<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self-Learning AI Betting System</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        .ai-badge {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto space-y-6">
        
        <!-- Header -->
        <div class="glass-card p-6">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-gray-900">ü§ñ Self-Learning AI Betting System</h1>
                    <p class="text-gray-600 mt-1">Advanced machine learning for profitable betting</p>
                </div>
                <div class="text-right">
                    <div class="text-sm text-gray-500">AI Status</div>
                    <div class="text-lg font-bold text-green-600">‚óè Learning</div>
                </div>
            </div>
        </div>

        <!-- AI Stats Dashboard -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div class="glass-card p-4">
                <div class="text-sm text-gray-500">Total Bets Analyzed</div>
                <div class="text-2xl font-bold text-gray-900" id="totalBets">0</div>
                <div class="text-xs text-gray-400 mt-1">Lifetime learning</div>
            </div>
            <div class="glass-card p-4">
                <div class="text-sm text-gray-500">Win Rate</div>
                <div class="text-2xl font-bold text-green-600" id="winRate">0%</div>
                <div class="text-xs text-gray-400 mt-1">AI accuracy</div>
            </div>
            <div class="glass-card p-4">
                <div class="text-sm text-gray-500">Best Bet Type</div>
                <div class="text-xl font-bold text-purple-600" id="confidence">Learning...</div>
                <div class="text-xs text-gray-400 mt-1">Top performer</div>
            </div>
            <div class="glass-card p-4">
                <div class="text-sm text-gray-500">Learning Cycles</div>
                <div class="text-2xl font-bold text-blue-600" id="cycles">0</div>
                <div class="text-xs text-gray-400 mt-1">Training iterations</div>
            </div>
        </div>

        <!-- Sport Selection -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">Select Sport</h2>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                <button onclick="selectSport('americanfootball_nfl', 'NFL')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèà</div>
                    <div class="font-semibold">NFL</div>
                </button>
                <button onclick="selectSport('basketball_nba', 'NBA')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèÄ</div>
                    <div class="font-semibold">NBA</div>
                </button>
                <button onclick="selectSport('icehockey_nhl', 'NHL')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèí</div>
                    <div class="font-semibold">NHL</div>
                </button>
                <button onclick="selectSport('baseball_mlb', 'MLB')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">‚öæ</div>
                    <div class="font-semibold">MLB</div>
                </button>
                <button onclick="selectSport('americanfootball_ncaaf', 'NCAAF')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üéì</div>
                    <div class="font-semibold">NCAAF</div>
                </button>
            </div>
            <div class="mt-4 text-center">
                <span class="text-gray-600">Selected: </span>
                <span class="font-bold text-purple-600" id="selectedSport">None</span>
            </div>
        </div>

        <!-- AI Control Panel -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üß† AI Control Panel</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button id="analyzeBtn" onclick="analyzeGames()" class="bg-gradient-to-r from-purple-600 to-blue-600 text-white font-bold py-4 px-6 rounded-lg hover:from-purple-700 hover:to-blue-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">üîç Analyze Games</div>
                    <div class="text-xs opacity-90">Find value bets with AI</div>
                </button>
                <button id="settleBtn" onclick="settleBets()" class="bg-gradient-to-r from-green-600 to-teal-600 text-white font-bold py-4 px-6 rounded-lg hover:from-green-700 hover:to-teal-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">‚úÖ Settle Results</div>
                    <div class="text-xs opacity-90">Get real game outcomes</div>
                </button>
                <button id="learnBtn" onclick="runLearningCycle()" class="bg-gradient-to-r from-orange-600 to-red-600 text-white font-bold py-4 px-6 rounded-lg hover:from-orange-700 hover:to-red-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">üéì Learn & Improve</div>
                    <div class="text-xs opacity-90">AI self-improvement</div>
                </button>
            </div>
        </div>

        <!-- Settlement Log -->
        <div id="settlementLog" class="glass-card p-6 hidden">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üìã Settlement Log</h2>
            <div id="logContent" class="space-y-1 text-sm font-mono max-h-96 overflow-y-auto bg-gray-900 p-4 rounded-lg"></div>
        </div>

        <!-- AI Predictions -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üéØ AI Predictions</h2>
            <div id="predictions" class="space-y-3">
                <div class="text-center text-gray-400 py-8">
                    Click "Analyze Games" to start AI analysis
                </div>
            </div>
        </div>

        <!-- Learning Insights -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üìä AI Learning Insights</h2>
            <div id="insights" class="space-y-4">
                <div class="text-center text-gray-400 py-8">
                    AI insights will appear after learning cycles
                </div>
            </div>
        </div>

    </div>

    <script>
        // Configuration
        const ODDS_API_KEY = '28beb23f0f84301404f98f2951928b52';
        let currentSport = null;
        let currentSportName = '';
        let predictions = [];
        
        // AI Learning Model
        class BettingAI {
            constructor() {
                this.loadModel();
            }
            
            loadModel() {
                const saved = localStorage.getItem('bettingAI_model');
                if (saved) {
                    this.model = JSON.parse(saved);
                    // Ensure new properties exist for older models
                    if (!this.model.betTypePerformance) {
                        this.model.betTypePerformance = {
                            Moneyline: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Spread: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Total: { wins: 0, losses: 0, total: 0, avgConfidence: 0 }
                        };
                    }
                    if (!this.model.confidenceRanges) {
                        this.model.confidenceRanges = {};
                    }
                    if (!this.model.weights.betTypePreference) {
                        this.model.weights.betTypePreference = {
                            Moneyline: 1.0,
                            Spread: 1.0,
                            Total: 1.0
                        };
                    }
                } else {
                    this.model = {
                        totalBets: 0,
                        wins: 0,
                        losses: 0,
                        learningCycles: 0,
                        betTypePerformance: {
                            Moneyline: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Spread: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Total: { wins: 0, losses: 0, total: 0, avgConfidence: 0 }
                        },
                        confidenceRanges: {},
                        patterns: {
                            spreadSuccess: { over: 0, under: 0, total: 0 },
                            moneylineSuccess: { favorite: 0, underdog: 0, total: 0 },
                            oddsRanges: {},
                            teamPerformance: {}
                        },
                        weights: {
                            oddsDiscrepancy: 1.0,
                            homeAdvantage: 0.3,
                            marketEfficiency: 0.5,
                            betTypePreference: {
                                Moneyline: 1.0,
                                Spread: 1.0,
                                Total: 1.0
                            }
                        }
                    };
                }
            }
            
            saveModel() {
                localStorage.setItem('bettingAI_model', JSON.stringify(this.model));
                updateStats();
            }
            
            analyzeGame(game) {
                if (!game.bookmakers || game.bookmakers.length < 2) return null;
                
                const homeTeam = game.home_team;
                const awayTeam = game.away_team;
                
                // Collect all odds types
                const h2hOdds = [];
                const spreadOdds = [];
                const totalOdds = [];
                
                game.bookmakers.forEach(book => {
                    const h2h = book.markets?.find(m => m.key === 'h2h');
                    const spread = book.markets?.find(m => m.key === 'spreads');
                    const totals = book.markets?.find(m => m.key === 'totals');
                    
                    if (h2h) h2hOdds.push(h2h.outcomes);
                    if (spread) spreadOdds.push(spread.outcomes);
                    if (totals) totalOdds.push(totals.outcomes);
                });
                
                // Array to store all potential bets
                const potentialBets = [];
                
                // 1. ANALYZE MONEYLINE BETS
                if (h2hOdds.length >= 2) {
                    const avgHomeOdds = this.calculateAverage(h2hOdds.map(o => o.find(x => x.name === homeTeam)?.price || 0));
                    const avgAwayOdds = this.calculateAverage(h2hOdds.map(o => o.find(x => x.name === awayTeam)?.price || 0));
                    
                    const bestHomeOdds = Math.max(...h2hOdds.map(o => o.find(x => x.name === homeTeam)?.price || 0));
                    const bestAwayOdds = Math.max(...h2hOdds.map(o => o.find(x => x.name === awayTeam)?.price || 0));
                    
                    const homeDiscrepancy = ((bestHomeOdds - avgHomeOdds) / avgHomeOdds) * 100;
                    const awayDiscrepancy = ((bestAwayOdds - avgAwayOdds) / avgAwayOdds) * 100;
                    
                    const homeImplied = this.oddsToProb(avgHomeOdds);
                    const awayImplied = this.oddsToProb(avgAwayOdds);
                    
                    const homeScore = homeDiscrepancy * this.model.weights.oddsDiscrepancy + 
                                     (5 * this.model.weights.homeAdvantage);
                    const awayScore = awayDiscrepancy * this.model.weights.oddsDiscrepancy;
                    
                    if (homeScore > 2) {
                        potentialBets.push({
                            team: homeTeam,
                            opponent: awayTeam,
                            odds: bestHomeOdds,
                            avgOdds: avgHomeOdds,
                            discrepancy: homeDiscrepancy.toFixed(2),
                            confidence: Math.min(95, 50 + homeScore * 5),
                            type: 'Moneyline',
                            betDetails: `${homeTeam} to Win`,
                            implied: homeImplied,
                            valueScore: homeScore
                        });
                    }
                    
                    if (awayScore > 2) {
                        potentialBets.push({
                            team: awayTeam,
                            opponent: homeTeam,
                            odds: bestAwayOdds,
                            avgOdds: avgAwayOdds,
                            discrepancy: awayDiscrepancy.toFixed(2),
                            confidence: Math.min(95, 50 + awayScore * 5),
                            type: 'Moneyline',
                            betDetails: `${awayTeam} to Win`,
                            implied: awayImplied,
                            valueScore: awayScore
                        });
                    }
                }
                
                // 2. ANALYZE SPREAD BETS
                if (spreadOdds.length >= 2) {
                    const homeSpreadData = [];
                    const awaySpreadData = [];
                    
                    spreadOdds.forEach(outcomes => {
                        const homeSpread = outcomes.find(o => o.name === homeTeam);
                        const awaySpread = outcomes.find(o => o.name === awayTeam);
                        if (homeSpread) homeSpreadData.push(homeSpread);
                        if (awaySpread) awaySpreadData.push(awaySpread);
                    });
                    
                    if (homeSpreadData.length > 0) {
                        const avgHomeSpreadOdds = this.calculateAverage(homeSpreadData.map(d => d.price));
                        const bestHomeSpreadOdds = Math.max(...homeSpreadData.map(d => d.price));
                        const avgHomeSpreadLine = this.calculateAverage(homeSpreadData.map(d => d.point));
                        const spreadDiscrepancy = ((bestHomeSpreadOdds - avgHomeSpreadOdds) / avgHomeSpreadOdds) * 100;
                        const spreadScore = spreadDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (spreadScore > 1.5 || bestHomeSpreadOdds > 100) {
                            potentialBets.push({
                                team: homeTeam,
                                opponent: awayTeam,
                                odds: bestHomeSpreadOdds,
                                avgOdds: avgHomeSpreadOdds,
                                discrepancy: spreadDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + spreadScore * 6),
                                type: 'Spread',
                                betDetails: `${homeTeam} ${avgHomeSpreadLine > 0 ? '+' : ''}${avgHomeSpreadLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgHomeSpreadOdds),
                                valueScore: spreadScore + 1,
                                spreadLine: avgHomeSpreadLine
                            });
                        }
                    }
                    
                    if (awaySpreadData.length > 0) {
                        const avgAwaySpreadOdds = this.calculateAverage(awaySpreadData.map(d => d.price));
                        const bestAwaySpreadOdds = Math.max(...awaySpreadData.map(d => d.price));
                        const avgAwaySpreadLine = this.calculateAverage(awaySpreadData.map(d => d.point));
                        const spreadDiscrepancy = ((bestAwaySpreadOdds - avgAwaySpreadOdds) / avgAwaySpreadOdds) * 100;
                        const spreadScore = spreadDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (spreadScore > 1.5 || bestAwaySpreadOdds > 100) {
                            potentialBets.push({
                                team: awayTeam,
                                opponent: homeTeam,
                                odds: bestAwaySpreadOdds,
                                avgOdds: avgAwaySpreadOdds,
                                discrepancy: spreadDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + spreadScore * 6),
                                type: 'Spread',
                                betDetails: `${awayTeam} ${avgAwaySpreadLine > 0 ? '+' : ''}${avgAwaySpreadLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgAwaySpreadOdds),
                                valueScore: spreadScore + 1,
                                spreadLine: avgAwaySpreadLine
                            });
                        }
                    }
                }
                
                // 3. ANALYZE TOTALS (Over/Under)
                if (totalOdds.length >= 2) {
                    const overData = [];
                    const underData = [];
                    
                    totalOdds.forEach(outcomes => {
                        const over = outcomes.find(o => o.name === 'Over');
                        const under = outcomes.find(o => o.name === 'Under');
                        if (over) overData.push(over);
                        if (under) underData.push(under);
                    });
                    
                    if (overData.length > 0) {
                        const avgOverOdds = this.calculateAverage(overData.map(d => d.price));
                        const bestOverOdds = Math.max(...overData.map(d => d.price));
                        const avgOverLine = this.calculateAverage(overData.map(d => d.point));
                        const totalDiscrepancy = ((bestOverOdds - avgOverOdds) / avgOverOdds) * 100;
                        const totalScore = totalDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (totalScore > 1.5 || bestOverOdds > 100) {
                            potentialBets.push({
                                team: 'Over',
                                opponent: `${homeTeam} vs ${awayTeam}`,
                                odds: bestOverOdds,
                                avgOdds: avgOverOdds,
                                discrepancy: totalDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + totalScore * 6),
                                type: 'Total',
                                betDetails: `Over ${avgOverLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgOverOdds),
                                valueScore: totalScore,
                                totalLine: avgOverLine
                            });
                        }
                    }
                    
                    if (underData.length > 0) {
                        const avgUnderOdds = this.calculateAverage(underData.map(d => d.price));
                        const bestUnderOdds = Math.max(...underData.map(d => d.price));
                        const avgUnderLine = this.calculateAverage(underData.map(d => d.point));
                        const totalDiscrepancy = ((bestUnderOdds - avgUnderOdds) / avgUnderOdds) * 100;
                        const totalScore = totalDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (totalScore > 1.5 || bestUnderOdds > 100) {
                            potentialBets.push({
                                team: 'Under',
                                opponent: `${homeTeam} vs ${awayTeam}`,
                                odds: bestUnderOdds,
                                avgOdds: avgUnderOdds,
                                discrepancy: totalDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + totalScore * 6),
                                type: 'Total',
                                betDetails: `Under ${avgUnderLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgUnderOdds),
                                valueScore: totalScore,
                                totalLine: avgUnderLine
                            });
                        }
                    }
                }
                
                // Pick the best bet based on value score AND learned preferences
                if (potentialBets.length === 0) return null;
                
                // Apply learned bet type preferences to adjust scores
                potentialBets.forEach(bet => {
                    const typePreference = this.model.weights.betTypePreference[bet.type] || 1.0;
                    bet.adjustedScore = bet.valueScore * typePreference;
                    
                    // Boost confidence based on historical performance
                    const typePerf = this.model.betTypePerformance[bet.type];
                    if (typePerf && typePerf.total > 5) {
                        const winRate = typePerf.wins / typePerf.total;
                        if (winRate > 0.55) {
                            bet.confidence = Math.min(95, bet.confidence * 1.1);
                        } else if (winRate < 0.45) {
                            bet.confidence = Math.max(40, bet.confidence * 0.9);
                        }
                    }
                });
                
                // Sort by adjusted score (value * learned preference)
                potentialBets.sort((a, b) => b.adjustedScore - a.adjustedScore);
                const pick = potentialBets[0];
                
                pick.game = `${awayTeam} @ ${homeTeam}`;
                pick.gameTime = game.commence_time;
                pick.gameId = game.id;
                
                return pick;
            }
            
            calculateAverage(arr) {
                const filtered = arr.filter(x => x > 0);
                return filtered.length > 0 ? filtered.reduce((a, b) => a + b, 0) / filtered.length : 0;
            }
            
            oddsToProb(odds) {
                if (odds > 0) {
                    return (100 / (odds + 100) * 100).toFixed(1);
                } else {
                    return (Math.abs(odds) / (Math.abs(odds) + 100) * 100).toFixed(1);
                }
            }
            
            recordResult(prediction, won) {
                this.model.totalBets++;
                if (won) {
                    this.model.wins++;
                } else {
                    this.model.losses++;
                }
                
                // Track performance by bet type
                const betType = prediction.type || 'Moneyline';
                if (!this.model.betTypePerformance[betType]) {
                    this.model.betTypePerformance[betType] = { wins: 0, losses: 0, total: 0, avgConfidence: 0 };
                }
                this.model.betTypePerformance[betType].total++;
                if (won) {
                    this.model.betTypePerformance[betType].wins++;
                } else {
                    this.model.betTypePerformance[betType].losses++;
                }
                
                // Track confidence level performance
                const confidenceRange = Math.floor(prediction.confidence / 10) * 10;
                if (!this.model.confidenceRanges[confidenceRange]) {
                    this.model.confidenceRanges[confidenceRange] = { wins: 0, total: 0 };
                }
                this.model.confidenceRanges[confidenceRange].total++;
                if (won) this.model.confidenceRanges[confidenceRange].wins++;
                
                // Update team performance tracking
                const team = prediction.team;
                if (!this.model.patterns.teamPerformance[team]) {
                    this.model.patterns.teamPerformance[team] = { wins: 0, total: 0 };
                }
                this.model.patterns.teamPerformance[team].total++;
                if (won) this.model.patterns.teamPerformance[team].wins++;
                
                this.saveModel();
            }
            
            learn() {
                this.model.learningCycles++;
                
                // Adjust weights based on overall success rates
                const winRate = this.model.wins / this.model.totalBets;
                
                if (winRate < 0.45) {
                    // Increase selectivity
                    this.model.weights.oddsDiscrepancy *= 1.1;
                    this.model.weights.marketEfficiency *= 1.05;
                } else if (winRate > 0.60) {
                    // Model is working, maintain
                    this.model.weights.oddsDiscrepancy *= 0.98;
                }
                
                // Adjust bet type preferences based on performance
                ['Moneyline', 'Spread', 'Total'].forEach(betType => {
                    const perf = this.model.betTypePerformance[betType];
                    if (perf && perf.total >= 5) {
                        const typeWinRate = perf.wins / perf.total;
                        
                        if (typeWinRate > 0.55) {
                            // This bet type is performing well - increase preference
                            this.model.weights.betTypePreference[betType] = Math.min(1.5, 
                                this.model.weights.betTypePreference[betType] * 1.05);
                        } else if (typeWinRate < 0.45) {
                            // This bet type is underperforming - decrease preference
                            this.model.weights.betTypePreference[betType] = Math.max(0.5, 
                                this.model.weights.betTypePreference[betType] * 0.95);
                        }
                    }
                });
                
                // Adjust confidence threshold based on confidence range performance
                let highConfidencePerformance = 0;
                let lowConfidencePerformance = 0;
                
                Object.keys(this.model.confidenceRanges).forEach(range => {
                    const rangeData = this.model.confidenceRanges[range];
                    if (rangeData.total >= 3) {
                        const rangeWinRate = rangeData.wins / rangeData.total;
                        if (parseInt(range) >= 70) {
                            highConfidencePerformance = rangeWinRate;
                        } else if (parseInt(range) <= 50) {
                            lowConfidencePerformance = rangeWinRate;
                        }
                    }
                });
                
                this.saveModel();
                
                return this.generateInsights();
            }
            
            generateInsights() {
                const winRate = ((this.model.wins / this.model.totalBets) * 100).toFixed(1);
                const insights = [];
                
                insights.push(`**Overall Win Rate**: ${winRate}% (${this.model.wins} wins, ${this.model.losses} losses)`);
                
                if (this.model.totalBets > 10) {
                    if (winRate > 55) {
                        insights.push(`‚úÖ **Strong Performance**: AI is beating the market by ${(winRate - 52.4).toFixed(1)}%`);
                    } else if (winRate < 45) {
                        insights.push(`‚ö†Ô∏è **Adjustment Needed**: Increasing selectivity to improve accuracy`);
                    }
                }
                
                // Bet type performance breakdown
                insights.push(`\n**üìä Bet Type Performance:**`);
                ['Moneyline', 'Spread', 'Total'].forEach(betType => {
                    const perf = this.model.betTypePerformance[betType];
                    if (perf && perf.total > 0) {
                        const typeWinRate = ((perf.wins / perf.total) * 100).toFixed(1);
                        const preference = (this.model.weights.betTypePreference[betType] * 100).toFixed(0);
                        const emoji = typeWinRate >= 55 ? 'üî•' : typeWinRate >= 50 ? '‚úÖ' : typeWinRate >= 45 ? '‚ö†Ô∏è' : '‚ùå';
                        insights.push(`  ${emoji} **${betType}**: ${typeWinRate}% (${perf.wins}/${perf.total}) - Preference: ${preference}%`);
                    }
                });
                
                insights.push(`\n**Current Strategy**: Focusing on odds discrepancies (weight: ${this.model.weights.oddsDiscrepancy.toFixed(2)})`);
                
                // Confidence calibration
                const confRanges = Object.keys(this.model.confidenceRanges).sort((a, b) => b - a);
                if (confRanges.length > 0) {
                    insights.push(`\n**üéØ Confidence Calibration:**`);
                    confRanges.forEach(range => {
                        const data = this.model.confidenceRanges[range];
                        if (data.total >= 3) {
                            const actualWinRate = ((data.wins / data.total) * 100).toFixed(1);
                            insights.push(`  ${range}-${parseInt(range) + 9}% confidence ‚Üí ${actualWinRate}% actual (${data.wins}/${data.total})`);
                        }
                    });
                }
                
                // Top performing teams
                const topTeams = Object.entries(this.model.patterns.teamPerformance)
                    .filter(([_, data]) => data.total >= 3)
                    .map(([team, data]) => ({ team, rate: (data.wins / data.total * 100).toFixed(0) }))
                    .sort((a, b) => b.rate - a.rate)
                    .slice(0, 3);
                
                if (topTeams.length > 0) {
                    insights.push(`**Top Teams**: ${topTeams.map(t => `${t.team} (${t.rate}%)`).join(', ')}`);
                }
                
                return insights;
            }
        }
        
        const ai = new BettingAI();
        
        function selectSport(sportKey, sportName) {
            currentSport = sportKey;
            currentSportName = sportName;
            document.getElementById('selectedSport').textContent = sportName;
            document.querySelectorAll('.sport-btn').forEach(btn => {
                btn.classList.remove('border-purple-500', 'bg-purple-50');
            });
            event.target.closest('.sport-btn').classList.add('border-purple-500', 'bg-purple-50');
        }
        
        async function analyzeGames() {
            if (!currentSport) {
                alert('Please select a sport first!');
                return;
            }
            
            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="text-lg">‚è≥ Analyzing...</div><div class="text-xs opacity-90">AI at work</div>';
            
            try {
                const url = `https://api.the-odds-api.com/v4/sports/${currentSport}/odds?apiKey=${ODDS_API_KEY}&regions=us&markets=h2h,spreads&oddsFormat=american`;
                console.log('Fetching:', url.replace(ODDS_API_KEY, 'KEY_HIDDEN'));
                
                const response = await fetch(url);
                console.log('Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`API error ${response.status}: ${errorText}`);
                }
                
                const games = await response.json();
                console.log(`Received ${games.length} games`);
                
                if (!Array.isArray(games) || games.length === 0) {
                    alert('‚ö†Ô∏è No games available for ' + currentSportName + ' right now. Try another sport!');
                    btn.disabled = false;
                    btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
                    return;
                }
                
                predictions = [];
                games.forEach(game => {
                    const pick = ai.analyzeGame(game);
                    if (pick) predictions.push(pick);
                });
                
                // Sort by confidence
                predictions.sort((a, b) => b.confidence - a.confidence);
                
                // Take top 5
                predictions = predictions.slice(0, 5);
                
                displayPredictions();
                
            } catch (error) {
                console.error('Full error:', error);
                alert('Error fetching games: ' + error.message + '\n\nCheck browser console for details.');
            }
            
            btn.disabled = false;
            btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
        }
        
        function displayPredictions() {
            const container = document.getElementById('predictions');
            
            if (predictions.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 py-8">No high-value bets found. AI is being selective! üéØ</div>';
                return;
            }
            
            container.innerHTML = predictions.map((p, i) => `
                <div class="border-2 ${p.settled ? (p.won ? 'border-green-400 bg-green-50' : 'border-red-400 bg-red-50') : 'border-gray-200'} rounded-lg p-4 hover:border-purple-400 transition">
                    <div class="flex items-start justify-between">
                        <div class="flex-1">
                            <div class="flex items-center gap-2">
                                <span class="text-2xl">${p.settled ? (p.won ? '‚úÖ' : '‚ùå') : (p.confidence > 70 ? 'ü§ñ' : 'üìä')}</span>
                                <div>
                                    <div class="font-bold text-lg text-gray-900">
                                        ${p.game}
                                        ${p.settled ? `<span class="ml-2 text-sm ${p.won ? 'text-green-600' : 'text-red-600'}">(${p.finalScore})</span>` : ''}
                                    </div>
                                    <div class="text-sm text-gray-500">
                                        ${new Date(p.gameTime).toLocaleString()}
                                        ${p.settled ? `<span class="ml-2 font-bold ${p.won ? 'text-green-600' : 'text-red-600'}">${p.won ? 'WON' : 'LOST'}</span>` : '<span class="ml-2 text-orange-600">PENDING</span>'}
                                    </div>
                                </div>
                            </div>
                            <div class="mt-3 space-y-2">
                                <div class="bg-purple-100 rounded-lg p-2 border-2 border-purple-300">
                                    <div class="text-xs text-purple-700 font-semibold">üìå ${p.type || 'Moneyline'} Bet</div>
                                    <div class="font-bold text-lg text-purple-900">${p.betDetails || p.team}</div>
                                </div>
                                <div class="grid grid-cols-3 gap-2">
                                    <div>
                                        <div class="text-xs text-gray-500">Best Odds</div>
                                        <div class="font-bold text-green-600">${p.odds > 0 ? '+' : ''}${p.odds}</div>
                                    </div>
                                    <div>
                                        <div class="text-xs text-gray-500">Value</div>
                                        <div class="font-bold text-orange-600">+${p.discrepancy}%</div>
                                    </div>
                                    <div>
                                        <div class="text-xs text-gray-500">Win Prob</div>
                                        <div class="font-bold text-blue-600">${p.implied}%</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="ml-4 text-right">
                            <div class="text-xs text-gray-500">AI Confidence</div>
                            <div class="text-3xl font-bold text-purple-600">${p.confidence.toFixed(0)}%</div>
                            ${p.confidence > 70 ? '<div class="text-xs text-green-600 font-bold mt-1">‚ú® HIGH CONFIDENCE</div>' : ''}
                        </div>
                    </div>
                    <div class="mt-3 pt-3 border-t border-gray-200">
                        <div class="text-xs text-gray-600">
                            <strong>AI Analysis:</strong> Detected ${p.discrepancy}% odds advantage. Market inefficiency suggests value bet on ${p.betDetails || p.team}.
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        async function settleBets() {
            if (predictions.length === 0) {
                alert('No predictions to settle. Analyze games first!');
                return;
            }
            
            // Show settlement log
            const logDiv = document.getElementById('settlementLog');
            const logContent = document.getElementById('logContent');
            logDiv.classList.remove('hidden');
            logContent.innerHTML = '';
            
            function addLog(message, type = 'info') {
                const colors = {
                    'info': 'text-gray-300',
                    'success': 'text-green-400',
                    'error': 'text-red-400',
                    'warning': 'text-yellow-400',
                    'header': 'text-blue-400 font-bold'
                };
                const log = document.createElement('div');
                log.className = colors[type];
                log.textContent = message;
                logContent.appendChild(log);
                logContent.scrollTop = logContent.scrollHeight;
                console.log(message);
            }
            
            const btn = document.getElementById('settleBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="text-lg">‚è≥ Settling...</div><div class="text-xs opacity-90">Getting results</div>';
            
            try {
                addLog('üîç Starting settlement process...', 'header');
                addLog('', 'info');
                addLog(`üì° Fetching scores from API for ${currentSport}...`, 'info');
                
                const response = await fetch(`https://api.the-odds-api.com/v4/sports/${currentSport}/scores?apiKey=${ODDS_API_KEY}&daysFrom=3`);
                const scores = await response.json();
                
                addLog(`‚úÖ Received ${scores.length} game results from API`, 'success');
                addLog(`üìä Checking ${predictions.length} predictions...`, 'info');
                addLog('', 'info');
                addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                
                let settled = 0;
                let wins = 0;
                let losses = 0;
                
                predictions.forEach((pred, index) => {
                    addLog('', 'info');
                    
                    if (pred.settled) {
                        addLog(`‚è≠Ô∏è  Prediction #${index + 1}: Already settled`, 'warning');
                        addLog(`   Game: ${pred.game}`, 'warning');
                        return;
                    }
                    
                    const score = scores.find(s => s.id === pred.gameId);
                    
                    if (!score) {
                        addLog(`‚è∞ Prediction #${index + 1}: Game not found in results`, 'warning');
                        addLog(`   Game: ${pred.game}`, 'warning');
                        addLog(`   GameID: ${pred.gameId}`, 'warning');
                        return;
                    }
                    
                    if (!score.completed) {
                        addLog(`‚è∞ Prediction #${index + 1}: Game not completed yet`, 'warning');
                        addLog(`   Game: ${score.away_team} @ ${score.home_team}`, 'warning');
                        addLog(`   Status: In Progress`, 'warning');
                        return;
                    }
                    
                    const homeScore = score.scores?.find(s => s.name === score.home_team)?.score;
                    const awayScore = score.scores?.find(s => s.name === score.away_team)?.score;
                    
                    addLog(`üèà Prediction #${index + 1}: ${score.away_team} @ ${score.home_team}`, 'header');
                    addLog(`   Final Score: ${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`, 'info');
                    addLog(`   AI Picked: ${pred.team} (${pred.confidence}% confidence)`, 'info');
                    
                    if (homeScore !== undefined && awayScore !== undefined) {
                        let won = false;
                        let resultDetails = '';
                        
                        // Determine result based on bet type
                        if (pred.type === 'Moneyline') {
                            // Moneyline: Did the picked team win?
                            let winner;
                            if (homeScore > awayScore) {
                                winner = score.home_team;
                                resultDetails = `${score.home_team} won by ${homeScore - awayScore}`;
                            } else if (awayScore > homeScore) {
                                winner = score.away_team;
                                resultDetails = `${score.away_team} won by ${awayScore - homeScore}`;
                            } else {
                                winner = 'TIE';
                                resultDetails = 'Game ended in TIE';
                            }
                            won = winner === pred.team;
                            addLog(`   üèÜ Result: ${resultDetails}`, 'info');
                            
                        } else if (pred.type === 'Spread') {
                            // Spread: Apply the spread line to determine winner
                            const spreadLine = pred.spreadLine || 0;
                            const isHomePick = pred.team === score.home_team;
                            
                            if (isHomePick) {
                                const homeWithSpread = homeScore + spreadLine;
                                won = homeWithSpread > awayScore;
                                resultDetails = `${score.home_team} ${spreadLine > 0 ? '+' : ''}${spreadLine.toFixed(1)} ‚Üí Adjusted: ${homeWithSpread.toFixed(1)} vs ${awayScore}`;
                            } else {
                                const awayWithSpread = awayScore + spreadLine;
                                won = awayWithSpread > homeScore;
                                resultDetails = `${score.away_team} ${spreadLine > 0 ? '+' : ''}${spreadLine.toFixed(1)} ‚Üí Adjusted: ${awayWithSpread.toFixed(1)} vs ${homeScore}`;
                            }
                            addLog(`   üìä Spread Result: ${resultDetails}`, 'info');
                            
                        } else if (pred.type === 'Total') {
                            // Total: Did the combined score go over/under the line?
                            const totalLine = pred.totalLine || 0;
                            const actualTotal = homeScore + awayScore;
                            
                            if (pred.team === 'Over') {
                                won = actualTotal > totalLine;
                                resultDetails = `Total: ${actualTotal} (Line: ${totalLine}) - ${won ? 'OVER' : 'UNDER'}`;
                            } else if (pred.team === 'Under') {
                                won = actualTotal < totalLine;
                                resultDetails = `Total: ${actualTotal} (Line: ${totalLine}) - ${won ? 'UNDER' : 'OVER'}`;
                            }
                            addLog(`   üéØ Total Result: ${resultDetails}`, 'info');
                        }
                        
                        // Log final result
                        if (won) {
                            addLog(`   ‚úÖ RESULT: AI WON! ${pred.betDetails}`, 'success');
                            wins++;
                        } else {
                            addLog(`   ‚ùå RESULT: AI LOST - ${pred.betDetails}`, 'error');
                            losses++;
                        }
                        
                        // Record to AI model
                        ai.recordResult(pred, won);
                        pred.settled = true;
                        pred.won = won;
                        pred.finalScore = `${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`;
                        settled++;
                        
                        addLog(`   üíæ Result recorded to AI model`, 'info');
                        
                    } else {
                        addLog(`   ‚ö†Ô∏è Score data incomplete or missing`, 'error');
                        addLog(`   Home Score: ${homeScore}, Away Score: ${awayScore}`, 'error');
                    }
                });
                
                addLog('', 'info');
                addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                addLog('üìà SETTLEMENT SUMMARY', 'header');
                addLog(`   Total Bets Settled: ${settled}`, 'success');
                addLog(`   Wins: ${wins} ‚úÖ`, 'success');
                addLog(`   Losses: ${losses} ‚ùå`, 'error');
                
                if (settled > 0) {
                    const winRate = ((wins / settled) * 100).toFixed(1);
                    const profitable = winRate >= 52.4;
                    addLog(`   Win Rate: ${winRate}% ${profitable ? 'üéØ' : ''}`, profitable ? 'success' : 'warning');
                    addLog(`   ${profitable ? 'üí∞ Profitable!' : 'üìä Keep learning...'}`, profitable ? 'success' : 'warning');
                    
                    displayPredictions();
                    alert(`‚úÖ Settled ${settled} bets!\n\nWins: ${wins} ‚úÖ\nLosses: ${losses} ‚ùå\nWin Rate: ${winRate}%\n\nAI is learning from results...`);
                } else {
                    addLog('   ‚è∞ No games finished yet', 'warning');
                    alert('‚è∞ Games not finished yet. Check back later!');
                }
                
            } catch (error) {
                addLog('', 'info');
                addLog(`‚ùå ERROR: ${error.message}`, 'error');
                console.error('Settlement error:', error);
                alert('Error fetching scores: ' + error.message);
            }
            
            btn.disabled = false;
            btn.innerHTML = '<div class="text-lg">‚úÖ Settle Results</div><div class="text-xs opacity-90">Get real game outcomes</div>';
        }
        
        function runLearningCycle() {
            const insights = ai.learn();
            
            const container = document.getElementById('insights');
            container.innerHTML = `
                <div class="bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-200 rounded-lg p-6">
                    <h3 class="text-lg font-bold text-purple-900 mb-3">üéì AI Learning Complete</h3>
                    <div class="space-y-2 text-sm text-gray-700">
                        ${insights.map(insight => `<div>‚Ä¢ ${insight}</div>`).join('')}
                    </div>
                </div>
            `;
            
            updateStats();
            
            alert('üß† AI has completed a learning cycle and updated its strategy!');
        }
        
        function updateStats() {
            const totalBets = ai.model.totalBets;
            const winRate = totalBets > 0 ? ((ai.model.wins / totalBets) * 100).toFixed(1) : '0';
            
            // Calculate best bet type
            let bestBetType = 'Learning...';
            let bestWinRate = 0;
            ['Moneyline', 'Spread', 'Total'].forEach(type => {
                const perf = ai.model.betTypePerformance[type];
                if (perf && perf.total >= 3) {
                    const typeRate = (perf.wins / perf.total) * 100;
                    if (typeRate > bestWinRate) {
                        bestWinRate = typeRate;
                        bestBetType = `${type} (${typeRate.toFixed(1)}%)`;
                    }
                }
            });
            
            document.getElementById('totalBets').textContent = totalBets;
            document.getElementById('winRate').textContent = winRate + '%';
            document.getElementById('confidence').textContent = bestBetType;
            document.getElementById('cycles').textContent = ai.model.learningCycles;
        }
        
        // Initialize
        updateStats();
    </script>
</body>
</html>
