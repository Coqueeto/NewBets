<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Self-Learning AI Betting System v2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.45);
        }
        .ai-badge {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .slide-in {
            animation: slideIn 0.5s ease-out;
        }
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
        .shimmer {
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
        }
        .progress-bar {
            transition: width 0.5s ease;
        }
        .stat-increase {
            animation: statPop 0.5s ease;
        }
        @keyframes statPop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto space-y-6">
        
        <!-- Header -->
        <div class="glass-card p-6">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-gray-900">ü§ñ Self-Learning AI Betting System</h1>
                    <p class="text-gray-600 mt-1">Advanced machine learning for profitable betting <span class="text-xs text-purple-600 font-mono">v2.0</span></p>
                </div>
                <div class="text-right">
                    <div class="text-sm text-gray-500">AI Status</div>
                    <div class="text-lg font-bold text-green-600">‚óè Learning</div>
                </div>
            </div>
        </div>

        <!-- AI Stats Dashboard -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500 flex justify-between items-center">
                    <span>Total Bets Analyzed</span>
                    <span class="text-xs" id="trendIndicator"></span>
                </div>
                <div class="text-2xl font-bold text-gray-900" id="totalBets">0</div>
                <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                    <div class="bg-gradient-to-r from-blue-500 to-purple-600 h-2 rounded-full progress-bar" id="totalBetsProgress" style="width: 0%"></div>
                </div>
                <div class="text-xs text-gray-400 mt-1">Lifetime learning</div>
            </div>
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500 flex justify-between items-center">
                    <span>Win Rate</span>
                    <span class="text-xs font-bold" id="winRateTrend"></span>
                </div>
                <div class="text-2xl font-bold text-green-600" id="winRate">0%</div>
                <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                    <div class="bg-gradient-to-r from-green-400 to-emerald-600 h-2 rounded-full progress-bar" id="winRateProgress" style="width: 0%"></div>
                </div>
                <div class="text-xs mt-1" id="winRateSubtext">AI accuracy</div>
            </div>
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500">Best Bet Type</div>
                <div class="text-xl font-bold text-purple-600 gradient-text" id="confidence">Learning...</div>
                <div class="text-xs text-gray-400 mt-1">Top performer</div>
                <div class="text-xs font-semibold mt-2" id="recentStreak"></div>
            </div>
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500">Learning Cycles</div>
                <div class="text-2xl font-bold text-blue-600" id="cycles">0</div>
                <div class="text-xs text-gray-400 mt-1">Training iterations</div>
                <div class="text-xs font-semibold mt-2 text-purple-600" id="momentum"></div>
            </div>
        </div>

        <!-- Sport Selection -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">Select Sport</h2>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                <button onclick="selectSport('americanfootball_nfl', 'NFL')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèà</div>
                    <div class="font-semibold">NFL</div>
                </button>
                <button onclick="selectSport('basketball_nba', 'NBA')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèÄ</div>
                    <div class="font-semibold">NBA</div>
                </button>
                <button onclick="selectSport('icehockey_nhl', 'NHL')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèí</div>
                    <div class="font-semibold">NHL</div>
                </button>
                <button onclick="selectSport('baseball_mlb', 'MLB')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">‚öæ</div>
                    <div class="font-semibold">MLB</div>
                </button>
                <button onclick="selectSport('americanfootball_ncaaf', 'NCAAF')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üéì</div>
                    <div class="font-semibold">NCAAF</div>
                </button>
            </div>
            <div class="mt-4 text-center">
                <span class="text-gray-600">Selected: </span>
                <span class="font-bold text-purple-600" id="selectedSport">None</span>
            </div>
        </div>

        <!-- AI Control Panel -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üß† AI Control Panel</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button id="analyzeBtn" onclick="analyzeGames()" class="bg-gradient-to-r from-purple-600 to-blue-600 text-white font-bold py-4 px-6 rounded-lg hover:from-purple-700 hover:to-blue-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">üîç Analyze Games</div>
                    <div class="text-xs opacity-90">Find value bets with AI</div>
                </button>
                <button id="settleBtn" onclick="settleBets()" class="bg-gradient-to-r from-green-600 to-teal-600 text-white font-bold py-4 px-6 rounded-lg hover:from-green-700 hover:to-teal-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">‚úÖ Settle Results</div>
                    <div class="text-xs opacity-90">Get real game outcomes</div>
                </button>
                <button id="learnBtn" onclick="runLearningCycle()" class="bg-gradient-to-r from-orange-600 to-red-600 text-white font-bold py-4 px-6 rounded-lg hover:from-orange-700 hover:to-red-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">üéì Learn & Improve</div>
                    <div class="text-xs opacity-90">AI self-improvement</div>
                </button>
            </div>
            <div class="mt-4 text-center">
                <button onclick="clearAllBets()" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded text-sm">
                    üóëÔ∏è Clear All Bets
                </button>
            </div>
        </div>

        <!-- Settlement Log -->
        <div id="settlementLog" class="glass-card p-6 hidden">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üìã Settlement Log</h2>
            <div id="logContent" class="space-y-1 text-sm font-mono max-h-96 overflow-y-auto bg-gray-900 p-4 rounded-lg"></div>
        </div>

        <!-- AI Predictions -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üéØ AI Predictions</h2>
            <div id="predictions" class="space-y-3">
                <div class="text-center text-gray-400 py-8">
                    Click "Analyze Games" to start AI analysis
                </div>
            </div>
        </div>

        <!-- Learning Insights -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üìä AI Learning Insights</h2>
            <div id="insights" class="space-y-4">
                <div class="text-center text-gray-400 py-8">
                    AI insights will appear after learning cycles
                </div>
            </div>
        </div>

    </div>

    <script>
        // Configuration
        const ODDS_API_KEY = '28beb23f0f84301404f98f2951928b52';
        let currentSport = null;
        let currentSportName = '';
        let predictions = [];
        
        // Load predictions from localStorage on startup
        function loadPredictions() {
            const saved = localStorage.getItem('predictions');
            if (saved) {
                try {
                    predictions = JSON.parse(saved);
                    console.log(`Loaded ${predictions.length} saved predictions`);
                } catch (e) {
                    console.error('Error loading predictions:', e);
                    predictions = [];
                }
            }
        }
        
        // Save predictions to localStorage
        function savePredictions() {
            localStorage.setItem('predictions', JSON.stringify(predictions));
        }
        
        // AI Learning Model
        class BettingAI {
            constructor() {
                this.loadModel();
            }
            
            loadModel() {
                const saved = localStorage.getItem('bettingAI_model');
                if (saved) {
                    this.model = JSON.parse(saved);
                    // Ensure new properties exist for older models
                    if (!this.model.betTypePerformance) {
                        this.model.betTypePerformance = {
                            Moneyline: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Spread: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Total: { wins: 0, losses: 0, total: 0, avgConfidence: 0 }
                        };
                    }
                    if (!this.model.confidenceRanges) {
                        this.model.confidenceRanges = {};
                    }
                    if (!this.model.weights.betTypePreference) {
                        this.model.weights.betTypePreference = {
                            Moneyline: 1.0,
                            Spread: 1.0,
                            Total: 1.0
                        };
                    }
                } else {
                    this.model = {
                        totalBets: 0,
                        wins: 0,
                        losses: 0,
                        learningCycles: 0,
                        betTypePerformance: {
                            Moneyline: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Spread: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Total: { wins: 0, losses: 0, total: 0, avgConfidence: 0 }
                        },
                        confidenceRanges: {},
                        betHistory: [], // Track all completed bets
                        recentTrend: { last10: [], last20: [], currentStreak: 0, streakType: null },
                        patterns: {
                            spreadSuccess: { over: 0, under: 0, total: 0 },
                            moneylineSuccess: { favorite: 0, underdog: 0, total: 0 },
                            homeAwayPerformance: { home: { wins: 0, losses: 0 }, away: { wins: 0, losses: 0 } },
                            oddsRanges: {},
                            teamPerformance: {},
                            timeOfDaySuccess: { early: 0, mid: 0, late: 0 },
                            dayOfWeekSuccess: {}
                        },
                        weights: {
                            oddsDiscrepancy: 1.0,
                            homeAdvantage: 0.3,
                            marketEfficiency: 0.5,
                            recentMomentum: 0.0,
                            betTypePreference: {
                                Moneyline: 1.0,
                                Spread: 1.0,
                                Total: 1.0
                            }
                        },
                        adaptiveThresholds: {
                            minConfidence: 50,
                            minDiscrepancy: 2.0,
                            minOdds: -200
                        }
                    };
                }
                
                // Ensure betHistory exists for older models
                if (!this.model.betHistory) {
                    this.model.betHistory = [];
                }
                if (!this.model.patterns.homeAwayPerformance) {
                    this.model.patterns.homeAwayPerformance = { 
                        home: { wins: 0, losses: 0 }, 
                        away: { wins: 0, losses: 0 } 
                    };
                }
            }
            
            saveModel() {
                localStorage.setItem('bettingAI_model', JSON.stringify(this.model));
                updateStats();
            }
            
            analyzeGame(game) {
                if (!game.bookmakers || game.bookmakers.length < 2) return null;
                
                const homeTeam = game.home_team;
                const awayTeam = game.away_team;
                
                // Collect all odds types
                const h2hOdds = [];
                const spreadOdds = [];
                const totalOdds = [];
                
                game.bookmakers.forEach(book => {
                    const h2h = book.markets?.find(m => m.key === 'h2h');
                    const spread = book.markets?.find(m => m.key === 'spreads');
                    const totals = book.markets?.find(m => m.key === 'totals');
                    
                    if (h2h) h2hOdds.push(h2h.outcomes);
                    if (spread) spreadOdds.push(spread.outcomes);
                    if (totals) totalOdds.push(totals.outcomes);
                });
                
                // Array to store all potential bets
                const potentialBets = [];
                
                // 1. ANALYZE MONEYLINE BETS
                if (h2hOdds.length >= 2) {
                    const avgHomeOdds = this.calculateAverage(h2hOdds.map(o => o.find(x => x.name === homeTeam)?.price || 0));
                    const avgAwayOdds = this.calculateAverage(h2hOdds.map(o => o.find(x => x.name === awayTeam)?.price || 0));
                    
                    const bestHomeOdds = Math.max(...h2hOdds.map(o => o.find(x => x.name === homeTeam)?.price || 0));
                    const bestAwayOdds = Math.max(...h2hOdds.map(o => o.find(x => x.name === awayTeam)?.price || 0));
                    
                    const homeDiscrepancy = ((bestHomeOdds - avgHomeOdds) / avgHomeOdds) * 100;
                    const awayDiscrepancy = ((bestAwayOdds - avgAwayOdds) / avgAwayOdds) * 100;
                    
                    const homeImplied = this.oddsToProb(avgHomeOdds);
                    const awayImplied = this.oddsToProb(avgAwayOdds);
                    
                    const homeScore = homeDiscrepancy * this.model.weights.oddsDiscrepancy + 
                                     (5 * this.model.weights.homeAdvantage);
                    const awayScore = awayDiscrepancy * this.model.weights.oddsDiscrepancy;
                    
                    if (homeScore > 2) {
                        potentialBets.push({
                            team: homeTeam,
                            opponent: awayTeam,
                            isHomeTeam: true,
                            odds: bestHomeOdds,
                            avgOdds: avgHomeOdds,
                            discrepancy: homeDiscrepancy.toFixed(2),
                            confidence: Math.min(95, 50 + homeScore * 5),
                            type: 'Moneyline',
                            betDetails: `${homeTeam} to Win`,
                            implied: homeImplied,
                            valueScore: homeScore
                        });
                    }
                    
                    if (awayScore > 2) {
                        potentialBets.push({
                            team: awayTeam,
                            opponent: homeTeam,
                            isHomeTeam: false,
                            odds: bestAwayOdds,
                            avgOdds: avgAwayOdds,
                            discrepancy: awayDiscrepancy.toFixed(2),
                            confidence: Math.min(95, 50 + awayScore * 5),
                            type: 'Moneyline',
                            betDetails: `${awayTeam} to Win`,
                            implied: awayImplied,
                            valueScore: awayScore
                        });
                    }
                }
                
                // 2. ANALYZE SPREAD BETS
                if (spreadOdds.length >= 2) {
                    const homeSpreadData = [];
                    const awaySpreadData = [];
                    
                    spreadOdds.forEach(outcomes => {
                        const homeSpread = outcomes.find(o => o.name === homeTeam);
                        const awaySpread = outcomes.find(o => o.name === awayTeam);
                        if (homeSpread) homeSpreadData.push(homeSpread);
                        if (awaySpread) awaySpreadData.push(awaySpread);
                    });
                    
                    if (homeSpreadData.length > 0) {
                        const avgHomeSpreadOdds = this.calculateAverage(homeSpreadData.map(d => d.price));
                        const bestHomeSpreadOdds = Math.max(...homeSpreadData.map(d => d.price));
                        const avgHomeSpreadLine = this.calculateAverage(homeSpreadData.map(d => d.point));
                        const spreadDiscrepancy = ((bestHomeSpreadOdds - avgHomeSpreadOdds) / avgHomeSpreadOdds) * 100;
                        const spreadScore = spreadDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (spreadScore > 1.5 || bestHomeSpreadOdds > 100) {
                            potentialBets.push({
                                team: homeTeam,
                                opponent: awayTeam,
                                isHomeTeam: true,
                                odds: bestHomeSpreadOdds,
                                avgOdds: avgHomeSpreadOdds,
                                discrepancy: spreadDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + spreadScore * 6),
                                type: 'Spread',
                                betDetails: `${homeTeam} ${avgHomeSpreadLine > 0 ? '+' : ''}${avgHomeSpreadLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgHomeSpreadOdds),
                                valueScore: spreadScore + 1,
                                spreadLine: avgHomeSpreadLine
                            });
                        }
                    }
                    
                    if (awaySpreadData.length > 0) {
                        const avgAwaySpreadOdds = this.calculateAverage(awaySpreadData.map(d => d.price));
                        const bestAwaySpreadOdds = Math.max(...awaySpreadData.map(d => d.price));
                        const avgAwaySpreadLine = this.calculateAverage(awaySpreadData.map(d => d.point));
                        const spreadDiscrepancy = ((bestAwaySpreadOdds - avgAwaySpreadOdds) / avgAwaySpreadOdds) * 100;
                        const spreadScore = spreadDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (spreadScore > 1.5 || bestAwaySpreadOdds > 100) {
                            potentialBets.push({
                                team: awayTeam,
                                opponent: homeTeam,
                                isHomeTeam: false,
                                odds: bestAwaySpreadOdds,
                                avgOdds: avgAwaySpreadOdds,
                                discrepancy: spreadDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + spreadScore * 6),
                                type: 'Spread',
                                betDetails: `${awayTeam} ${avgAwaySpreadLine > 0 ? '+' : ''}${avgAwaySpreadLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgAwaySpreadOdds),
                                valueScore: spreadScore + 1,
                                spreadLine: avgAwaySpreadLine
                            });
                        }
                    }
                }
                
                // 3. ANALYZE TOTALS (Over/Under)
                if (totalOdds.length >= 2) {
                    const overData = [];
                    const underData = [];
                    
                    totalOdds.forEach(outcomes => {
                        const over = outcomes.find(o => o.name === 'Over');
                        const under = outcomes.find(o => o.name === 'Under');
                        if (over) overData.push(over);
                        if (under) underData.push(under);
                    });
                    
                    if (overData.length > 0) {
                        const avgOverOdds = this.calculateAverage(overData.map(d => d.price));
                        const bestOverOdds = Math.max(...overData.map(d => d.price));
                        const avgOverLine = this.calculateAverage(overData.map(d => d.point));
                        const totalDiscrepancy = ((bestOverOdds - avgOverOdds) / avgOverOdds) * 100;
                        const totalScore = totalDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (totalScore > 1.5 || bestOverOdds > 100) {
                            potentialBets.push({
                                team: 'Over',
                                opponent: `${homeTeam} vs ${awayTeam}`,
                                odds: bestOverOdds,
                                avgOdds: avgOverOdds,
                                discrepancy: totalDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + totalScore * 6),
                                type: 'Total',
                                betDetails: `Over ${avgOverLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgOverOdds),
                                valueScore: totalScore,
                                totalLine: avgOverLine
                            });
                        }
                    }
                    
                    if (underData.length > 0) {
                        const avgUnderOdds = this.calculateAverage(underData.map(d => d.price));
                        const bestUnderOdds = Math.max(...underData.map(d => d.price));
                        const avgUnderLine = this.calculateAverage(underData.map(d => d.point));
                        const totalDiscrepancy = ((bestUnderOdds - avgUnderOdds) / avgUnderOdds) * 100;
                        const totalScore = totalDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (totalScore > 1.5 || bestUnderOdds > 100) {
                            potentialBets.push({
                                team: 'Under',
                                opponent: `${homeTeam} vs ${awayTeam}`,
                                odds: bestUnderOdds,
                                avgOdds: avgUnderOdds,
                                discrepancy: totalDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + totalScore * 6),
                                type: 'Total',
                                betDetails: `Under ${avgUnderLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgUnderOdds),
                                valueScore: totalScore,
                                totalLine: avgUnderLine
                            });
                        }
                    }
                }
                
                // Pick the best bet based on value score AND learned preferences
                if (potentialBets.length === 0) return null;
                
                // Apply learned bet type preferences to adjust scores
                potentialBets.forEach(bet => {
                    const typePreference = this.model.weights.betTypePreference[bet.type] || 1.0;
                    bet.adjustedScore = bet.valueScore * typePreference;
                    
                    // Start with calculated confidence
                    let adjustedConfidence = bet.confidence;
                    
                    // Factor 1: Historical bet type performance
                    const typePerf = this.model.betTypePerformance[bet.type];
                    if (typePerf && typePerf.total > 10) {
                        const winRate = typePerf.wins / typePerf.total;
                        if (winRate > 0.60) {
                            adjustedConfidence *= 1.15; // Strong bet type - boost 15%
                        } else if (winRate > 0.55) {
                            adjustedConfidence *= 1.08; // Good bet type - boost 8%
                        } else if (winRate < 0.45) {
                            adjustedConfidence *= 0.85; // Weak bet type - reduce 15%
                        }
                    }
                    
                    // Factor 2: Team historical performance
                    const teamPerf = this.model.patterns.teamPerformance[bet.team];
                    if (teamPerf && teamPerf.total >= 5) {
                        const teamWinRate = teamPerf.wins / teamPerf.total;
                        if (teamWinRate > 0.65) {
                            adjustedConfidence *= 1.12; // Hot team - boost 12%
                        } else if (teamWinRate < 0.35) {
                            adjustedConfidence *= 0.88; // Cold team - reduce 12%
                        }
                    }
                    
                    // Factor 3: Home/Away performance alignment
                    if (bet.isHomeTeam !== undefined) {
                        const position = bet.isHomeTeam ? 'home' : 'away';
                        const posPerf = this.model.patterns.homeAwayPerformance[position];
                        const posTotal = posPerf.wins + posPerf.losses;
                        if (posTotal >= 10) {
                            const posWinRate = posPerf.wins / posTotal;
                            if (posWinRate > 0.58) {
                                adjustedConfidence *= 1.08; // Strong position record
                            } else if (posWinRate < 0.42) {
                                adjustedConfidence *= 0.92; // Weak position record
                            }
                        }
                    }
                    
                    // Factor 4: Recent momentum boost
                    if (this.model.weights.recentMomentum > 0) {
                        adjustedConfidence *= 1.05; // Hot streak - slight boost
                    } else if (this.model.weights.recentMomentum < 0) {
                        adjustedConfidence *= 0.93; // Cold streak - be cautious
                    }
                    
                    // Factor 5: High odds discrepancy = high confidence
                    if (parseFloat(bet.discrepancy) > 5.0) {
                        adjustedConfidence *= 1.10; // Huge value found
                    } else if (parseFloat(bet.discrepancy) > 3.5) {
                        adjustedConfidence *= 1.05; // Good value
                    }
                    
                    // Apply adaptive threshold - only accept if meets minimum
                    const minConfidence = this.model.adaptiveThresholds?.minConfidence || 50;
                    if (adjustedConfidence < minConfidence) {
                        bet.confidence = 0; // Reject - below threshold
                        return;
                    }
                    
                    // Cap confidence appropriately
                    bet.confidence = Math.min(99, Math.max(40, adjustedConfidence));
                });
                
                // Filter out rejected bets (confidence = 0)
                potentialBets = potentialBets.filter(b => b.confidence > 0);
                
                if (potentialBets.length === 0) return null;
                
                // Sort by adjusted score (value * learned preference)
                potentialBets.sort((a, b) => b.adjustedScore - a.adjustedScore);
                const pick = potentialBets[0];
                
                pick.game = `${awayTeam} @ ${homeTeam}`;
                pick.gameTime = game.commence_time;
                pick.gameId = game.id;
                
                // Only assign confidence tier emoji if AI has proven itself (80%+ win rate)
                const aiWinRate = this.model.totalBets > 0 ? (this.model.wins / this.model.totalBets) : 0;
                
                if (aiWinRate >= 0.80 && this.model.totalBets >= 20) {
                    // AI has proven itself - show confidence tiers
                    if (pick.confidence >= 95) {
                        pick.confidenceTier = 'üíé'; // Diamond - Elite (95-99%)
                        pick.tierName = 'ELITE';
                        pick.showTier = true;
                    } else if (pick.confidence >= 85) {
                        pick.confidenceTier = 'üî•'; // Fire - Premium (85-94%)
                        pick.tierName = 'PREMIUM';
                        pick.showTier = true;
                    } else if (pick.confidence >= 75) {
                        pick.confidenceTier = '‚≠ê'; // Star - Strong (75-84%)
                        pick.tierName = 'STRONG';
                        pick.showTier = true;
                    } else if (pick.confidence >= 65) {
                        pick.confidenceTier = '‚úÖ'; // Check - Good (65-74%)
                        pick.tierName = 'GOOD';
                        pick.showTier = true;
                    } else {
                        pick.confidenceTier = 'üìä'; // Chart - Standard (50-64%)
                        pick.tierName = 'STANDARD';
                        pick.showTier = true;
                    }
                } else {
                    // AI still learning - no tier badges
                    pick.confidenceTier = null;
                    pick.tierName = 'LEARNING';
                    pick.showTier = false;
                }
                
                // Mark super elite bets when AI has 95%+ win rate
                if (aiWinRate >= 0.95 && this.model.totalBets >= 30) {
                    pick.superElite = true;
                    pick.aiMastery = true;
                }
                
                return pick;
            }
            
            calculateAverage(arr) {
                const filtered = arr.filter(x => x > 0);
                return filtered.length > 0 ? filtered.reduce((a, b) => a + b, 0) / filtered.length : 0;
            }
            
            oddsToProb(odds) {
                if (odds > 0) {
                    return (100 / (odds + 100) * 100).toFixed(1);
                } else {
                    return (Math.abs(odds) / (Math.abs(odds) + 100) * 100).toFixed(1);
                }
            }
            
            recordResult(prediction, won) {
                this.model.totalBets++;
                if (won) {
                    this.model.wins++;
                } else {
                    this.model.losses++;
                }
                
                // Update recent trend tracking
                if (!this.model.recentTrend) {
                    this.model.recentTrend = { last10: [], last20: [], currentStreak: 0, streakType: null };
                }
                
                // Add to recent results
                this.model.recentTrend.last10.unshift(won);
                this.model.recentTrend.last20.unshift(won);
                if (this.model.recentTrend.last10.length > 10) this.model.recentTrend.last10.pop();
                if (this.model.recentTrend.last20.length > 20) this.model.recentTrend.last20.pop();
                
                // Update streak
                if (this.model.recentTrend.streakType === (won ? 'win' : 'loss')) {
                    this.model.recentTrend.currentStreak++;
                } else {
                    this.model.recentTrend.currentStreak = 1;
                    this.model.recentTrend.streakType = won ? 'win' : 'loss';
                }
                
                // Determine if bet was on home or away team
                const betOnHome = prediction.isHomeTeam !== undefined ? prediction.isHomeTeam : false;
                const betPosition = betOnHome ? 'home' : 'away';
                
                // Track home/away performance
                if (won) {
                    this.model.patterns.homeAwayPerformance[betPosition].wins++;
                } else {
                    this.model.patterns.homeAwayPerformance[betPosition].losses++;
                }
                
                // Track performance by bet type
                const betType = prediction.type || 'Moneyline';
                if (!this.model.betTypePerformance[betType]) {
                    this.model.betTypePerformance[betType] = { wins: 0, losses: 0, total: 0, avgConfidence: 0 };
                }
                this.model.betTypePerformance[betType].total++;
                if (won) {
                    this.model.betTypePerformance[betType].wins++;
                } else {
                    this.model.betTypePerformance[betType].losses++;
                }
                
                // Track confidence level performance
                const confidenceRange = Math.floor(prediction.confidence / 10) * 10;
                if (!this.model.confidenceRanges[confidenceRange]) {
                    this.model.confidenceRanges[confidenceRange] = { wins: 0, total: 0 };
                }
                this.model.confidenceRanges[confidenceRange].total++;
                if (won) this.model.confidenceRanges[confidenceRange].wins++;
                
                // Update team performance tracking
                const team = prediction.team;
                if (!this.model.patterns.teamPerformance[team]) {
                    this.model.patterns.teamPerformance[team] = { wins: 0, total: 0 };
                }
                this.model.patterns.teamPerformance[team].total++;
                if (won) this.model.patterns.teamPerformance[team].wins++;
                
                // Track time-based patterns
                const gameDate = new Date(prediction.gameTime);
                const dayOfWeek = gameDate.toLocaleDateString('en-US', { weekday: 'long' });
                if (!this.model.patterns.dayOfWeekSuccess[dayOfWeek]) {
                    this.model.patterns.dayOfWeekSuccess[dayOfWeek] = { wins: 0, total: 0 };
                }
                this.model.patterns.dayOfWeekSuccess[dayOfWeek].total++;
                if (won) this.model.patterns.dayOfWeekSuccess[dayOfWeek].wins++;
                
                // Add to bet history (keep last 100)
                this.model.betHistory.unshift({
                    date: new Date().toISOString(),
                    game: prediction.game,
                    sport: prediction.sport || 'Unknown',
                    betType: betType,
                    betDetails: prediction.betDetails || prediction.team,
                    team: prediction.team,
                    position: betPosition,
                    odds: prediction.odds,
                    confidence: prediction.confidence,
                    won: won,
                    finalScore: prediction.finalScore
                });
                
                // Keep only last 100 bets
                if (this.model.betHistory.length > 100) {
                    this.model.betHistory = this.model.betHistory.slice(0, 100);
                }
                
                // Auto-learn after every result
                this.learn();
                
                this.saveModel();
            }
            
            learn() {
                this.model.learningCycles++;
                
                // Adjust weights based on overall success rates
                const winRate = this.model.wins / this.model.totalBets;
                
                // Calculate recent momentum (last 10 bets)
                let recentWinRate = 0;
                if (this.model.recentTrend && this.model.recentTrend.last10.length > 0) {
                    const recentWins = this.model.recentTrend.last10.filter(w => w).length;
                    recentWinRate = recentWins / this.model.recentTrend.last10.length;
                    
                    // Adjust momentum weight based on recent performance
                    if (recentWinRate > 0.60) {
                        this.model.weights.recentMomentum = 0.2; // Hot streak
                    } else if (recentWinRate < 0.40) {
                        this.model.weights.recentMomentum = -0.2; // Cold streak, be cautious
                    } else {
                        this.model.weights.recentMomentum = 0;
                    }
                }
                
                // Adaptive thresholds based on performance
                if (!this.model.adaptiveThresholds) {
                    this.model.adaptiveThresholds = { minConfidence: 50, minDiscrepancy: 2.0, minOdds: -200 };
                }
                
                if (winRate < 0.45) {
                    // Increase selectivity - raise thresholds
                    this.model.weights.oddsDiscrepancy *= 1.15;
                    this.model.weights.marketEfficiency *= 1.08;
                    this.model.adaptiveThresholds.minConfidence = Math.min(70, this.model.adaptiveThresholds.minConfidence + 2);
                    this.model.adaptiveThresholds.minDiscrepancy = Math.min(4.0, this.model.adaptiveThresholds.minDiscrepancy + 0.2);
                } else if (winRate > 0.55) {
                    // Model is working well - can be slightly less conservative
                    this.model.weights.oddsDiscrepancy *= 0.97;
                    this.model.adaptiveThresholds.minConfidence = Math.max(45, this.model.adaptiveThresholds.minConfidence - 1);
                    this.model.adaptiveThresholds.minDiscrepancy = Math.max(1.5, this.model.adaptiveThresholds.minDiscrepancy - 0.1);
                }
                
                // Adjust bet type preferences based on performance
                ['Moneyline', 'Spread', 'Total'].forEach(betType => {
                    const perf = this.model.betTypePerformance[betType];
                    if (perf && perf.total >= 5) {
                        const typeWinRate = perf.wins / perf.total;
                        
                        if (typeWinRate > 0.55) {
                            // This bet type is performing well - increase preference significantly
                            this.model.weights.betTypePreference[betType] = Math.min(1.8, 
                                this.model.weights.betTypePreference[betType] * 1.08);
                        } else if (typeWinRate < 0.45) {
                            // This bet type is underperforming - decrease preference more aggressively
                            this.model.weights.betTypePreference[betType] = Math.max(0.4, 
                                this.model.weights.betTypePreference[betType] * 0.92);
                        }
                    }
                });
                
                // Adjust confidence threshold based on confidence range performance
                let highConfidencePerformance = 0;
                let lowConfidencePerformance = 0;
                
                Object.keys(this.model.confidenceRanges).forEach(range => {
                    const rangeData = this.model.confidenceRanges[range];
                    if (rangeData.total >= 3) {
                        const rangeWinRate = rangeData.wins / rangeData.total;
                        if (parseInt(range) >= 70) {
                            highConfidencePerformance = rangeWinRate;
                        } else if (parseInt(range) <= 50) {
                            lowConfidencePerformance = rangeWinRate;
                        }
                    }
                });
                
                this.saveModel();
                
                return this.generateInsights();
            }
            
            generateInsights() {
                const winRate = ((this.model.wins / this.model.totalBets) * 100).toFixed(1);
                const insights = [];
                
                insights.push(`**Overall Win Rate**: ${winRate}% (${this.model.wins} wins, ${this.model.losses} losses)`);
                
                if (this.model.totalBets > 10) {
                    if (winRate > 55) {
                        insights.push(`‚úÖ **Strong Performance**: AI is beating the market by ${(winRate - 52.4).toFixed(1)}%`);
                    } else if (winRate < 45) {
                        insights.push(`‚ö†Ô∏è **Adjustment Needed**: Increasing selectivity to improve accuracy`);
                    }
                }
                
                // Bet type performance breakdown
                insights.push(`\n**üìä Bet Type Performance:**`);
                ['Moneyline', 'Spread', 'Total'].forEach(betType => {
                    const perf = this.model.betTypePerformance[betType];
                    if (perf && perf.total > 0) {
                        const typeWinRate = ((perf.wins / perf.total) * 100).toFixed(1);
                        const preference = (this.model.weights.betTypePreference[betType] * 100).toFixed(0);
                        const emoji = typeWinRate >= 55 ? 'üî•' : typeWinRate >= 50 ? '‚úÖ' : typeWinRate >= 45 ? '‚ö†Ô∏è' : '‚ùå';
                        insights.push(`  ${emoji} **${betType}**: ${typeWinRate}% (${perf.wins}/${perf.total}) - Preference: ${preference}%`);
                    }
                });
                
                // Home vs Away performance
                const homePerf = this.model.patterns.homeAwayPerformance.home;
                const awayPerf = this.model.patterns.homeAwayPerformance.away;
                const homeTotal = homePerf.wins + homePerf.losses;
                const awayTotal = awayPerf.wins + awayPerf.losses;
                
                if (homeTotal > 0 || awayTotal > 0) {
                    insights.push(`\n**üè† Home vs Away Performance:**`);
                    if (homeTotal > 0) {
                        const homeWinRate = ((homePerf.wins / homeTotal) * 100).toFixed(1);
                        insights.push(`  üè† Home Teams: ${homeWinRate}% (${homePerf.wins}/${homeTotal})`);
                    }
                    if (awayTotal > 0) {
                        const awayWinRate = ((awayPerf.wins / awayTotal) * 100).toFixed(1);
                        insights.push(`  ‚úàÔ∏è Away Teams: ${awayWinRate}% (${awayPerf.wins}/${awayTotal})`);
                    }
                }
                
                insights.push(`\n**Current Strategy**: Focusing on odds discrepancies (weight: ${this.model.weights.oddsDiscrepancy.toFixed(2)})`);
                
                // Confidence calibration
                const confRanges = Object.keys(this.model.confidenceRanges).sort((a, b) => b - a);
                if (confRanges.length > 0) {
                    insights.push(`\n**üéØ Confidence Calibration:**`);
                    confRanges.forEach(range => {
                        const data = this.model.confidenceRanges[range];
                        if (data.total >= 3) {
                            const actualWinRate = ((data.wins / data.total) * 100).toFixed(1);
                            insights.push(`  ${range}-${parseInt(range) + 9}% confidence ‚Üí ${actualWinRate}% actual (${data.wins}/${data.total})`);
                        }
                    });
                }
                
                // Top performing teams
                const topTeams = Object.entries(this.model.patterns.teamPerformance)
                    .filter(([_, data]) => data.total >= 3)
                    .map(([team, data]) => ({ team, rate: (data.wins / data.total * 100).toFixed(0) }))
                    .sort((a, b) => b.rate - a.rate)
                    .slice(0, 3);
                
                if (topTeams.length > 0) {
                    insights.push(`**Top Teams**: ${topTeams.map(t => `${t.team} (${t.rate}%)`).join(', ')}`);
                }
                
                return insights;
            }
        }
        
        const ai = new BettingAI();
        
        function selectSport(sportKey, sportName) {
            currentSport = sportKey;
            currentSportName = sportName;
            document.getElementById('selectedSport').textContent = sportName;
            document.querySelectorAll('.sport-btn').forEach(btn => {
                btn.classList.remove('border-purple-500', 'bg-purple-50');
            });
            event.target.closest('.sport-btn').classList.add('border-purple-500', 'bg-purple-50');
        }
        
        async function analyzeGames() {
            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="text-lg">‚è≥ Analyzing...</div><div class="text-xs opacity-90">Checking all sports...</div>';
            
            try {
                // All sports to analyze
                const sports = [
                    { key: 'americanfootball_nfl', name: 'NFL', emoji: 'üèà' },
                    { key: 'basketball_nba', name: 'NBA', emoji: 'üèÄ' },
                    { key: 'icehockey_nhl', name: 'NHL', emoji: 'üèí' },
                    { key: 'baseball_mlb', name: 'MLB', emoji: '‚öæ' },
                    { key: 'americanfootball_ncaaf', name: 'NCAAF', emoji: 'üéì' }
                ];
                
                const newPredictions = [];
                const existingGameIds = new Set(predictions.map(p => p.gameId));
                
                // Track existing ML bets by team to prevent contradictions
                const existingMLTeams = new Map();
                predictions.forEach(p => {
                    if (p.type === 'Moneyline') {
                        // Store the team and opponent for this ML bet
                        existingMLTeams.set(p.team, p.opponent);
                    }
                });
                
                for (const sport of sports) {
                    console.log(`Analyzing ${sport.name}...`);
                    
                    try {
                        const url = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${ODDS_API_KEY}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`;
                        const response = await fetch(url);
                        
                        if (!response.ok) continue;
                        
                        const games = await response.json();
                        console.log(`${sport.name}: ${games.length} games`);
                        
                        games.forEach(game => {
                            // Skip if we already have any prediction for this game
                            if (existingGameIds.has(game.id)) {
                                console.log(`Skipping ${game.id} - already have prediction`);
                                return;
                            }
                            
                            const pick = ai.analyzeGame(game);
                            if (pick) {
                                // Check if this is a ML bet that contradicts an existing ML bet
                                if (pick.type === 'Moneyline') {
                                    // Check if we already have a ML bet for either team in this matchup
                                    if (existingMLTeams.has(pick.team)) {
                                        console.log(`‚ö†Ô∏è Already have ML bet for ${pick.team} - keeping original pick`);
                                        return;
                                    }
                                    if (existingMLTeams.has(pick.opponent)) {
                                        console.log(`‚ö†Ô∏è Already have ML bet for ${pick.opponent} - keeping original pick`);
                                        return;
                                    }
                                }
                                
                                pick.sport = sport.name;
                                pick.sportEmoji = sport.emoji;
                                console.log('AI Pick:', pick);
                                newPredictions.push(pick);
                            }
                        });
                    } catch (error) {
                        console.error(`Error analyzing ${sport.name}:`, error);
                    }
                }
                
                console.log(`Generated ${newPredictions.length} new predictions`);
                console.log(`Keeping ${predictions.length} existing predictions`);
                
                if (newPredictions.length === 0) {
                    const msg = predictions.length > 0 
                        ? `‚è∞ No new high-value bets found. Keeping your ${predictions.length} active predictions!`
                        : '‚è∞ No high-value bets found across all sports. AI is being selective!';
                    alert(msg);
                    btn.disabled = false;
                    btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
                    return;
                }
                
                const oldCount = predictions.length;
                
                // Sort new predictions by confidence
                newPredictions.sort((a, b) => b.confidence - a.confidence);
                
                // Add ALL new predictions to existing ones (keep ALL old ones)
                predictions.push(...newPredictions);
                
                // Sort all predictions by confidence
                predictions.sort((a, b) => b.confidence - a.confidence);
                
                // Save to localStorage
                savePredictions();
                
                console.log(`Total predictions: ${predictions.length} (${oldCount} kept + ${newPredictions.length} new)`);
                
                displayPredictions();
                
                // Only show tier breakdown if AI has earned it
                const aiWinRate = ai.model.totalBets > 0 ? (ai.model.wins / ai.model.totalBets) : 0;
                let alertMsg = `‚úÖ Added ${newPredictions.length} new bets! Total active: ${predictions.length} (kept ${oldCount} existing)\n\n`;
                
                if (aiWinRate >= 0.95 && ai.model.totalBets >= 30) {
                    const superElite = newPredictions.filter(p => p.superElite).length;
                    if (superElite > 0) {
                        alertMsg += `\nüí∞üíéüí∞ AI MASTER MODE ACTIVE! üí∞üíéüí∞\n`;
                        alertMsg += `${superElite} MONEY MAKER BET${superElite > 1 ? 'S' : ''}!\n`;
                        alertMsg += `AI Win Rate: ${(aiWinRate * 100).toFixed(1)}% üî•\n`;
                    }
                } else if (aiWinRate >= 0.80 && ai.model.totalBets >= 20) {
                    const eliteBets = newPredictions.filter(p => p.confidence >= 95).length;
                    const premiumBets = newPredictions.filter(p => p.confidence >= 85 && p.confidence < 95).length;
                    const strongBets = newPredictions.filter(p => p.confidence >= 75 && p.confidence < 85).length;
                    if (eliteBets > 0) alertMsg += `üíé ELITE bets (95%+): ${eliteBets}\n`;
                    if (premiumBets > 0) alertMsg += `üî• PREMIUM bets (85-94%): ${premiumBets}\n`;
                    if (strongBets > 0) alertMsg += `‚≠ê STRONG bets (75-84%): ${strongBets}\n`;
                } else {
                    alertMsg += `üß† AI is learning... (${ai.model.totalBets} bets analyzed)\n`;
                    alertMsg += `Need ${Math.max(0, 20 - ai.model.totalBets)} more bets to unlock confidence tiers`;
                }
                
                alert(alertMsg);
                
            } catch (error) {
                console.error('Full error:', error);
                alert('Error fetching games: ' + error.message + '\n\nCheck browser console for details.');
            }
            
            btn.disabled = false;
            btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
        }
        
        function displayPredictions() {
            const container = document.getElementById('predictions');
            
            if (predictions.length === 0) {
                container.innerHTML = '<div class="text-center text-gray-400 py-8">No high-value bets found. AI is being selective! üéØ</div>';
                return;
            }
            
            container.innerHTML = predictions.map((p, i) => {
                // Ensure all properties exist
                const betType = p.type || 'Moneyline';
                const betDetails = p.betDetails || `${p.team} to Win`;
                const sportDisplay = p.sport ? `${p.sportEmoji || ''} ${p.sport}` : '';
                const gameDate = new Date(p.gameTime);
                const now = new Date();
                const isToday = gameDate.toDateString() === now.toDateString();
                const isTomorrow = gameDate.toDateString() === new Date(now.getTime() + 86400000).toDateString();
                
                let dateStr = '';
                if (isToday) dateStr = 'Today';
                else if (isTomorrow) dateStr = 'Tomorrow';
                else dateStr = gameDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                
                const timeStr = gameDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                
                // Calculate potential payout for display
                const odds = p.odds || 0;
                let payout100 = 0;
                let payout500 = 0;
                let payout1000 = 0;
                if (odds > 0) {
                    payout100 = 100 + (100 * odds / 100);
                    payout500 = 500 + (500 * odds / 100);
                    payout1000 = 1000 + (1000 * odds / 100);
                } else if (odds < 0) {
                    payout100 = 100 + (100 * 100 / Math.abs(odds));
                    payout500 = 500 + (500 * 100 / Math.abs(odds));
                    payout1000 = 1000 + (1000 * 100 / Math.abs(odds));
                }
                
                // Determine border color based on confidence tier and AI mastery
                let borderClass = 'border-gray-200';
                let bgClass = '';
                if (p.settled) {
                    borderClass = p.won ? 'border-green-400' : 'border-red-400';
                    bgClass = p.won ? 'bg-green-50' : 'bg-red-50';
                } else if (p.superElite && p.showTier) {
                    // AI has 95%+ win rate - SUPER OBVIOUS
                    borderClass = 'border-8 border-yellow-400 shadow-2xl animate-pulse';
                    bgClass = 'bg-gradient-to-r from-yellow-100 via-green-100 to-yellow-100';
                } else if (p.showTier && p.confidence >= 95) {
                    borderClass = 'border-purple-500 shadow-lg';
                    bgClass = 'bg-gradient-to-r from-purple-50 to-pink-50';
                } else if (p.showTier && p.confidence >= 85) {
                    borderClass = 'border-orange-500';
                    bgClass = 'bg-orange-50';
                } else if (p.showTier && p.confidence >= 75) {
                    borderClass = 'border-yellow-400';
                    bgClass = 'bg-yellow-50';
                }
                
                return `
                <div class="border-2 ${borderClass} ${bgClass} rounded-lg p-4 hover:border-purple-400 transition slide-in">
                    <!-- Super Elite Money Alert (AI 95%+ Win Rate) -->
                    ${p.superElite && p.showTier && !p.settled ? `
                        <div class="mb-3 p-4 bg-gradient-to-r from-yellow-400 via-green-400 to-yellow-400 rounded-lg border-4 border-yellow-600 animate-pulse">
                            <div class="text-center">
                                <div class="text-3xl mb-2">üí∞ üíé üí∞ MONEY MAKER üí∞ üíé üí∞</div>
                                <div class="text-lg font-black text-gray-900">AI MASTER PICK - ${p.confidence.toFixed(0)}% CONFIDENCE</div>
                                <div class="text-sm font-bold text-gray-800 mt-2">POTENTIAL PAYOUT:</div>
                                <div class="flex justify-around mt-2 text-gray-900 font-bold">
                                    <div>$100 ‚Üí <span class="text-green-700 text-xl">$${payout100.toFixed(0)}</span></div>
                                    <div>$500 ‚Üí <span class="text-green-700 text-xl">$${payout500.toFixed(0)}</span></div>
                                    <div>$1000 ‚Üí <span class="text-green-700 text-2xl">$${payout1000.toFixed(0)}</span></div>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- Confidence Tier Badge (Only if AI earned it with 80%+ win rate) -->
                    ${p.showTier && p.confidenceTier && !p.settled && !p.superElite ? `
                        <div class="flex items-center justify-between mb-2">
                            <div class="inline-block ${p.confidence >= 95 ? 'bg-gradient-to-r from-purple-600 to-pink-600' : p.confidence >= 85 ? 'bg-gradient-to-r from-orange-500 to-red-500' : 'bg-gradient-to-r from-yellow-500 to-orange-500'} text-white text-xs font-bold px-3 py-1 rounded-full">
                                ${p.confidenceTier} ${p.tierName} BET
                            </div>
                            ${sportDisplay ? `<div class="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-2 py-1 rounded">${sportDisplay}</div>` : ''}
                        </div>
                    ` : `
                        ${sportDisplay ? `<div class="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-2 py-1 rounded mb-2">${sportDisplay}</div>` : ''}
                    `}
                    
                    <!-- Game Header -->
                    <div class="flex items-center gap-2 mb-3">
                        <span class="text-4xl">${p.settled ? (p.won ? '‚úÖ' : '‚ùå') : (p.confidenceTier || 'üìä')}</span>
                        <div class="flex-1">
                            <div class="font-bold text-base text-gray-900">
                                ${p.game}
                            </div>
                            <div class="text-xs text-gray-500">
                                üìÖ ${dateStr} at ${timeStr}
                                ${p.settled ? `<span class="ml-2 font-bold ${p.won ? 'text-green-600' : 'text-red-600'}">${p.won ? 'WON' : 'LOST'}</span>` : '<span class="ml-2 text-orange-600">PENDING</span>'}
                            </div>
                        </div>
                        ${p.showTier && !p.superElite ? `
                            <div class="text-right">
                                <div class="text-xs text-gray-400">Confidence</div>
                                <div class="text-2xl font-bold ${p.confidence >= 85 ? 'text-green-600' : 'text-purple-600'}">${p.confidence.toFixed(0)}%</div>
                            </div>
                        ` : !p.settled ? `
                            <div class="text-right">
                                <div class="text-xs text-gray-400">Status</div>
                                <div class="text-sm font-bold text-blue-600">üß† Learning</div>
                            </div>
                        ` : ''}
                    </div>
                    
                    ${p.settled && p.finalScore ? `
                    <div class="mb-3 p-2 bg-gray-100 rounded text-center">
                        <div class="text-xs text-gray-500">Final Score</div>
                        <div class="font-bold text-sm text-gray-900">${p.finalScore}</div>
                    </div>
                    ` : ''}
                    
                    <!-- Bet Details - PROMINENT DISPLAY -->
                    <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg p-3 mb-3">
                        <div class="text-xs font-semibold opacity-90 mb-1">üìå ${betType.toUpperCase()}</div>
                        <div class="text-xl font-bold">${betDetails}</div>
                        <div class="text-sm opacity-90 mt-1">@ ${p.odds > 0 ? '+' : ''}${p.odds}</div>
                    </div>
                    
                    <!-- Stats Grid -->
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-green-50 rounded p-2">
                            <div class="text-xs text-green-700">Best Odds</div>
                            <div class="font-bold text-green-600">${p.odds > 0 ? '+' : ''}${p.odds}</div>
                        </div>
                        <div class="bg-orange-50 rounded p-2">
                            <div class="text-xs text-orange-700">Value</div>
                            <div class="font-bold text-orange-600">+${p.discrepancy}%</div>
                        </div>
                        <div class="bg-blue-50 rounded p-2">
                            <div class="text-xs text-blue-700">Win Prob</div>
                            <div class="font-bold text-blue-600">${p.implied}%</div>
                        </div>
                    </div>
                    
                    ${p.confidence > 70 ? '<div class="mt-2 text-center text-xs text-green-600 font-bold">‚ú® HIGH CONFIDENCE BET</div>' : ''}
                </div>
                `;
            }).join('');
        }
        
        async function settleBets(silentMode = false) {
            if (predictions.length === 0) {
                if (!silentMode) alert('No predictions to settle. Analyze games first!');
                return;
            }
            
            // Show settlement log
            const logDiv = document.getElementById('settlementLog');
            const logContent = document.getElementById('logContent');
            if (!silentMode) {
                logDiv.classList.remove('hidden');
                logContent.innerHTML = '';
            }
            
            function addLog(message, type = 'info') {
                const colors = {
                    'info': 'text-gray-300',
                    'success': 'text-green-400',
                    'error': 'text-red-400',
                    'warning': 'text-yellow-400',
                    'header': 'text-blue-400 font-bold'
                };
                if (!silentMode) {
                    const log = document.createElement('div');
                    log.className = colors[type];
                    log.textContent = message;
                    logContent.appendChild(log);
                    logContent.scrollTop = logContent.scrollHeight;
                }
                console.log(message);
            }
            
            const btn = document.getElementById('settleBtn');
            if (!silentMode) {
                btn.disabled = true;
                btn.innerHTML = '<div class="text-lg">‚è≥ Settling...</div><div class="text-xs opacity-90">Getting results</div>';
            }
            
            try {
                addLog('üîç Starting settlement process...', 'header');
                addLog('', 'info');
                addLog(`üì° Fetching scores from API for all sports...`, 'info');
                
                // Fetch scores from all sports
                const sports = [
                    'americanfootball_nfl',
                    'basketball_nba',
                    'icehockey_nhl',
                    'baseball_mlb',
                    'americanfootball_ncaaf'
                ];
                
                let allScores = [];
                for (const sport of sports) {
                    try {
                        const response = await fetch(`https://api.the-odds-api.com/v4/sports/${sport}/scores?apiKey=${ODDS_API_KEY}&daysFrom=3`);
                        if (response.ok) {
                            const scores = await response.json();
                            if (Array.isArray(scores)) {
                                allScores = allScores.concat(scores);
                            }
                        }
                    } catch (e) {
                        console.error(`Error fetching ${sport} scores:`, e);
                    }
                }
                
                addLog(`‚úÖ Received ${allScores.length} game results from API`, 'success');
                addLog(`üìä Checking ${predictions.length} predictions...`, 'info');
                addLog('', 'info');
                addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                
                let settled = 0;
                let wins = 0;
                let losses = 0;
                
                predictions.forEach((pred, index) => {
                    addLog('', 'info');
                    
                    if (pred.settled) {
                        addLog(`‚è≠Ô∏è  Prediction #${index + 1}: Already settled`, 'warning');
                        addLog(`   Game: ${pred.game}`, 'warning');
                        return;
                    }
                    
                    const score = allScores.find(s => s.id === pred.gameId);
                    
                    if (!score) {
                        addLog(`‚è∞ Prediction #${index + 1}: Game not found in results`, 'warning');
                        addLog(`   Game: ${pred.game}`, 'warning');
                        addLog(`   GameID: ${pred.gameId}`, 'warning');
                        return;
                    }
                    
                    if (!score.completed) {
                        addLog(`‚è∞ Prediction #${index + 1}: Game not completed yet`, 'warning');
                        addLog(`   Game: ${score.away_team} @ ${score.home_team}`, 'warning');
                        addLog(`   Status: In Progress`, 'warning');
                        return;
                    }
                    
                    const homeScore = score.scores?.find(s => s.name === score.home_team)?.score;
                    const awayScore = score.scores?.find(s => s.name === score.away_team)?.score;
                    
                    addLog(`üèà Prediction #${index + 1}: ${score.away_team} @ ${score.home_team}`, 'header');
                    addLog(`   Final Score: ${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`, 'info');
                    addLog(`   AI Picked: ${pred.team} (${pred.confidence}% confidence)`, 'info');
                    
                    if (homeScore !== undefined && awayScore !== undefined) {
                        let won = false;
                        let resultDetails = '';
                        
                        // Determine result based on bet type
                        if (pred.type === 'Moneyline') {
                            // Moneyline: Did the picked team win?
                            let winner;
                            if (homeScore > awayScore) {
                                winner = score.home_team;
                                resultDetails = `${score.home_team} won by ${homeScore - awayScore}`;
                            } else if (awayScore > homeScore) {
                                winner = score.away_team;
                                resultDetails = `${score.away_team} won by ${awayScore - homeScore}`;
                            } else {
                                winner = 'TIE';
                                resultDetails = 'Game ended in TIE';
                            }
                            won = winner === pred.team;
                            addLog(`   üèÜ Result: ${resultDetails}`, 'info');
                            
                        } else if (pred.type === 'Spread') {
                            // Spread: Apply the spread line to determine winner
                            const spreadLine = pred.spreadLine || 0;
                            const isHomePick = pred.team === score.home_team;
                            
                            if (isHomePick) {
                                const homeWithSpread = homeScore + spreadLine;
                                won = homeWithSpread > awayScore;
                                resultDetails = `${score.home_team} ${spreadLine > 0 ? '+' : ''}${spreadLine.toFixed(1)} ‚Üí Adjusted: ${homeWithSpread.toFixed(1)} vs ${awayScore}`;
                            } else {
                                const awayWithSpread = awayScore + spreadLine;
                                won = awayWithSpread > homeScore;
                                resultDetails = `${score.away_team} ${spreadLine > 0 ? '+' : ''}${spreadLine.toFixed(1)} ‚Üí Adjusted: ${awayWithSpread.toFixed(1)} vs ${homeScore}`;
                            }
                            addLog(`   üìä Spread Result: ${resultDetails}`, 'info');
                            
                        } else if (pred.type === 'Total') {
                            // Total: Did the combined score go over/under the line?
                            const totalLine = pred.totalLine || 0;
                            const actualTotal = homeScore + awayScore;
                            
                            if (pred.team === 'Over') {
                                won = actualTotal > totalLine;
                                resultDetails = `Total: ${actualTotal} (Line: ${totalLine}) - ${won ? 'OVER' : 'UNDER'}`;
                            } else if (pred.team === 'Under') {
                                won = actualTotal < totalLine;
                                resultDetails = `Total: ${actualTotal} (Line: ${totalLine}) - ${won ? 'UNDER' : 'OVER'}`;
                            }
                            addLog(`   üéØ Total Result: ${resultDetails}`, 'info');
                        }
                        
                        // Log final result
                        if (won) {
                            addLog(`   ‚úÖ RESULT: AI WON! ${pred.betDetails}`, 'success');
                            wins++;
                        } else {
                            addLog(`   ‚ùå RESULT: AI LOST - ${pred.betDetails}`, 'error');
                            losses++;
                        }
                        
                        // Record to AI model
                        ai.recordResult(pred, won);
                        pred.settled = true;
                        pred.won = won;
                        pred.finalScore = `${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`;
                        settled++;
                        
                        addLog(`   üíæ Result recorded to AI model`, 'info');
                        
                    } else {
                        addLog(`   ‚ö†Ô∏è Score data incomplete or missing`, 'error');
                        addLog(`   Home Score: ${homeScore}, Away Score: ${awayScore}`, 'error');
                    }
                });
                
                addLog('', 'info');
                addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                addLog('üìà SETTLEMENT SUMMARY', 'header');
                addLog(`   Total Bets Settled: ${settled}`, 'success');
                addLog(`   Wins: ${wins} ‚úÖ`, 'success');
                addLog(`   Losses: ${losses} ‚ùå`, 'error');
                
                if (settled > 0) {
                    const winRate = ((wins / settled) * 100).toFixed(1);
                    const profitable = winRate >= 52.4;
                    addLog(`   Win Rate: ${winRate}% ${profitable ? 'üéØ' : ''}`, profitable ? 'success' : 'warning');
                    addLog(`   ${profitable ? 'üí∞ Profitable!' : 'üìä Keep learning...'}`, profitable ? 'success' : 'warning');
                    
                    // Remove settled predictions from the list
                    addLog('', 'info');
                    addLog('üóëÔ∏è Removing settled bets from active list...', 'info');
                    const beforeCount = predictions.length;
                    predictions = predictions.filter(p => !p.settled);
                    const removedCount = beforeCount - predictions.length;
                    addLog(`   Removed ${removedCount} settled bets`, 'success');
                    addLog(`   ${predictions.length} active bets remaining`, 'info');
                    
                    savePredictions(); // Save updated predictions
                    displayPredictions();
                    updateStats(); // Update stats after settlement
                    
                    if (!silentMode) {
                        alert(`‚úÖ Settled ${settled} bets!\n\nWins: ${wins} ‚úÖ\nLosses: ${losses} ‚ùå\nWin Rate: ${winRate}%\n\nüóëÔ∏è Removed ${removedCount} finished bets\nüìä ${predictions.length} bets still active\n\nAI is learning from results...`);
                    } else {
                        console.log(`ü§ñ Auto-settled ${settled} bets (${wins}W/${losses}L - ${winRate}% WR) - ${predictions.length} active remaining`);
                    }
                } else {
                    addLog('   ‚è∞ No games finished yet', 'warning');
                    if (!silentMode) alert('‚è∞ Games not finished yet. Check back later!');
                }
                
            } catch (error) {
                addLog('', 'info');
                addLog(`‚ùå ERROR: ${error.message}`, 'error');
                console.error('Settlement error:', error);
                if (!silentMode) alert('Error fetching scores: ' + error.message);
            }
            
            if (!silentMode) {
                btn.disabled = false;
                btn.innerHTML = '<div class="text-lg">‚úÖ Settle Results</div><div class="text-xs opacity-90">Get real game outcomes</div>';
            }
        }
        
        function clearAllBets() {
            if (confirm('‚ö†Ô∏è Clear all bets? This will remove all predictions but keep your AI learning data.')) {
                predictions = [];
                savePredictions();
                displayPredictions();
                alert('‚úÖ All bets cleared!');
            }
        }
        
        function runLearningCycle() {
            const insights = ai.learn();
            
            const container = document.getElementById('insights');
            container.innerHTML = `
                <div class="bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-200 rounded-lg p-6">
                    <h3 class="text-lg font-bold text-purple-900 mb-3">üéì AI Learning Complete</h3>
                    <div class="space-y-2 text-sm text-gray-700">
                        ${insights.map(insight => `<div>‚Ä¢ ${insight}</div>`).join('')}
                    </div>
                </div>
            `;
            
            updateStats();
            
            alert('üß† AI has completed a learning cycle and updated its strategy!');
        }
        
        function updateStats() {
            const totalBets = ai.model.totalBets;
            const winRate = totalBets > 0 ? ((ai.model.wins / totalBets) * 100).toFixed(1) : '0';
            
            // Calculate best bet type
            let bestBetType = 'Learning...';
            let bestWinRate = 0;
            ['Moneyline', 'Spread', 'Total'].forEach(type => {
                const perf = ai.model.betTypePerformance[type];
                if (perf && perf.total >= 3) {
                    const typeRate = (perf.wins / perf.total) * 100;
                    if (typeRate > bestWinRate) {
                        bestWinRate = typeRate;
                        bestBetType = `${type} (${typeRate.toFixed(1)}%)`;
                    }
                }
            });
            
            // Update basic stats
            document.getElementById('totalBets').textContent = totalBets;
            document.getElementById('winRate').textContent = winRate + '%';
            document.getElementById('confidence').textContent = bestBetType;
            document.getElementById('cycles').textContent = ai.model.learningCycles;
            
            // Update progress bars with animation
            const totalBetsProgress = Math.min(100, (totalBets / 100) * 100);
            document.getElementById('totalBetsProgress').style.width = totalBetsProgress + '%';
            document.getElementById('winRateProgress').style.width = winRate + '%';
            
            // Show trend indicators
            if (ai.model.recentTrend && ai.model.recentTrend.last10.length >= 5) {
                const recentWins = ai.model.recentTrend.last10.filter(w => w).length;
                const recentWinRate = (recentWins / ai.model.recentTrend.last10.length * 100).toFixed(0);
                const trendEl = document.getElementById('winRateTrend');
                
                if (recentWinRate >= 60) {
                    trendEl.textContent = 'üî• HOT';
                    trendEl.className = 'text-xs font-bold text-green-600';
                } else if (recentWinRate <= 40) {
                    trendEl.textContent = '‚ùÑÔ∏è COLD';
                    trendEl.className = 'text-xs font-bold text-red-600';
                } else {
                    trendEl.textContent = '‚û°Ô∏è STEADY';
                    trendEl.className = 'text-xs font-bold text-gray-600';
                }
                
                // Show recent streak
                const streakEl = document.getElementById('recentStreak');
                if (ai.model.recentTrend.currentStreak >= 3) {
                    const streakEmoji = ai.model.recentTrend.streakType === 'win' ? 'üî•' : '‚ö†Ô∏è';
                    const streakText = ai.model.recentTrend.streakType === 'win' ? 'Win Streak' : 'Loss Streak';
                    const streakColor = ai.model.recentTrend.streakType === 'win' ? 'text-green-600' : 'text-red-600';
                    streakEl.textContent = `${streakEmoji} ${ai.model.recentTrend.currentStreak} ${streakText}`;
                    streakEl.className = `text-xs font-semibold mt-2 ${streakColor}`;
                } else {
                    streakEl.textContent = '';
                }
            }
            
            // Show win rate assessment
            const winRateSubtext = document.getElementById('winRateSubtext');
            if (totalBets >= 10) {
                if (winRate >= 55) {
                    winRateSubtext.textContent = 'üí∞ Profitable! (>55%)';
                    winRateSubtext.className = 'text-xs mt-1 text-green-600 font-semibold';
                } else if (winRate >= 50) {
                    winRateSubtext.textContent = '‚úÖ Break-even zone';
                    winRateSubtext.className = 'text-xs mt-1 text-yellow-600 font-semibold';
                } else {
                    winRateSubtext.textContent = 'üìö Still learning...';
                    winRateSubtext.className = 'text-xs mt-1 text-gray-600';
                }
            } else {
                winRateSubtext.textContent = 'AI accuracy';
                winRateSubtext.className = 'text-xs text-gray-400 mt-1';
            }
            
            // Show momentum indicator
            const momentumEl = document.getElementById('momentum');
            if (ai.model.weights.recentMomentum) {
                if (ai.model.weights.recentMomentum > 0) {
                    momentumEl.textContent = 'üìà Positive momentum';
                } else if (ai.model.weights.recentMomentum < 0) {
                    momentumEl.textContent = 'üìâ Adjusting strategy';
                } else {
                    momentumEl.textContent = '';
                }
            }
        }
        
        // Auto-settlement system - Smart timing to avoid API limit
        function getGameDuration(sport) {
            // Approximate game durations in minutes
            const durations = {
                'NFL': 210,      // ~3.5 hours
                'NCAAF': 210,    // ~3.5 hours
                'NBA': 150,      // ~2.5 hours
                'NHL': 150,      // ~2.5 hours
                'MLB': 180       // ~3 hours
            };
            return durations[sport] || 180;
        }
        
        function getNextSettlementTime() {
            if (predictions.length === 0) return null;
            
            const now = new Date();
            let earliestCheck = null;
            
            // Find the earliest game that should be finished
            predictions.forEach(pred => {
                const gameTime = new Date(pred.gameTime);
                const gameDuration = getGameDuration(pred.sport);
                const estimatedEndTime = new Date(gameTime.getTime() + gameDuration * 60000);
                
                // Add 15 minute buffer after estimated end
                const checkTime = new Date(estimatedEndTime.getTime() + 15 * 60000);
                
                // Only consider games that should be done or finishing soon
                if (checkTime <= new Date(now.getTime() + 4 * 60 * 60000)) { // Within next 4 hours
                    if (!earliestCheck || checkTime < earliestCheck) {
                        earliestCheck = checkTime;
                    }
                }
            });
            
            return earliestCheck;
        }
        
        async function autoSettleCheck() {
            if (predictions.length === 0) {
                console.log('‚è∞ Auto-settle: No predictions to check');
                return;
            }
            
            const now = new Date();
            const nextCheckTime = getNextSettlementTime();
            
            if (!nextCheckTime) {
                console.log('‚è∞ Auto-settle: No games finishing soon');
                scheduleNextAutoSettle();
                return;
            }
            
            if (now < nextCheckTime) {
                const minutesUntil = Math.ceil((nextCheckTime - now) / 60000);
                console.log(`‚è∞ Auto-settle: Next check in ${minutesUntil} minutes (when games should be finished)`);
                scheduleNextAutoSettle();
                return;
            }
            
            console.log('ü§ñ Auto-settling completed games...');
            await settleBets(true); // Pass true for silent mode
            
            // Schedule next check after settling
            scheduleNextAutoSettle();
        }
        
        let autoSettleTimeout = null;
        function scheduleNextAutoSettle() {
            // Clear existing timeout
            if (autoSettleTimeout) clearTimeout(autoSettleTimeout);
            
            const nextCheckTime = getNextSettlementTime();
            if (!nextCheckTime) {
                // No games finishing soon, check again in 2 hours
                autoSettleTimeout = setTimeout(autoSettleCheck, 2 * 60 * 60000);
                console.log('‚è∞ No games finishing soon, will check again in 2 hours');
                return;
            }
            
            const now = new Date();
            const msUntilCheck = Math.max(60000, nextCheckTime - now); // At least 1 minute
            autoSettleTimeout = setTimeout(autoSettleCheck, msUntilCheck);
            
            const minutesUntil = Math.ceil(msUntilCheck / 60000);
            console.log(`‚è∞ Auto-settle scheduled for ${minutesUntil} minutes from now`);
        }
        
        // Initialize
        loadPredictions(); // Load saved predictions
        updateStats();
        displayPredictions(); // Display loaded predictions
        
        // Start smart auto-settlement system
        scheduleNextAutoSettle();
        
        // Display version info
        console.log('üöÄ AI Betting System v2.0 - Build: 2024-12-10 18:30 UTC');
        console.log('‚úÖ Features: Multi-bet types (Moneyline/Spread/Total), AI Learning, Performance Tracking, Auto-Settlement');
        console.log(`üìä Loaded ${predictions.length} saved predictions`);
    </script>
    
    <!-- Version Footer -->
    <div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.7); font-size: 12px;">
        v2.0 ‚Ä¢ Build: Dec 10, 2024 18:30 UTC ‚Ä¢ Multi-Bet AI System
    </div>
</body>
</html>
