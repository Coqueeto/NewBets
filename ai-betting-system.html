<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Self-Learning AI Betting System v2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .glass-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
            border: 1px solid rgba(255, 255, 255, 0.18);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }
        .glass-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 40px 0 rgba(31, 38, 135, 0.45);
        }
        .ai-badge {
            animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: .5; }
        }
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .slide-in {
            animation: slideIn 0.5s ease-out;
        }
        @keyframes shimmer {
            0% { background-position: -1000px 0; }
            100% { background-position: 1000px 0; }
        }
        .shimmer {
            background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.3) 50%, rgba(255,255,255,0) 100%);
            background-size: 1000px 100%;
            animation: shimmer 2s infinite;
        }
        .progress-bar {
            transition: width 0.5s ease;
        }
        .stat-increase {
            animation: statPop 0.5s ease;
        }
        @keyframes statPop {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
        .gradient-text {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        /* Dark Mode */
        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }
        body.dark-mode .glass-card {
            background: rgba(30, 30, 46, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        body.dark-mode h1, body.dark-mode h2, body.dark-mode h3 {
            color: #e0e0e0 !important;
        }
        body.dark-mode .text-gray-900 { color: #e0e0e0 !important; }
        body.dark-mode .text-gray-700 { color: #b0b0b0 !important; }
        body.dark-mode .text-gray-600 { color: #909090 !important; }
        body.dark-mode .text-gray-500 { color: #707070 !important; }
        body.dark-mode .bg-gray-100 { background-color: #2a2a3e !important; }
        body.dark-mode .bg-gray-200 { background-color: #3a3a4e !important; }
        body.dark-mode .border-gray-300 { border-color: #4a4a5e !important; }
        /* Mobile Optimization */
        @media (max-width: 640px) {
            .glass-card { padding: 12px !important; }
            h1 { font-size: 1.5rem !important; }
            .sportsbook-table { overflow-x: auto; display: block; }
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div class="max-w-7xl mx-auto space-y-6">
        
        <!-- Header -->
        <div class="glass-card p-6">
            <div class="flex items-center justify-between">
                <div>
                    <h1 class="text-3xl font-bold text-gray-900">ü§ñ Self-Learning AI Betting System</h1>
                    <p class="text-gray-600 mt-1">Advanced machine learning for profitable betting <span class="text-xs text-purple-600 font-mono">v2.0</span></p>
                </div>
                <div class="text-right">
                    <div class="text-sm text-gray-500">AI Status</div>
                    <div class="text-lg font-bold text-green-600">‚óè Learning</div>
                    <div class="text-xs text-gray-500 mt-1">API: <span id="apiUsage">0/500</span></div>
                    <div class="text-xs text-gray-400 mt-1">Storage: <span id="storageUsage">0%</span></div>
                    <button onclick="toggleDarkMode()" class="mt-2 text-xs px-2 py-1 bg-gray-200 dark:bg-gray-700 rounded hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors" id="darkModeBtn">üåô Dark</button>
                </div>
            </div>
        </div>

        <!-- AI Stats Dashboard -->
        <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500 flex justify-between items-center">
                    <span>Total Bets Analyzed</span>
                    <span class="text-xs" id="trendIndicator"></span>
                </div>
                <div class="text-2xl font-bold text-gray-900" id="totalBets">0</div>
                <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                    <div class="bg-gradient-to-r from-blue-500 to-purple-600 h-2 rounded-full progress-bar" id="totalBetsProgress" style="width: 0%"></div>
                </div>
                <div class="text-xs text-gray-400 mt-1">Lifetime learning</div>
            </div>
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500 flex justify-between items-center">
                    <span>Win Rate</span>
                    <span class="text-xs font-bold" id="winRateTrend"></span>
                </div>
                <div class="text-2xl font-bold text-green-600" id="winRate">0%</div>
                <div class="w-full bg-gray-200 rounded-full h-2 mt-2">
                    <div class="bg-gradient-to-r from-green-400 to-emerald-600 h-2 rounded-full progress-bar" id="winRateProgress" style="width: 0%"></div>
                </div>
                <div class="text-xs mt-1" id="winRateSubtext">AI accuracy</div>
            </div>
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500">Best Bet Type</div>
                <div class="text-xl font-bold text-purple-600 gradient-text" id="confidence">Learning...</div>
                <div class="text-xs text-gray-400 mt-1">Top performer</div>
                <div class="text-xs font-semibold mt-2" id="recentStreak"></div>
            </div>
            <div class="glass-card p-4 slide-in">
                <div class="text-sm text-gray-500">Learning Cycles</div>
                <div class="text-2xl font-bold text-blue-600" id="cycles">0</div>
                <div class="text-xs text-gray-400 mt-1">Training iterations</div>
                <div class="text-xs font-semibold mt-2 text-purple-600" id="momentum"></div>
            </div>
        </div>

        <!-- Sport Selection -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">Select Sport</h2>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-3">
                <button onclick="selectSport('americanfootball_nfl', 'NFL')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèà</div>
                    <div class="font-semibold">NFL</div>
                </button>
                <button onclick="selectSport('basketball_nba', 'NBA')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèÄ</div>
                    <div class="font-semibold">NBA</div>
                </button>
                <button onclick="selectSport('icehockey_nhl', 'NHL')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üèí</div>
                    <div class="font-semibold">NHL</div>
                </button>
                <button onclick="selectSport('baseball_mlb', 'MLB')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">‚öæ</div>
                    <div class="font-semibold">MLB</div>
                </button>
                <button onclick="selectSport('americanfootball_ncaaf', 'NCAAF')" class="sport-btn p-4 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition">
                    <div class="text-2xl mb-2">üéì</div>
                    <div class="font-semibold">NCAAF</div>
                </button>
            </div>
            <div class="mt-4 text-center">
                <span class="text-gray-600">Selected: </span>
                <span class="font-bold text-purple-600" id="selectedSport">None</span>
            </div>
        </div>

        <!-- Confidence Filter & Data Management -->
        <div class="glass-card p-4">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="flex-1 w-full">
                    <label class="text-sm font-semibold text-gray-700 dark:text-gray-300">üéØ Min Confidence Filter: <span id="minConfidenceValue" class="text-purple-600">0%</span></label>
                    <input type="range" id="minConfidenceSlider" min="0" max="95" value="0" step="5" class="w-full mt-2" oninput="updateConfidenceFilter(this.value)">
                    <div class="flex justify-between text-xs text-gray-400 mt-1">
                        <span>All Bets</span>
                        <span>50%</span>
                        <span>Elite (95%)</span>
                    </div>
                </div>
                <div class="flex gap-2">
                    <button onclick="exportData()" class="px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm">üì• Export</button>
                    <button onclick="importData()" class="px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 text-sm">üì§ Import</button>
                    <button onclick="requestNotificationPermission()" class="px-3 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 text-sm" id="notifBtn">üîî</button>
                </div>
            </div>
        </div>

        <!-- AI Control Panel -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üß† AI Control Panel</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                <button id="analyzeBtn" onclick="analyzeGames()" class="bg-gradient-to-r from-purple-600 to-blue-600 text-white font-bold py-4 px-6 rounded-lg hover:from-purple-700 hover:to-blue-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">üîç Analyze Games</div>
                    <div class="text-xs opacity-90">Find value bets with AI</div>
                </button>
                <button id="settleBtn" onclick="settleBets()" class="bg-gradient-to-r from-green-600 to-teal-600 text-white font-bold py-4 px-6 rounded-lg hover:from-green-700 hover:to-teal-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">‚úÖ Settle Results</div>
                    <div class="text-xs opacity-90">Get real game outcomes</div>
                </button>
                <button id="learnBtn" onclick="runLearningCycle()" class="bg-gradient-to-r from-orange-600 to-red-600 text-white font-bold py-4 px-6 rounded-lg hover:from-orange-700 hover:to-red-700 transition shadow-lg disabled:opacity-50">
                    <div class="text-lg">üéì Learn & Improve</div>
                    <div class="text-xs opacity-90">AI self-improvement</div>
                </button>
            </div>
            <div class="mt-4 text-center">
                <button onclick="clearAllBets()" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-2 px-4 rounded text-sm">
                    üóëÔ∏è Clear All Bets
                </button>
            </div>
        </div>

        <!-- Settlement Log -->
        <div id="settlementLog" class="glass-card p-6 hidden">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üìã Settlement Log</h2>
            <div id="logContent" class="space-y-1 text-sm font-mono max-h-96 overflow-y-auto bg-gray-900 p-4 rounded-lg"></div>
        </div>

        <!-- AI Predictions -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üéØ AI Predictions</h2>
            <div id="predictions" class="space-y-3">
                <div class="text-center text-gray-400 py-8">
                    Click "Analyze Games" to start AI analysis
                </div>
            </div>
        </div>

        <!-- Learning Insights -->
        <div class="glass-card p-6">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-900 dark:text-gray-100">üìä AI Learning Insights</h2>
                <button onclick="createModelSnapshot()" class="px-3 py-1 bg-purple-500 text-white rounded hover:bg-purple-600 text-xs" id="snapshotBtn">üíæ Snapshot</button>
            </div>
            <div id="insights" class="space-y-4">
                <div class="text-center text-gray-400 py-8">
                    AI insights will appear after learning cycles
                </div>
            </div>
        </div>

        <!-- Performance Analytics -->
        <div class="glass-card p-6">
            <h2 class="text-xl font-bold text-gray-900 dark:text-gray-100 mb-4">üìà Performance Analytics</h2>
            <canvas id="performanceChart" height="80"></canvas>
            <div class="grid grid-cols-3 gap-4 mt-4 text-sm">
                <div class="text-center">
                    <div class="text-gray-500">7-Day Win Rate</div>
                    <div class="text-xl font-bold text-green-600" id="weekWinRate">-</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">ROI (Units)</div>
                    <div class="text-xl font-bold text-blue-600" id="roiUnits">-</div>
                </div>
                <div class="text-center">
                    <div class="text-gray-500">Current Streak</div>
                    <div class="text-xl font-bold text-purple-600" id="currentStreakDisplay">-</div>
                </div>
            </div>
        </div>

        <!-- Model Versions -->
        <div class="glass-card p-4" id="modelVersions" style="display: none;">
            <h3 class="text-sm font-bold text-gray-700 dark:text-gray-300 mb-2">üîÑ Model Snapshots</h3>
            <div id="versionsList" class="space-y-2 text-xs"></div>
        </div>

    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Configuration
        const ODDS_API_KEY = '28beb23f0f84301404f98f2951928b52';
        let currentSport = null;
        let currentSportName = '';
        let predictions = [];
        
        // API Usage Tracking
        function trackApiCall() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
            const apiUsage = JSON.parse(localStorage.getItem('apiUsage') || '{}');
            
            if (!apiUsage[monthKey]) {
                apiUsage[monthKey] = { count: 0, limit: 500 };
            }
            apiUsage[monthKey].count++;
            
            // Clean up old months
            const currentMonth = monthKey;
            Object.keys(apiUsage).forEach(key => {
                if (key !== currentMonth) delete apiUsage[key];
            });
            
            localStorage.setItem('apiUsage', JSON.stringify(apiUsage));
            updateApiUsageDisplay();
            return apiUsage[monthKey];
        }
        
        function getApiUsage() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
            const apiUsage = JSON.parse(localStorage.getItem('apiUsage') || '{}');
            return apiUsage[monthKey] || { count: 0, limit: 500 };
        }
        
        function updateApiUsageDisplay() {
            const usage = getApiUsage();
            const percent = (usage.count / usage.limit * 100).toFixed(0);
            const color = percent > 90 ? 'text-red-600' : percent > 70 ? 'text-orange-600' : 'text-green-600';
            const apiDisplay = document.getElementById('apiUsage');
            if (apiDisplay) {
                apiDisplay.innerHTML = `<span class="${color} font-bold">${usage.count}/${usage.limit}</span> calls`;
            }
            
            // Notify when approaching limit
            if (percent >= 90 && !localStorage.getItem('api90notified')) {
                showNotification('‚ö†Ô∏è API usage at 90% - Consider caching', 'warning');
                localStorage.setItem('api90notified', 'true');
            }
        }
        
        // Storage Management
        function getStorageUsage() {
            let total = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    total += localStorage[key].length + key.length;
                }
            }
            const mb = (total / (1024 * 1024)).toFixed(2);
            const percent = ((total / (5 * 1024 * 1024)) * 100).toFixed(1);
            return { bytes: total, mb, percent };
        }
        
        function updateStorageDisplay() {
            const usage = getStorageUsage();
            const elem = document.getElementById('storageUsage');
            if (elem) {
                const color = usage.percent > 80 ? 'text-red-600' : usage.percent > 60 ? 'text-orange-600' : 'text-green-600';
                elem.className = color + ' font-bold';
                elem.textContent = usage.percent + '%';
            }
        }
        
        function cleanupOldData() {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 90); // Keep last 90 days
            
            predictions = predictions.filter(p => {
                const predDate = new Date(p.timestamp || p.oddsTimestamp || 0);
                return predDate > cutoffDate || !p.settled;
            });
            
            savePredictions();
            console.log(`üóëÔ∏è Cleaned up old predictions. ${predictions.length} remaining.`);
        }
        
        // API Response Caching
        const apiCache = {
            data: {},
            set(key, value, ttlMinutes = 5) {
                this.data[key] = {
                    value,
                    expires: Date.now() + (ttlMinutes * 60 * 1000)
                };
            },
            get(key) {
                const cached = this.data[key];
                if (!cached) return null;
                if (Date.now() > cached.expires) {
                    delete this.data[key];
                    return null;
                }
                return cached.value;
            },
            clear() {
                this.data = {};
            }
        };
        
        // Export/Import Functions
        function exportData() {
            const exportObj = {
                predictions,
                aiModel: ai.model,
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            const dataStr = JSON.stringify(exportObj, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ai-betting-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('‚úÖ Data exported successfully!', 'success');
        }
        
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importObj = JSON.parse(event.target.result);
                        if (confirm(`Import ${importObj.predictions?.length || 0} predictions and AI model from ${importObj.exportDate}?`)) {
                            predictions = importObj.predictions || [];
                            ai.model = importObj.aiModel || ai.model;
                            savePredictions();
                            ai.saveModel();
                            displayPredictions();
                            updateStats();
                            showNotification('‚úÖ Data imported successfully!', 'success');
                        }
                    } catch (err) {
                        showNotification('‚ùå Invalid backup file', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // Confidence Filter
        let minConfidenceFilter = 0;
        function updateConfidenceFilter(value) {
            minConfidenceFilter = parseInt(value);
            document.getElementById('minConfidenceValue').textContent = value + '%';
            displayPredictions();
        }
        
        // Model Versioning
        function createModelSnapshot() {
            const snapshots = JSON.parse(localStorage.getItem('modelSnapshots') || '[]');
            const snapshot = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                model: JSON.parse(JSON.stringify(ai.model)),
                winRate: ai.model.totalBets > 0 ? (ai.model.wins / ai.model.totalBets * 100).toFixed(1) : 0
            };
            snapshots.push(snapshot);
            // Keep only last 10 snapshots
            if (snapshots.length > 10) snapshots.shift();
            localStorage.setItem('modelSnapshots', JSON.stringify(snapshots));
            showNotification('üíæ Model snapshot saved', 'success');
            displayModelVersions();
        }
        
        function displayModelVersions() {
            const snapshots = JSON.parse(localStorage.getItem('modelSnapshots') || '[]');
            const container = document.getElementById('modelVersions');
            const list = document.getElementById('versionsList');
            
            if (snapshots.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            list.innerHTML = snapshots.reverse().map((snap, idx) => `
                <div class="flex justify-between items-center p-2 bg-gray-100 dark:bg-gray-800 rounded">
                    <div>
                        <div class="font-semibold">${new Date(snap.timestamp).toLocaleString()}</div>
                        <div class="text-gray-500">Win Rate: ${snap.winRate}% | Bets: ${snap.model.totalBets}</div>
                    </div>
                    <button onclick="restoreModelSnapshot(${snap.id})" class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">Restore</button>
                </div>
            `).join('');
        }
        
        function restoreModelSnapshot(snapshotId) {
            const snapshots = JSON.parse(localStorage.getItem('modelSnapshots') || '[]');
            const snapshot = snapshots.find(s => s.id === snapshotId);
            if (!snapshot) return;
            
            if (confirm(`Restore model from ${new Date(snapshot.timestamp).toLocaleString()}?`)) {
                ai.model = snapshot.model;
                ai.saveModel();
                updateStats();
                showNotification('‚úÖ Model restored successfully!', 'success');
            }
        }
        
        // Dark Mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            document.getElementById('darkModeBtn').textContent = isDark ? '‚òÄÔ∏è Light' : 'üåô Dark';
        }
        
        function initDarkMode() {
            const isDark = localStorage.getItem('darkMode') === 'true';
            if (isDark) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeBtn').textContent = '‚òÄÔ∏è Light';
            }
        }
        
        // Browser Notifications
        let notificationsEnabled = false;
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    notificationsEnabled = permission === 'granted';
                    if (notificationsEnabled) {
                        showNotification('üîî Notifications enabled!', 'success');
                    }
                });
            } else if (Notification.permission === 'granted') {
                notificationsEnabled = true;
            }
        }
        
        function showNotification(message, type = 'info') {
            // Visual notification
            const notif = document.createElement('div');
            const colors = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-orange-500',
                info: 'bg-blue-500'
            };
            notif.className = `fixed top-20 right-4 ${colors[type]} text-white px-4 py-3 rounded-lg shadow-lg z-50 animate-pulse`;
            notif.textContent = message;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
            
            // Browser notification
            if (notificationsEnabled && type !== 'info') {
                new Notification('AI Betting System', { body: message, icon: 'ü§ñ' });
            }
        }
        
        // Load predictions from localStorage on startup
        function loadPredictions() {
            const saved = localStorage.getItem('predictions');
            if (saved) {
                try {
                    predictions = JSON.parse(saved);
                    console.log(`Loaded ${predictions.length} saved predictions`);
                } catch (e) {
                    console.error('Error loading predictions:', e);
                    predictions = [];
                }
            }
        }
        
        // Save predictions to localStorage
        function savePredictions() {
            localStorage.setItem('predictions', JSON.stringify(predictions));
        }
        
        // AI Learning Model
        class BettingAI {
            constructor() {
                this.loadModel();
            }
            
            loadModel() {
                const saved = localStorage.getItem('bettingAI_model');
                if (saved) {
                    this.model = JSON.parse(saved);
                    // Ensure new properties exist for older models
                    if (!this.model.betTypePerformance) {
                        this.model.betTypePerformance = {
                            Moneyline: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Spread: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Total: { wins: 0, losses: 0, total: 0, avgConfidence: 0 }
                        };
                    }
                    if (!this.model.confidenceRanges) {
                        this.model.confidenceRanges = {};
                    }
                    if (!this.model.weights.betTypePreference) {
                        this.model.weights.betTypePreference = {
                            Moneyline: 1.0,
                            Spread: 1.0,
                            Total: 1.0
                        };
                    }
                } else {
                    this.model = {
                        totalBets: 0,
                        wins: 0,
                        losses: 0,
                        learningCycles: 0,
                        betTypePerformance: {
                            Moneyline: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Spread: { wins: 0, losses: 0, total: 0, avgConfidence: 0 },
                            Total: { wins: 0, losses: 0, total: 0, avgConfidence: 0 }
                        },
                        confidenceRanges: {},
                        betHistory: [], // Track all completed bets
                        recentTrend: { last10: [], last20: [], currentStreak: 0, streakType: null },
                        patterns: {
                            spreadSuccess: { over: 0, under: 0, total: 0 },
                            moneylineSuccess: { favorite: 0, underdog: 0, total: 0 },
                            homeAwayPerformance: { home: { wins: 0, losses: 0 }, away: { wins: 0, losses: 0 } },
                            oddsRanges: {},
                            teamPerformance: {},
                            timeOfDaySuccess: { early: 0, mid: 0, late: 0 },
                            dayOfWeekSuccess: {}
                        },
                        weights: {
                            oddsDiscrepancy: 1.0,
                            homeAdvantage: 0.3,
                            marketEfficiency: 0.5,
                            recentMomentum: 0.0,
                            betTypePreference: {
                                Moneyline: 1.0,
                                Spread: 1.0,
                                Total: 1.0
                            }
                        },
                        adaptiveThresholds: {
                            minConfidence: 45,  // Start lower for learning
                            minDiscrepancy: 1.5, // Accept more bets initially
                            minOdds: -250
                        }
                    };
                }
                
                // Ensure betHistory exists for older models
                if (!this.model.betHistory) {
                    this.model.betHistory = [];
                }
                if (!this.model.patterns.homeAwayPerformance) {
                    this.model.patterns.homeAwayPerformance = { 
                        home: { wins: 0, losses: 0 }, 
                        away: { wins: 0, losses: 0 } 
                    };
                }
            }
            
            saveModel() {
                localStorage.setItem('bettingAI_model', JSON.stringify(this.model));
                updateStats();
            }
            
            analyzeGame(game) {
                if (!game.bookmakers || game.bookmakers.length < 2) return null;
                
                const homeTeam = game.home_team;
                const awayTeam = game.away_team;
                
                // Collect all odds types WITH sportsbook names
                const h2hOdds = [];
                const spreadOdds = [];
                const totalOdds = [];
                
                game.bookmakers.forEach(book => {
                    const h2h = book.markets?.find(m => m.key === 'h2h');
                    const spread = book.markets?.find(m => m.key === 'spreads');
                    const totals = book.markets?.find(m => m.key === 'totals');
                    
                    if (h2h) h2hOdds.push({ outcomes: h2h.outcomes, book: book.title });
                    if (spread) spreadOdds.push({ outcomes: spread.outcomes, book: book.title });
                    if (totals) totalOdds.push({ outcomes: totals.outcomes, book: book.title });
                });
                
                // Array to store all potential bets
                const potentialBets = [];
                
                // 1. ANALYZE MONEYLINE BETS
                if (h2hOdds.length >= 2) {
                    const avgHomeOdds = this.calculateAverage(h2hOdds.map(o => o.outcomes.find(x => x.name === homeTeam)?.price || 0));
                    const avgAwayOdds = this.calculateAverage(h2hOdds.map(o => o.outcomes.find(x => x.name === awayTeam)?.price || 0));
                    
                    // Find best odds AND which sportsbook has them
                    let bestHomeOdds = -Infinity;
                    let bestHomeBook = '';
                    let bestAwayOdds = -Infinity;
                    let bestAwayBook = '';
                    
                    h2hOdds.forEach(({ outcomes, book }) => {
                        const homeOdds = outcomes.find(x => x.name === homeTeam)?.price || -Infinity;
                        const awayOdds = outcomes.find(x => x.name === awayTeam)?.price || -Infinity;
                        if (homeOdds > bestHomeOdds) {
                            bestHomeOdds = homeOdds;
                            bestHomeBook = book;
                        }
                        if (awayOdds > bestAwayOdds) {
                            bestAwayOdds = awayOdds;
                            bestAwayBook = book;
                        }
                    });
                    
                    const homeDiscrepancy = ((bestHomeOdds - avgHomeOdds) / avgHomeOdds) * 100;
                    const awayDiscrepancy = ((bestAwayOdds - avgAwayOdds) / avgAwayOdds) * 100;
                    
                    const homeImplied = this.oddsToProb(avgHomeOdds);
                    const awayImplied = this.oddsToProb(avgAwayOdds);
                    
                    const homeScore = homeDiscrepancy * this.model.weights.oddsDiscrepancy + 
                                     (5 * this.model.weights.homeAdvantage);
                    const awayScore = awayDiscrepancy * this.model.weights.oddsDiscrepancy;
                    
                    if (homeScore > 2) {
                        potentialBets.push({
                            team: homeTeam,
                            opponent: awayTeam,
                            isHomeTeam: true,
                            odds: bestHomeOdds,
                            avgOdds: avgHomeOdds,
                            bestBook: bestHomeBook,
                            allBooks: h2hOdds.map(({outcomes, book}) => ({ book, odds: outcomes.find(x => x.name === homeTeam)?.price })).filter(b => b.odds),
                            discrepancy: homeDiscrepancy.toFixed(2),
                            confidence: Math.min(95, 50 + homeScore * 5),
                            type: 'Moneyline',
                            betDetails: `${homeTeam} to Win`,
                            implied: homeImplied,
                            valueScore: homeScore
                        });
                    }
                    
                    if (awayScore > 2) {
                        potentialBets.push({
                            team: awayTeam,
                            opponent: homeTeam,
                            isHomeTeam: false,
                            odds: bestAwayOdds,
                            avgOdds: avgAwayOdds,
                            discrepancy: awayDiscrepancy.toFixed(2),
                            confidence: Math.min(95, 50 + awayScore * 5),
                            type: 'Moneyline',
                            betDetails: `${awayTeam} to Win`,
                            implied: awayImplied,
                            valueScore: awayScore
                        });
                    }
                }
                
                // 2. ANALYZE SPREAD BETS
                if (spreadOdds.length >= 2) {
                    const homeSpreadData = [];
                    const awaySpreadData = [];
                    
                    spreadOdds.forEach(outcomes => {
                        const homeSpread = outcomes.find(o => o.name === homeTeam);
                        const awaySpread = outcomes.find(o => o.name === awayTeam);
                        if (homeSpread) homeSpreadData.push(homeSpread);
                        if (awaySpread) awaySpreadData.push(awaySpread);
                    });
                    
                    if (homeSpreadData.length > 0) {
                        const avgHomeSpreadOdds = this.calculateAverage(homeSpreadData.map(d => d.price));
                        const bestHomeSpreadOdds = Math.max(...homeSpreadData.map(d => d.price));
                        const avgHomeSpreadLine = this.calculateAverage(homeSpreadData.map(d => d.point));
                        const spreadDiscrepancy = ((bestHomeSpreadOdds - avgHomeSpreadOdds) / avgHomeSpreadOdds) * 100;
                        const spreadScore = spreadDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (spreadScore > 1.5 || bestHomeSpreadOdds > 100) {
                            potentialBets.push({
                                team: homeTeam,
                                opponent: awayTeam,
                                isHomeTeam: true,
                                odds: bestHomeSpreadOdds,
                                avgOdds: avgHomeSpreadOdds,
                                discrepancy: spreadDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + spreadScore * 6),
                                type: 'Spread',
                                betDetails: `${homeTeam} ${avgHomeSpreadLine > 0 ? '+' : ''}${avgHomeSpreadLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgHomeSpreadOdds),
                                valueScore: spreadScore + 1,
                                spreadLine: avgHomeSpreadLine
                            });
                        }
                    }
                    
                    if (awaySpreadData.length > 0) {
                        const avgAwaySpreadOdds = this.calculateAverage(awaySpreadData.map(d => d.price));
                        const bestAwaySpreadOdds = Math.max(...awaySpreadData.map(d => d.price));
                        const avgAwaySpreadLine = this.calculateAverage(awaySpreadData.map(d => d.point));
                        const spreadDiscrepancy = ((bestAwaySpreadOdds - avgAwaySpreadOdds) / avgAwaySpreadOdds) * 100;
                        const spreadScore = spreadDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (spreadScore > 1.5 || bestAwaySpreadOdds > 100) {
                            potentialBets.push({
                                team: awayTeam,
                                opponent: homeTeam,
                                isHomeTeam: false,
                                odds: bestAwaySpreadOdds,
                                avgOdds: avgAwaySpreadOdds,
                                discrepancy: spreadDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + spreadScore * 6),
                                type: 'Spread',
                                betDetails: `${awayTeam} ${avgAwaySpreadLine > 0 ? '+' : ''}${avgAwaySpreadLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgAwaySpreadOdds),
                                valueScore: spreadScore + 1,
                                spreadLine: avgAwaySpreadLine
                            });
                        }
                    }
                }
                
                // 3. ANALYZE TOTALS (Over/Under)
                if (totalOdds.length >= 2) {
                    const overData = [];
                    const underData = [];
                    
                    totalOdds.forEach(outcomes => {
                        const over = outcomes.find(o => o.name === 'Over');
                        const under = outcomes.find(o => o.name === 'Under');
                        if (over) overData.push(over);
                        if (under) underData.push(under);
                    });
                    
                    if (overData.length > 0) {
                        const avgOverOdds = this.calculateAverage(overData.map(d => d.price));
                        const bestOverOdds = Math.max(...overData.map(d => d.price));
                        const avgOverLine = this.calculateAverage(overData.map(d => d.point));
                        const totalDiscrepancy = ((bestOverOdds - avgOverOdds) / avgOverOdds) * 100;
                        const totalScore = totalDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (totalScore > 1.5 || bestOverOdds > 100) {
                            potentialBets.push({
                                team: 'Over',
                                opponent: `${homeTeam} vs ${awayTeam}`,
                                odds: bestOverOdds,
                                avgOdds: avgOverOdds,
                                discrepancy: totalDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + totalScore * 6),
                                type: 'Total',
                                betDetails: `Over ${avgOverLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgOverOdds),
                                valueScore: totalScore,
                                totalLine: avgOverLine
                            });
                        }
                    }
                    
                    if (underData.length > 0) {
                        const avgUnderOdds = this.calculateAverage(underData.map(d => d.price));
                        const bestUnderOdds = Math.max(...underData.map(d => d.price));
                        const avgUnderLine = this.calculateAverage(underData.map(d => d.point));
                        const totalDiscrepancy = ((bestUnderOdds - avgUnderOdds) / avgUnderOdds) * 100;
                        const totalScore = totalDiscrepancy * this.model.weights.oddsDiscrepancy;
                        
                        if (totalScore > 1.5 || bestUnderOdds > 100) {
                            potentialBets.push({
                                team: 'Under',
                                opponent: `${homeTeam} vs ${awayTeam}`,
                                odds: bestUnderOdds,
                                avgOdds: avgUnderOdds,
                                discrepancy: totalDiscrepancy.toFixed(2),
                                confidence: Math.min(95, 45 + totalScore * 6),
                                type: 'Total',
                                betDetails: `Under ${avgUnderLine.toFixed(1)}`,
                                implied: this.oddsToProb(avgUnderOdds),
                                valueScore: totalScore,
                                totalLine: avgUnderLine
                            });
                        }
                    }
                }
                
                // Pick the best bet based on value score AND learned preferences
                if (potentialBets.length === 0) return null;
                
                // Apply learned bet type preferences to adjust scores
                potentialBets.forEach(bet => {
                    const typePreference = this.model.weights.betTypePreference[bet.type] || 1.0;
                    bet.adjustedScore = bet.valueScore * typePreference;
                    
                    // Start with calculated confidence
                    let adjustedConfidence = bet.confidence;
                    
                    // Factor 1: Historical bet type performance
                    const typePerf = this.model.betTypePerformance[bet.type];
                    if (typePerf && typePerf.total > 10) {
                        const winRate = typePerf.wins / typePerf.total;
                        if (winRate > 0.60) {
                            adjustedConfidence *= 1.15; // Strong bet type - boost 15%
                        } else if (winRate > 0.55) {
                            adjustedConfidence *= 1.08; // Good bet type - boost 8%
                        } else if (winRate < 0.45) {
                            adjustedConfidence *= 0.85; // Weak bet type - reduce 15%
                        }
                    }
                    
                    // Factor 2: Team historical performance
                    const teamPerf = this.model.patterns.teamPerformance[bet.team];
                    if (teamPerf && teamPerf.total >= 5) {
                        const teamWinRate = teamPerf.wins / teamPerf.total;
                        if (teamWinRate > 0.65) {
                            adjustedConfidence *= 1.12; // Hot team - boost 12%
                        } else if (teamWinRate < 0.35) {
                            adjustedConfidence *= 0.88; // Cold team - reduce 12%
                        }
                    }
                    
                    // Factor 3: Home/Away performance alignment
                    if (bet.isHomeTeam !== undefined) {
                        const position = bet.isHomeTeam ? 'home' : 'away';
                        const posPerf = this.model.patterns.homeAwayPerformance[position];
                        const posTotal = posPerf.wins + posPerf.losses;
                        if (posTotal >= 10) {
                            const posWinRate = posPerf.wins / posTotal;
                            if (posWinRate > 0.58) {
                                adjustedConfidence *= 1.08; // Strong position record
                            } else if (posWinRate < 0.42) {
                                adjustedConfidence *= 0.92; // Weak position record
                            }
                        }
                    }
                    
                    // Factor 4: Recent momentum boost
                    if (this.model.weights.recentMomentum > 0) {
                        adjustedConfidence *= 1.05; // Hot streak - slight boost
                    } else if (this.model.weights.recentMomentum < 0) {
                        adjustedConfidence *= 0.93; // Cold streak - be cautious
                    }
                    
                    // Factor 5: High odds discrepancy = high confidence
                    if (parseFloat(bet.discrepancy) > 5.0) {
                        adjustedConfidence *= 1.10; // Huge value found
                    } else if (parseFloat(bet.discrepancy) > 3.5) {
                        adjustedConfidence *= 1.05; // Good value
                    }
                    
                    // Apply adaptive threshold - only accept if meets minimum
                    const minConfidence = this.model.adaptiveThresholds?.minConfidence || 50;
                    if (adjustedConfidence < minConfidence) {
                        bet.confidence = 0; // Reject - below threshold
                        return;
                    }
                    
                    // Cap confidence appropriately
                    bet.confidence = Math.min(99, Math.max(40, adjustedConfidence));
                });
                
                // Filter out rejected bets (confidence = 0)
                potentialBets = potentialBets.filter(b => b.confidence > 0);
                
                if (potentialBets.length === 0) return null;
                
                // Sort by adjusted score (value * learned preference)
                potentialBets.sort((a, b) => b.adjustedScore - a.adjustedScore);
                const pick = potentialBets[0];
                
                pick.game = `${awayTeam} @ ${homeTeam}`;
                pick.gameTime = game.commence_time;
                pick.gameId = game.id;
                
                // Calculate game timing
                const gameDate = new Date(game.commence_time);
                const now = new Date();
                const hoursUntilGame = (gameDate - now) / (1000 * 60 * 60);
                pick.hoursUntilGame = hoursUntilGame;
                
                // Generate AI reasoning explanation
                const reasons = [];
                const teamPerf = this.model.patterns.teamPerformance[pick.team];
                if (teamPerf && teamPerf.total >= 3) {
                    const teamWinRate = ((teamPerf.wins / teamPerf.total) * 100).toFixed(0);
                    reasons.push(`${pick.team} has ${teamWinRate}% win rate in your history`);
                }
                
                if (parseFloat(pick.discrepancy) > 3.5) {
                    reasons.push(`${pick.discrepancy}% odds value found (great line!)`);
                } else if (parseFloat(pick.discrepancy) > 2.0) {
                    reasons.push(`${pick.discrepancy}% odds edge detected`);
                }
                
                const typePerf = this.model.betTypePerformance[pick.type];
                if (typePerf && typePerf.total >= 5) {
                    const typeWinRate = ((typePerf.wins / typePerf.total) * 100).toFixed(0);
                    if (typeWinRate >= 55) {
                        reasons.push(`${pick.type} bets are ${typeWinRate}% successful`);
                    }
                }
                
                if (pick.isHomeTeam) {
                    const homePerf = this.model.patterns.homeAwayPerformance.home;
                    const homeTotal = homePerf.wins + homePerf.losses;
                    if (homeTotal >= 5) {
                        const homeWR = ((homePerf.wins / homeTotal) * 100).toFixed(0);
                        reasons.push(`Home team advantage (${homeWR}% on home bets)`);
                    }
                }
                
                if (this.model.recentTrend && this.model.recentTrend.currentStreak >= 3 && this.model.recentTrend.streakType === 'win') {
                    reasons.push(`AI on ${this.model.recentTrend.currentStreak}-game win streak üî•`);
                }
                
                pick.aiReasoning = reasons.length > 0 ? reasons : ['High value bet detected based on odds analysis'];
                
                // Only assign confidence tier emoji if AI has proven itself (80%+ win rate)
                const aiWinRate = this.model.totalBets > 0 ? (this.model.wins / this.model.totalBets) : 0;
                
                // Require statistical significance: 30+ bets minimum for confidence display
                if (aiWinRate >= 0.80 && this.model.totalBets >= 30) {
                    // AI has proven itself - show confidence tiers
                    if (pick.confidence >= 95) {
                        pick.confidenceTier = 'üíé'; // Diamond - Elite (95-99%)
                        pick.tierName = 'ELITE';
                        pick.showTier = true;
                    } else if (pick.confidence >= 85) {
                        pick.confidenceTier = 'üî•'; // Fire - Premium (85-94%)
                        pick.tierName = 'PREMIUM';
                        pick.showTier = true;
                    } else if (pick.confidence >= 75) {
                        pick.confidenceTier = '‚≠ê'; // Star - Strong (75-84%)
                        pick.tierName = 'STRONG';
                        pick.showTier = true;
                    } else if (pick.confidence >= 65) {
                        pick.confidenceTier = '‚úÖ'; // Check - Good (65-74%)
                        pick.tierName = 'GOOD';
                        pick.showTier = true;
                    } else {
                        pick.confidenceTier = 'üìä'; // Chart - Standard (50-64%)
                        pick.tierName = 'STANDARD';
                        pick.showTier = true;
                    }
                } else {
                    // AI still learning - no tier badges
                    pick.confidenceTier = null;
                    pick.tierName = 'LEARNING';
                    pick.showTier = false;
                }
                
                // Mark super elite bets when AI has 95%+ win rate
                if (aiWinRate >= 0.95 && this.model.totalBets >= 30) {
                    pick.superElite = true;
                    pick.aiMastery = true;
                }
                
                // Calculate bet sizing (1-5 units based on confidence)
                // Only show units if AI has proven itself
                if (this.model.totalBets >= 30 && aiWinRate >= 0.55) {
                    if (pick.confidence >= 90) {
                        pick.units = 5; // MAX BET
                    } else if (pick.confidence >= 80) {
                        pick.units = 4; // Large bet
                    } else if (pick.confidence >= 70) {
                        pick.units = 3; // Standard bet
                    } else if (pick.confidence >= 60) {
                        pick.units = 2; // Small bet
                    } else {
                        pick.units = 1; // Minimum bet
                    }
                } else {
                    pick.units = 1; // Default to 1 unit while learning
                }
                
                // Store opening odds for CLV tracking
                pick.openingOdds = pick.odds;
                pick.oddsTimestamp = new Date().toISOString();
                
                return pick;
            }
            
            calculateAverage(arr) {
                const filtered = arr.filter(x => x > 0);
                return filtered.length > 0 ? filtered.reduce((a, b) => a + b, 0) / filtered.length : 0;
            }
            
            oddsToProb(odds) {
                if (odds > 0) {
                    return (100 / (odds + 100) * 100).toFixed(1);
                } else {
                    return (Math.abs(odds) / (Math.abs(odds) + 100) * 100).toFixed(1);
                }
            }
            
            recordResult(prediction, won) {
                this.model.totalBets++;
                if (won) {
                    this.model.wins++;
                } else {
                    this.model.losses++;
                }
                
                // Track performance history for analytics
                if (!this.model.performanceHistory) {
                    this.model.performanceHistory = [];
                }
                this.model.performanceHistory.push({
                    timestamp: Date.now(),
                    won,
                    confidence: prediction.confidence,
                    odds: prediction.odds,
                    units: prediction.units || 1,
                    type: prediction.type
                });
                // Keep last 100 bets for analytics
                if (this.model.performanceHistory.length > 100) {
                    this.model.performanceHistory.shift();
                }
                
                // Update recent trend tracking
                if (!this.model.recentTrend) {
                    this.model.recentTrend = { last10: [], last20: [], currentStreak: 0, streakType: null };
                }
                
                // Add to recent results
                this.model.recentTrend.last10.unshift(won);
                this.model.recentTrend.last20.unshift(won);
                if (this.model.recentTrend.last10.length > 10) this.model.recentTrend.last10.pop();
                if (this.model.recentTrend.last20.length > 20) this.model.recentTrend.last20.pop();
                
                // Update streak
                if (this.model.recentTrend.streakType === (won ? 'win' : 'loss')) {
                    this.model.recentTrend.currentStreak++;
                } else {
                    this.model.recentTrend.currentStreak = 1;
                    this.model.recentTrend.streakType = won ? 'win' : 'loss';
                }
                
                // Determine if bet was on home or away team
                const betOnHome = prediction.isHomeTeam !== undefined ? prediction.isHomeTeam : false;
                const betPosition = betOnHome ? 'home' : 'away';
                
                // Track home/away performance
                if (won) {
                    this.model.patterns.homeAwayPerformance[betPosition].wins++;
                } else {
                    this.model.patterns.homeAwayPerformance[betPosition].losses++;
                }
                
                // Track performance by bet type
                const betType = prediction.type || 'Moneyline';
                if (!this.model.betTypePerformance[betType]) {
                    this.model.betTypePerformance[betType] = { wins: 0, losses: 0, total: 0, avgConfidence: 0 };
                }
                this.model.betTypePerformance[betType].total++;
                if (won) {
                    this.model.betTypePerformance[betType].wins++;
                } else {
                    this.model.betTypePerformance[betType].losses++;
                }
                
                // Track confidence level performance
                const confidenceRange = Math.floor(prediction.confidence / 10) * 10;
                if (!this.model.confidenceRanges[confidenceRange]) {
                    this.model.confidenceRanges[confidenceRange] = { wins: 0, total: 0 };
                }
                this.model.confidenceRanges[confidenceRange].total++;
                if (won) this.model.confidenceRanges[confidenceRange].wins++;
                
                // Update team performance tracking
                const team = prediction.team;
                if (!this.model.patterns.teamPerformance[team]) {
                    this.model.patterns.teamPerformance[team] = { wins: 0, total: 0 };
                }
                this.model.patterns.teamPerformance[team].total++;
                if (won) this.model.patterns.teamPerformance[team].wins++;
                
                // Track time-based patterns
                const gameDate = new Date(prediction.gameTime);
                const dayOfWeek = gameDate.toLocaleDateString('en-US', { weekday: 'long' });
                if (!this.model.patterns.dayOfWeekSuccess[dayOfWeek]) {
                    this.model.patterns.dayOfWeekSuccess[dayOfWeek] = { wins: 0, total: 0 };
                }
                this.model.patterns.dayOfWeekSuccess[dayOfWeek].total++;
                if (won) this.model.patterns.dayOfWeekSuccess[dayOfWeek].wins++;
                
                // Add to bet history (keep last 100)
                this.model.betHistory.unshift({
                    date: new Date().toISOString(),
                    game: prediction.game,
                    sport: prediction.sport || 'Unknown',
                    betType: betType,
                    betDetails: prediction.betDetails || prediction.team,
                    team: prediction.team,
                    position: betPosition,
                    odds: prediction.odds,
                    confidence: prediction.confidence,
                    won: won,
                    finalScore: prediction.finalScore
                });
                
                // Keep only last 100 bets
                if (this.model.betHistory.length > 100) {
                    this.model.betHistory = this.model.betHistory.slice(0, 100);
                }
                
                // Auto-learn after every result
                this.learn();
                
                this.saveModel();
            }
            
            learn() {
                this.model.learningCycles++;
                
                // Adjust weights based on overall success rates
                const winRate = this.model.wins / this.model.totalBets;
                
                // Calculate recent momentum (last 10 bets)
                let recentWinRate = 0;
                if (this.model.recentTrend && this.model.recentTrend.last10.length > 0) {
                    const recentWins = this.model.recentTrend.last10.filter(w => w).length;
                    recentWinRate = recentWins / this.model.recentTrend.last10.length;
                    
                    // Adjust momentum weight based on recent performance
                    if (recentWinRate > 0.60) {
                        this.model.weights.recentMomentum = 0.2; // Hot streak
                    } else if (recentWinRate < 0.40) {
                        this.model.weights.recentMomentum = -0.2; // Cold streak, be cautious
                    } else {
                        this.model.weights.recentMomentum = 0;
                    }
                }
                
                // Adaptive thresholds based on performance
                if (!this.model.adaptiveThresholds) {
                    this.model.adaptiveThresholds = { minConfidence: 45, minDiscrepancy: 1.5, minOdds: -250 };
                }
                
                // In early learning (< 15 bets), be more aggressive to gather data
                if (this.model.totalBets < 15) {
                    this.model.adaptiveThresholds.minConfidence = Math.max(40, this.model.adaptiveThresholds.minConfidence - 1);
                    this.model.adaptiveThresholds.minDiscrepancy = Math.max(1.0, this.model.adaptiveThresholds.minDiscrepancy - 0.1);
                } else if (winRate < 0.45) {
                    // Increase selectivity - raise thresholds
                    this.model.weights.oddsDiscrepancy *= 1.15;
                    this.model.weights.marketEfficiency *= 1.08;
                    this.model.adaptiveThresholds.minConfidence = Math.min(70, this.model.adaptiveThresholds.minConfidence + 2);
                    this.model.adaptiveThresholds.minDiscrepancy = Math.min(4.0, this.model.adaptiveThresholds.minDiscrepancy + 0.2);
                } else if (winRate > 0.55) {
                    // Model is working well - can be slightly less conservative
                    this.model.weights.oddsDiscrepancy *= 0.97;
                    this.model.adaptiveThresholds.minConfidence = Math.max(42, this.model.adaptiveThresholds.minConfidence - 1);
                    this.model.adaptiveThresholds.minDiscrepancy = Math.max(1.3, this.model.adaptiveThresholds.minDiscrepancy - 0.1);
                }
                
                // Adjust bet type preferences based on performance
                ['Moneyline', 'Spread', 'Total'].forEach(betType => {
                    const perf = this.model.betTypePerformance[betType];
                    if (perf && perf.total >= 5) {
                        const typeWinRate = perf.wins / perf.total;
                        
                        if (typeWinRate > 0.55) {
                            // This bet type is performing well - increase preference significantly
                            this.model.weights.betTypePreference[betType] = Math.min(1.8, 
                                this.model.weights.betTypePreference[betType] * 1.08);
                        } else if (typeWinRate < 0.45) {
                            // This bet type is underperforming - decrease preference more aggressively
                            this.model.weights.betTypePreference[betType] = Math.max(0.4, 
                                this.model.weights.betTypePreference[betType] * 0.92);
                        }
                    }
                });
                
                // Adjust confidence threshold based on confidence range performance
                let highConfidencePerformance = 0;
                let lowConfidencePerformance = 0;
                
                Object.keys(this.model.confidenceRanges).forEach(range => {
                    const rangeData = this.model.confidenceRanges[range];
                    if (rangeData.total >= 3) {
                        const rangeWinRate = rangeData.wins / rangeData.total;
                        if (parseInt(range) >= 70) {
                            highConfidencePerformance = rangeWinRate;
                        } else if (parseInt(range) <= 50) {
                            lowConfidencePerformance = rangeWinRate;
                        }
                    }
                });
                
                this.saveModel();
                
                return this.generateInsights();
            }
            
            generateInsights() {
                const winRate = ((this.model.wins / this.model.totalBets) * 100).toFixed(1);
                const insights = [];
                
                insights.push(`**Overall Win Rate**: ${winRate}% (${this.model.wins} wins, ${this.model.losses} losses)`);
                
                if (this.model.totalBets > 10) {
                    if (winRate > 55) {
                        insights.push(`‚úÖ **Strong Performance**: AI is beating the market by ${(winRate - 52.4).toFixed(1)}%`);
                    } else if (winRate < 45) {
                        insights.push(`‚ö†Ô∏è **Adjustment Needed**: Increasing selectivity to improve accuracy`);
                    }
                }
                
                // Bet type performance breakdown
                insights.push(`\n**üìä Bet Type Performance:**`);
                ['Moneyline', 'Spread', 'Total'].forEach(betType => {
                    const perf = this.model.betTypePerformance[betType];
                    if (perf && perf.total > 0) {
                        const typeWinRate = ((perf.wins / perf.total) * 100).toFixed(1);
                        const preference = (this.model.weights.betTypePreference[betType] * 100).toFixed(0);
                        const emoji = typeWinRate >= 55 ? 'üî•' : typeWinRate >= 50 ? '‚úÖ' : typeWinRate >= 45 ? '‚ö†Ô∏è' : '‚ùå';
                        insights.push(`  ${emoji} **${betType}**: ${typeWinRate}% (${perf.wins}/${perf.total}) - Preference: ${preference}%`);
                    }
                });
                
                // Home vs Away performance
                const homePerf = this.model.patterns.homeAwayPerformance.home;
                const awayPerf = this.model.patterns.homeAwayPerformance.away;
                const homeTotal = homePerf.wins + homePerf.losses;
                const awayTotal = awayPerf.wins + awayPerf.losses;
                
                if (homeTotal > 0 || awayTotal > 0) {
                    insights.push(`\n**üè† Home vs Away Performance:**`);
                    if (homeTotal > 0) {
                        const homeWinRate = ((homePerf.wins / homeTotal) * 100).toFixed(1);
                        insights.push(`  üè† Home Teams: ${homeWinRate}% (${homePerf.wins}/${homeTotal})`);
                    }
                    if (awayTotal > 0) {
                        const awayWinRate = ((awayPerf.wins / awayTotal) * 100).toFixed(1);
                        insights.push(`  ‚úàÔ∏è Away Teams: ${awayWinRate}% (${awayPerf.wins}/${awayTotal})`);
                    }
                }
                
                insights.push(`\n**Current Strategy**: Focusing on odds discrepancies (weight: ${this.model.weights.oddsDiscrepancy.toFixed(2)})`);
                
                // Confidence calibration
                const confRanges = Object.keys(this.model.confidenceRanges).sort((a, b) => b - a);
                if (confRanges.length > 0) {
                    insights.push(`\n**üéØ Confidence Calibration:**`);
                    confRanges.forEach(range => {
                        const data = this.model.confidenceRanges[range];
                        if (data.total >= 3) {
                            const actualWinRate = ((data.wins / data.total) * 100).toFixed(1);
                            insights.push(`  ${range}-${parseInt(range) + 9}% confidence ‚Üí ${actualWinRate}% actual (${data.wins}/${data.total})`);
                        }
                    });
                }
                
                // Top performing teams
                const topTeams = Object.entries(this.model.patterns.teamPerformance)
                    .filter(([_, data]) => data.total >= 3)
                    .map(([team, data]) => ({ team, rate: (data.wins / data.total * 100).toFixed(0) }))
                    .sort((a, b) => b.rate - a.rate)
                    .slice(0, 3);
                
                if (topTeams.length > 0) {
                    insights.push(`**Top Teams**: ${topTeams.map(t => `${t.team} (${t.rate}%)`).join(', ')}`);
                }
                
                return insights;
            }
        }
        
        const ai = new BettingAI();
        
        function selectSport(sportKey, sportName) {
            currentSport = sportKey;
            currentSportName = sportName;
            document.getElementById('selectedSport').textContent = sportName;
            document.querySelectorAll('.sport-btn').forEach(btn => {
                btn.classList.remove('border-purple-500', 'bg-purple-50');
            });
            event.target.closest('.sport-btn').classList.add('border-purple-500', 'bg-purple-50');
        }
        
        async function analyzeGames() {
            const btn = document.getElementById('analyzeBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="text-lg">‚è≥ Analyzing...</div><div class="text-xs opacity-90">Checking all sports...</div>';
            
            try {
                // All sports to analyze
                const sports = [
                    { key: 'americanfootball_nfl', name: 'NFL', emoji: 'üèà' },
                    { key: 'basketball_nba', name: 'NBA', emoji: 'üèÄ' },
                    { key: 'icehockey_nhl', name: 'NHL', emoji: 'üèí' },
                    { key: 'baseball_mlb', name: 'MLB', emoji: '‚öæ' },
                    { key: 'americanfootball_ncaaf', name: 'NCAAF', emoji: 'üéì' }
                ];
                
                const newPredictions = [];
                const existingGameIds = new Set(predictions.map(p => p.gameId));
                
                // Track existing ML bets by team to prevent contradictions
                const existingMLTeams = new Map();
                predictions.forEach(p => {
                    if (p.type === 'Moneyline') {
                        // Store the team and opponent for this ML bet
                        existingMLTeams.set(p.team, p.opponent);
                    }
                });
                
                for (const sport of sports) {
                    console.log(`Analyzing ${sport.name}...`);
                    
                    try {
                        const url = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${ODDS_API_KEY}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`;
                        
                        // Check cache first
                        let games = apiCache.get(sport.key);
                        if (!games) {
                            const response = await fetch(url);
                            trackApiCall(); // Count this API request
                            
                            if (!response.ok) continue;
                            
                            games = await response.json();
                            apiCache.set(sport.key, games, 5); // Cache for 5 minutes
                            console.log(`${sport.name}: ${games.length} games (from API)`);
                        } else {
                            console.log(`${sport.name}: ${games.length} games (from cache ‚ö°)`);
                        }
                        
                        games.forEach(game => {
                            // Skip if we already have any prediction for this game
                            if (existingGameIds.has(game.id)) {
                                console.log(`Skipping ${game.id} - already have prediction`);
                                return;
                            }
                            
                            // Calculate timing for game filtering
                            const gameDate = new Date(game.commence_time);
                            const now = new Date();
                            const hoursUntilGame = (gameDate - now) / (1000 * 60 * 60);
                            const aiWinRate = ai.model.totalBets > 0 ? (ai.model.wins / ai.model.totalBets) : 0;
                            
                            // PRIORITY: Games happening within 24 hours (TODAY)
                            // ONLY allow future games if AI has 95%+ win rate
                            if (hoursUntilGame > 24 && aiWinRate < 0.95) {
                                console.log(`‚è≠Ô∏è Skipping ${game.home_team} vs ${game.away_team} - game in ${hoursUntilGame.toFixed(1)}h (AI needs 95%+ win rate for future games)`);
                                return;
                            }
                            
                            const pick = ai.analyzeGame(game);
                            if (pick) {
                                // Check if this is a ML bet that contradicts an existing ML bet
                                if (pick.type === 'Moneyline') {
                                    // Check if we already have a ML bet for either team in this matchup
                                    if (existingMLTeams.has(pick.team)) {
                                        console.log(`‚ö†Ô∏è Already have ML bet for ${pick.team} - keeping original pick`);
                                        return;
                                    }
                                    if (existingMLTeams.has(pick.opponent)) {
                                        console.log(`‚ö†Ô∏è Already have ML bet for ${pick.opponent} - keeping original pick`);
                                        return;
                                    }
                                }
                                
                                pick.sport = sport.name;
                                pick.sportEmoji = sport.emoji;
                                console.log('AI Pick:', pick);
                                newPredictions.push(pick);
                            }
                        });
                    } catch (error) {
                        console.error(`Error analyzing ${sport.name}:`, error);
                    }
                }
                
                console.log(`Generated ${newPredictions.length} new predictions`);
                console.log(`Keeping ${predictions.length} existing predictions`);
                
                if (newPredictions.length === 0) {
                    const msg = predictions.length > 0 
                        ? `‚è∞ No new high-value bets found. Keeping your ${predictions.length} active predictions!`
                        : '‚è∞ No high-value bets found across all sports. AI is being selective!';
                    alert(msg);
                    btn.disabled = false;
                    btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
                    return;
                }
                
                const oldCount = predictions.length;
                
                // Sort new predictions by confidence
                newPredictions.sort((a, b) => b.confidence - a.confidence);
                
                // Add ALL new predictions to existing ones (keep ALL old ones)
                predictions.push(...newPredictions);
                
                // Sort all predictions by confidence
                predictions.sort((a, b) => b.confidence - a.confidence);
                
                // Save to localStorage
                savePredictions();
                
                console.log(`Total predictions: ${predictions.length} (${oldCount} kept + ${newPredictions.length} new)`);
                
                displayPredictions();
                
                // Only show tier breakdown if AI has earned it
                const aiWinRate = ai.model.totalBets > 0 ? (ai.model.wins / ai.model.totalBets) : 0;
                let alertMsg = `‚úÖ Added ${newPredictions.length} new bets! Total active: ${predictions.length} (kept ${oldCount} existing)\n\n`;
                
                if (aiWinRate >= 0.95 && ai.model.totalBets >= 30) {
                    const superElite = newPredictions.filter(p => p.superElite).length;
                    if (superElite > 0) {
                        alertMsg += `\nüí∞üíéüí∞ AI MASTER MODE ACTIVE! üí∞üíéüí∞\n`;
                        alertMsg += `${superElite} MONEY MAKER BET${superElite > 1 ? 'S' : ''}!\n`;
                        alertMsg += `AI Win Rate: ${(aiWinRate * 100).toFixed(1)}% üî•\n`;
                    }
                } else if (aiWinRate >= 0.80 && ai.model.totalBets >= 30) {
                    const eliteBets = newPredictions.filter(p => p.confidence >= 95).length;
                    const premiumBets = newPredictions.filter(p => p.confidence >= 85 && p.confidence < 95).length;
                    const strongBets = newPredictions.filter(p => p.confidence >= 75 && p.confidence < 85).length;
                    if (eliteBets > 0) alertMsg += `üíé ELITE bets (95%+): ${eliteBets}\n`;
                    if (premiumBets > 0) alertMsg += `üî• PREMIUM bets (85-94%): ${premiumBets}\n`;
                    if (strongBets > 0) alertMsg += `‚≠ê STRONG bets (75-84%): ${strongBets}\n`;
                } else {
                    alertMsg += `üß† AI is learning... (${ai.model.totalBets} bets analyzed)\n`;
                    const betsNeeded = Math.max(0, 30 - ai.model.totalBets);
                    if (betsNeeded > 0) {
                        alertMsg += `Need ${betsNeeded} more bets for statistical significance\n`;
                    }
                    const usage = getApiUsage();
                    alertMsg += `API Usage: ${usage.count}/${usage.limit} this month`;
                }
                
                alert(alertMsg);
                
            } catch (error) {
                console.error('Full error:', error);
                alert('Error fetching games: ' + error.message + '\n\nCheck browser console for details.');
            }
            
            btn.disabled = false;
            btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
        }
        
        function displayPredictions() {
            const container = document.getElementById('predictions');
            
            // Apply confidence filter
            const filteredPredictions = predictions.filter(p => p.confidence >= minConfidenceFilter);
            
            if (filteredPredictions.length === 0) {
                if (predictions.length > 0 && minConfidenceFilter > 0) {
                    container.innerHTML = `<div class="text-center text-gray-400 py-8">No bets match ${minConfidenceFilter}%+ confidence filter. ${predictions.length} bets hidden.</div>`;
                } else {
                    container.innerHTML = '<div class="text-center text-gray-400 py-8">No high-value bets found. AI is being selective! üéØ</div>';
                }
                return;
            }
            
            container.innerHTML = filteredPredictions.map((p, i) => {
                // Ensure all properties exist
                const betType = p.type || 'Moneyline';
                const betDetails = p.betDetails || `${p.team} to Win`;
                const sportDisplay = p.sport ? `${p.sportEmoji || ''} ${p.sport}` : '';
                const gameDate = new Date(p.gameTime);
                const now = new Date();
                const isToday = gameDate.toDateString() === now.toDateString();
                const isTomorrow = gameDate.toDateString() === new Date(now.getTime() + 86400000).toDateString();
                
                let dateStr = '';
                if (isToday) dateStr = 'Today';
                else if (isTomorrow) dateStr = 'Tomorrow';
                else dateStr = gameDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                
                const timeStr = gameDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                
                // Calculate potential payout for display
                const odds = p.odds || 0;
                let payout100 = 0;
                let payout500 = 0;
                let payout1000 = 0;
                if (odds > 0) {
                    payout100 = 100 + (100 * odds / 100);
                    payout500 = 500 + (500 * odds / 100);
                    payout1000 = 1000 + (1000 * odds / 100);
                } else if (odds < 0) {
                    payout100 = 100 + (100 * 100 / Math.abs(odds));
                    payout500 = 500 + (500 * 100 / Math.abs(odds));
                    payout1000 = 1000 + (1000 * 100 / Math.abs(odds));
                }
                
                // Determine border color based on confidence tier and AI mastery
                let borderClass = 'border-gray-200';
                let bgClass = '';
                if (p.settled) {
                    borderClass = p.won ? 'border-green-400' : 'border-red-400';
                    bgClass = p.won ? 'bg-green-50' : 'bg-red-50';
                } else if (p.superElite && p.showTier) {
                    // AI has 95%+ win rate - SUPER OBVIOUS
                    borderClass = 'border-8 border-yellow-400 shadow-2xl animate-pulse';
                    bgClass = 'bg-gradient-to-r from-yellow-100 via-green-100 to-yellow-100';
                } else if (p.showTier && p.confidence >= 95) {
                    borderClass = 'border-purple-500 shadow-lg';
                    bgClass = 'bg-gradient-to-r from-purple-50 to-pink-50';
                } else if (p.showTier && p.confidence >= 85) {
                    borderClass = 'border-orange-500';
                    bgClass = 'bg-orange-50';
                } else if (p.showTier && p.confidence >= 75) {
                    borderClass = 'border-yellow-400';
                    bgClass = 'bg-yellow-50';
                }
                
                return `
                <div class="border-2 ${borderClass} ${bgClass} rounded-lg p-4 hover:border-purple-400 transition slide-in">
                    <!-- Super Elite Money Alert (AI 95%+ Win Rate) -->
                    ${p.superElite && p.showTier && !p.settled ? `
                        <div class="mb-3 p-4 bg-gradient-to-r from-yellow-400 via-green-400 to-yellow-400 rounded-lg border-4 border-yellow-600 animate-pulse">
                            <div class="text-center">
                                <div class="text-3xl mb-2">üí∞ üíé üí∞ MONEY MAKER üí∞ üíé üí∞</div>
                                <div class="text-lg font-black text-gray-900">AI MASTER PICK - ${p.confidence.toFixed(0)}% CONFIDENCE</div>
                                <div class="text-sm font-bold text-gray-800 mt-2">POTENTIAL PAYOUT:</div>
                                <div class="flex justify-around mt-2 text-gray-900 font-bold">
                                    <div>$100 ‚Üí <span class="text-green-700 text-xl">$${payout100.toFixed(0)}</span></div>
                                    <div>$500 ‚Üí <span class="text-green-700 text-xl">$${payout500.toFixed(0)}</span></div>
                                    <div>$1000 ‚Üí <span class="text-green-700 text-2xl">$${payout1000.toFixed(0)}</span></div>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- Confidence Tier Badge (Only if AI earned it with 80%+ win rate) -->
                    ${p.showTier && p.confidenceTier && !p.settled && !p.superElite ? `
                        <div class="flex items-center justify-between mb-2">
                            <div class="inline-block ${p.confidence >= 95 ? 'bg-gradient-to-r from-purple-600 to-pink-600' : p.confidence >= 85 ? 'bg-gradient-to-r from-orange-500 to-red-500' : 'bg-gradient-to-r from-yellow-500 to-orange-500'} text-white text-xs font-bold px-3 py-1 rounded-full">
                                ${p.confidenceTier} ${p.tierName} BET
                            </div>
                            ${sportDisplay ? `<div class="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-2 py-1 rounded">${sportDisplay}</div>` : ''}
                        </div>
                    ` : `
                        ${sportDisplay ? `<div class="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-2 py-1 rounded mb-2">${sportDisplay}</div>` : ''}
                    `}
                    
                    <!-- Game Header -->
                    <div class="flex items-center gap-2 mb-3">
                        <span class="text-4xl">${p.settled ? (p.won ? '‚úÖ' : '‚ùå') : (p.confidenceTier || 'üìä')}</span>
                        <div class="flex-1">
                            <div class="font-bold text-base text-gray-900">
                                ${p.game}
                            </div>
                            <div class="text-xs text-gray-500">
                                üìÖ ${dateStr} at ${timeStr}
                                ${p.settled ? `<span class="ml-2 font-bold ${p.won ? 'text-green-600' : 'text-red-600'}">${p.won ? 'WON' : 'LOST'}</span>` : '<span class="ml-2 text-orange-600">PENDING</span>'}
                            </div>
                        </div>
                        ${p.showTier && !p.superElite ? `
                            <div class="text-right">
                                <div class="text-xs text-gray-400">Confidence</div>
                                <div class="text-2xl font-bold ${p.confidence >= 85 ? 'text-green-600' : 'text-purple-600'}">${p.confidence.toFixed(0)}%</div>
                            </div>
                        ` : !p.settled ? `
                            <div class="text-right">
                                <div class="text-xs text-gray-400">Status</div>
                                <div class="text-sm font-bold text-blue-600">üß† Learning</div>
                            </div>
                        ` : ''}
                    </div>
                    
                    ${p.settled && p.finalScore ? `
                    <div class="mb-3 p-2 bg-gray-100 rounded text-center">
                        <div class="text-xs text-gray-500">Final Score</div>
                        <div class="font-bold text-sm text-gray-900">${p.finalScore}</div>
                        ${p.closingOdds && p.openingOdds && p.closingOdds !== p.openingOdds ? `
                            <div class="text-xs mt-1 ${p.closingOdds > p.openingOdds ? 'text-green-600' : 'text-red-600'}">
                                CLV: ${p.openingOdds > 0 ? '+' : ''}${p.openingOdds} ‚Üí ${p.closingOdds > 0 ? '+' : ''}${p.closingOdds}
                                ${p.closingOdds > p.openingOdds ? '‚úì Beat closing line!' : '‚úó Worse than close'}
                            </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <!-- Bet Details - PROMINENT DISPLAY -->
                    <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg p-3 mb-3">
                        <div class="flex justify-between items-center mb-1">
                            <div class="text-xs font-semibold opacity-90">üìå ${betType.toUpperCase()}</div>
                            ${p.units && !p.settled ? `<div class="text-xs font-bold bg-white bg-opacity-20 px-2 py-1 rounded">${p.units} UNIT${p.units > 1 ? 'S' : ''}</div>` : ''}
                        </div>
                        <div class="text-xl font-bold">${betDetails}</div>
                        <div class="text-sm opacity-90 mt-1">@ ${p.odds > 0 ? '+' : ''}${p.odds}</div>
                    </div>
                    
                    <!-- Sportsbook Comparison -->
                    ${!p.settled && p.bestBook ? `
                    <div class="mb-3 p-3 bg-green-50 border-2 border-green-200 rounded-lg">
                        <div class="text-xs font-bold text-green-800 mb-2">üèÜ BEST LINE FOUND:</div>
                        <div class="flex justify-between items-center">
                            <div class="font-bold text-green-700">${p.bestBook}</div>
                            <div class="text-xl font-black text-green-600">${p.odds > 0 ? '+' : ''}${p.odds}</div>
                        </div>
                        ${p.allBooks && p.allBooks.length > 1 ? `
                            <details class="mt-2">
                                <summary class="text-xs text-gray-600 cursor-pointer hover:text-gray-800">Compare ${p.allBooks.length} sportsbooks</summary>
                                <div class="mt-2 space-y-1">
                                    ${p.allBooks.sort((a, b) => b.odds - a.odds).map(b => `
                                        <div class="flex justify-between text-xs ${b.book === p.bestBook ? 'font-bold text-green-700' : 'text-gray-600'}">
                                            <span>${b.book}</span>
                                            <span>${b.odds > 0 ? '+' : ''}${b.odds}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </details>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <!-- AI Reasoning -->
                    ${!p.settled && p.aiReasoning && p.aiReasoning.length > 0 ? `
                    <div class="mb-3 p-3 bg-blue-50 border-2 border-blue-200 rounded-lg">
                        <div class="text-xs font-bold text-blue-800 mb-2">üß† WHY AI PICKED THIS:</div>
                        <ul class="space-y-1">
                            ${p.aiReasoning.map(reason => `
                                <li class="text-xs text-blue-700">‚Ä¢ ${reason}</li>
                            `).join('')}
                        </ul>
                    </div>
                    ` : ''}
                    
                    <!-- Stats Grid -->
                    <div class="grid grid-cols-3 gap-2 text-center">
                        <div class="bg-green-50 rounded p-2">
                            <div class="text-xs text-green-700">Best Odds</div>
                            <div class="font-bold text-green-600">${p.odds > 0 ? '+' : ''}${p.odds}</div>
                        </div>
                        <div class="bg-orange-50 rounded p-2">
                            <div class="text-xs text-orange-700">Value</div>
                            <div class="font-bold text-orange-600">+${p.discrepancy}%</div>
                        </div>
                        <div class="bg-blue-50 rounded p-2">
                            <div class="text-xs text-blue-700">Win Prob</div>
                            <div class="font-bold text-blue-600">${p.implied}%</div>
                        </div>
                    </div>
                    
                    ${p.confidence > 70 ? '<div class="mt-2 text-center text-xs text-green-600 font-bold">‚ú® HIGH CONFIDENCE BET</div>' : ''}
                </div>
                `;
            }).join('');
        }
        
        async function settleBets(silentMode = false) {
            if (predictions.length === 0) {
                if (!silentMode) alert('No predictions to settle. Analyze games first!');
                return;
            }
            
            // Show settlement log
            const logDiv = document.getElementById('settlementLog');
            const logContent = document.getElementById('logContent');
            if (!silentMode) {
                logDiv.classList.remove('hidden');
                logContent.innerHTML = '';
            }
            
            function addLog(message, type = 'info') {
                const colors = {
                    'info': 'text-gray-300',
                    'success': 'text-green-400',
                    'error': 'text-red-400',
                    'warning': 'text-yellow-400',
                    'header': 'text-blue-400 font-bold'
                };
                if (!silentMode) {
                    const log = document.createElement('div');
                    log.className = colors[type];
                    log.textContent = message;
                    logContent.appendChild(log);
                    logContent.scrollTop = logContent.scrollHeight;
                }
                console.log(message);
            }
            
            const btn = document.getElementById('settleBtn');
            if (!silentMode) {
                btn.disabled = true;
                btn.innerHTML = '<div class="text-lg">‚è≥ Settling...</div><div class="text-xs opacity-90">Getting results</div>';
            }
            
            try {
                addLog('üîç Starting settlement process...', 'header');
                addLog('', 'info');
                addLog(`üì° Fetching scores from API for all sports...`, 'info');
                
                // Fetch scores from all sports
                const sports = [
                    'americanfootball_nfl',
                    'basketball_nba',
                    'icehockey_nhl',
                    'baseball_mlb',
                    'americanfootball_ncaaf'
                ];
                
                let allScores = [];
                for (const sport of sports) {
                    try {
                        const response = await fetch(`https://api.the-odds-api.com/v4/sports/${sport}/scores?apiKey=${ODDS_API_KEY}&daysFrom=3`);
                        trackApiCall(); // Count this API request
                        if (response.ok) {
                            const scores = await response.json();
                            if (Array.isArray(scores)) {
                                allScores = allScores.concat(scores);
                            }
                        }
                    } catch (e) {
                        console.error(`Error fetching ${sport} scores:`, e);
                    }
                }
                
                addLog(`‚úÖ Received ${allScores.length} game results from API`, 'success');
                addLog(`üìä Checking ${predictions.length} predictions...`, 'info');
                addLog('', 'info');
                addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                
                let settled = 0;
                let wins = 0;
                let losses = 0;
                
                predictions.forEach((pred, index) => {
                    addLog('', 'info');
                    
                    if (pred.settled) {
                        addLog(`‚è≠Ô∏è  Prediction #${index + 1}: Already settled`, 'warning');
                        addLog(`   Game: ${pred.game}`, 'warning');
                        return;
                    }
                    
                    const score = allScores.find(s => s.id === pred.gameId);
                    
                    if (!score) {
                        addLog(`‚è∞ Prediction #${index + 1}: Game not found in results`, 'warning');
                        addLog(`   Game: ${pred.game}`, 'warning');
                        addLog(`   GameID: ${pred.gameId}`, 'warning');
                        return;
                    }
                    
                    if (!score.completed) {
                        addLog(`‚è∞ Prediction #${index + 1}: Game not completed yet`, 'warning');
                        addLog(`   Game: ${score.away_team} @ ${score.home_team}`, 'warning');
                        addLog(`   Status: In Progress`, 'warning');
                        return;
                    }
                    
                    const homeScore = score.scores?.find(s => s.name === score.home_team)?.score;
                    const awayScore = score.scores?.find(s => s.name === score.away_team)?.score;
                    
                    addLog(`üèà Prediction #${index + 1}: ${score.away_team} @ ${score.home_team}`, 'header');
                    addLog(`   Final Score: ${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`, 'info');
                    addLog(`   AI Picked: ${pred.team} (${pred.confidence}% confidence)`, 'info');
                    
                    if (homeScore !== undefined && awayScore !== undefined) {
                        let won = false;
                        let resultDetails = '';
                        
                        // Determine result based on bet type
                        if (pred.type === 'Moneyline') {
                            // Moneyline: Did the picked team win?
                            let winner;
                            if (homeScore > awayScore) {
                                winner = score.home_team;
                                resultDetails = `${score.home_team} won by ${homeScore - awayScore}`;
                            } else if (awayScore > homeScore) {
                                winner = score.away_team;
                                resultDetails = `${score.away_team} won by ${awayScore - homeScore}`;
                            } else {
                                winner = 'TIE';
                                resultDetails = 'Game ended in TIE';
                            }
                            won = winner === pred.team;
                            addLog(`   üèÜ Result: ${resultDetails}`, 'info');
                            
                        } else if (pred.type === 'Spread') {
                            // Spread: Apply the spread line to determine winner
                            const spreadLine = pred.spreadLine || 0;
                            const isHomePick = pred.team === score.home_team;
                            
                            if (isHomePick) {
                                const homeWithSpread = homeScore + spreadLine;
                                won = homeWithSpread > awayScore;
                                resultDetails = `${score.home_team} ${spreadLine > 0 ? '+' : ''}${spreadLine.toFixed(1)} ‚Üí Adjusted: ${homeWithSpread.toFixed(1)} vs ${awayScore}`;
                            } else {
                                const awayWithSpread = awayScore + spreadLine;
                                won = awayWithSpread > homeScore;
                                resultDetails = `${score.away_team} ${spreadLine > 0 ? '+' : ''}${spreadLine.toFixed(1)} ‚Üí Adjusted: ${awayWithSpread.toFixed(1)} vs ${homeScore}`;
                            }
                            addLog(`   üìä Spread Result: ${resultDetails}`, 'info');
                            
                        } else if (pred.type === 'Total') {
                            // Total: Did the combined score go over/under the line?
                            const totalLine = pred.totalLine || 0;
                            const actualTotal = homeScore + awayScore;
                            
                            if (pred.team === 'Over') {
                                won = actualTotal > totalLine;
                                resultDetails = `Total: ${actualTotal} (Line: ${totalLine}) - ${won ? 'OVER' : 'UNDER'}`;
                            } else if (pred.team === 'Under') {
                                won = actualTotal < totalLine;
                                resultDetails = `Total: ${actualTotal} (Line: ${totalLine}) - ${won ? 'UNDER' : 'OVER'}`;
                            }
                            addLog(`   üéØ Total Result: ${resultDetails}`, 'info');
                        }
                        
                        // Log final result
                        if (won) {
                            addLog(`   ‚úÖ RESULT: AI WON! ${pred.betDetails}`, 'success');
                            wins++;
                        } else {
                            addLog(`   ‚ùå RESULT: AI LOST - ${pred.betDetails}`, 'error');
                            losses++;
                        }
                        
                        // Record to AI model
                        ai.recordResult(pred, won);
                        pred.settled = true;
                        pred.won = won;
                        pred.finalScore = `${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`;
                        settled++;
                        
                        addLog(`   üíæ Result recorded to AI model`, 'info');
                        
                    } else {
                        addLog(`   ‚ö†Ô∏è Score data incomplete or missing`, 'error');
                        addLog(`   Home Score: ${homeScore}, Away Score: ${awayScore}`, 'error');
                    }
                });
                
                addLog('', 'info');
                addLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                addLog('üìà SETTLEMENT SUMMARY', 'header');
                addLog(`   Total Bets Settled: ${settled}`, 'success');
                addLog(`   Wins: ${wins} ‚úÖ`, 'success');
                addLog(`   Losses: ${losses} ‚ùå`, 'error');
                
                if (settled > 0) {
                    const winRate = ((wins / settled) * 100).toFixed(1);
                    const profitable = winRate >= 52.4;
                    addLog(`   Win Rate: ${winRate}% ${profitable ? 'üéØ' : ''}`, profitable ? 'success' : 'warning');
                    addLog(`   ${profitable ? 'üí∞ Profitable!' : 'üìä Keep learning...'}`, profitable ? 'success' : 'warning');
                    
                    // Remove settled predictions from the list
                    addLog('', 'info');
                    addLog('üóëÔ∏è Removing settled bets from active list...', 'info');
                    const beforeCount = predictions.length;
                    predictions = predictions.filter(p => !p.settled);
                    const removedCount = beforeCount - predictions.length;
                    addLog(`   Removed ${removedCount} settled bets`, 'success');
                    addLog(`   ${predictions.length} active bets remaining`, 'info');
                    
                    savePredictions(); // Save updated predictions
                    displayPredictions();
                    updateStats(); // Update stats after settlement
                    
                    // Send notification
                    const notifMessage = `‚úÖ ${settled} bets settled - ${wins}W/${losses}L (${winRate}%)`;
                    if (silentMode) {
                        showNotification(notifMessage, profitable ? 'success' : 'warning');
                        console.log(`ü§ñ Auto-settled ${settled} bets (${wins}W/${losses}L - ${winRate}% WR) - ${predictions.length} active remaining`);
                    } else {
                        alert(`‚úÖ Settled ${settled} bets!\n\nWins: ${wins} ‚úÖ\nLosses: ${losses} ‚ùå\nWin Rate: ${winRate}%\n\nüóëÔ∏è Removed ${removedCount} finished bets\nüìä ${predictions.length} bets still active\n\nAI is learning from results...`);
                    }
                    }
                } else {
                    addLog('   ‚è∞ No games finished yet', 'warning');
                    if (!silentMode) alert('‚è∞ Games not finished yet. Check back later!');
                }
                
            } catch (error) {
                addLog('', 'info');
                addLog(`‚ùå ERROR: ${error.message}`, 'error');
                console.error('Settlement error:', error);
                if (!silentMode) alert('Error fetching scores: ' + error.message);
            }
            
            if (!silentMode) {
                btn.disabled = false;
                btn.innerHTML = '<div class="text-lg">‚úÖ Settle Results</div><div class="text-xs opacity-90">Get real game outcomes</div>';
            }
        }
        
        function clearAllBets() {
            if (confirm('‚ö†Ô∏è Clear all bets? This will remove all predictions but keep your AI learning data.')) {
                predictions = [];
                savePredictions();
                displayPredictions();
                alert('‚úÖ All bets cleared!');
            }
        }
        
        function runLearningCycle() {
            const insights = ai.learn();
            
            const container = document.getElementById('insights');
            container.innerHTML = `
                <div class="bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-200 rounded-lg p-6">
                    <h3 class="text-lg font-bold text-purple-900 mb-3">üéì AI Learning Complete</h3>
                    <div class="space-y-2 text-sm text-gray-700">
                        ${insights.map(insight => `<div>‚Ä¢ ${insight}</div>`).join('')}
                    </div>
                </div>
            `;
            
            updateStats();
            
            alert('üß† AI has completed a learning cycle and updated its strategy!');
        }
        
        function updateStats() {
            const totalBets = ai.model.totalBets;
            const winRate = totalBets > 0 ? ((ai.model.wins / totalBets) * 100).toFixed(1) : '0';
            
            // Calculate best bet type
            let bestBetType = 'Learning...';
            let bestWinRate = 0;
            ['Moneyline', 'Spread', 'Total'].forEach(type => {
                const perf = ai.model.betTypePerformance[type];
                if (perf && perf.total >= 3) {
                    const typeRate = (perf.wins / perf.total) * 100;
                    if (typeRate > bestWinRate) {
                        bestWinRate = typeRate;
                        bestBetType = `${type} (${typeRate.toFixed(1)}%)`;
                    }
                }
            });
            
            // Update basic stats
            document.getElementById('totalBets').textContent = totalBets;
            document.getElementById('winRate').textContent = winRate + '%';
            document.getElementById('confidence').textContent = bestBetType;
            document.getElementById('cycles').textContent = ai.model.learningCycles;
            
            // Update progress bars with animation
            const totalBetsProgress = Math.min(100, (totalBets / 100) * 100);
            document.getElementById('totalBetsProgress').style.width = totalBetsProgress + '%';
            document.getElementById('winRateProgress').style.width = winRate + '%';
            
            // Show trend indicators
            if (ai.model.recentTrend && ai.model.recentTrend.last10.length >= 5) {
                const recentWins = ai.model.recentTrend.last10.filter(w => w).length;
                const recentWinRate = (recentWins / ai.model.recentTrend.last10.length * 100).toFixed(0);
                const trendEl = document.getElementById('winRateTrend');
                
                if (recentWinRate >= 60) {
                    trendEl.textContent = 'üî• HOT';
                    trendEl.className = 'text-xs font-bold text-green-600';
                } else if (recentWinRate <= 40) {
                    trendEl.textContent = '‚ùÑÔ∏è COLD';
                    trendEl.className = 'text-xs font-bold text-red-600';
                } else {
                    trendEl.textContent = '‚û°Ô∏è STEADY';
                    trendEl.className = 'text-xs font-bold text-gray-600';
                }
                
                // Show recent streak
                const streakEl = document.getElementById('recentStreak');
                if (ai.model.recentTrend.currentStreak >= 3) {
                    const streakEmoji = ai.model.recentTrend.streakType === 'win' ? 'üî•' : '‚ö†Ô∏è';
                    const streakText = ai.model.recentTrend.streakType === 'win' ? 'Win Streak' : 'Loss Streak';
                    const streakColor = ai.model.recentTrend.streakType === 'win' ? 'text-green-600' : 'text-red-600';
                    streakEl.textContent = `${streakEmoji} ${ai.model.recentTrend.currentStreak} ${streakText}`;
                    streakEl.className = `text-xs font-semibold mt-2 ${streakColor}`;
                } else {
                    streakEl.textContent = '';
                }
            }
            
            // Show win rate assessment
            const winRateSubtext = document.getElementById('winRateSubtext');
            if (totalBets >= 10) {
                if (winRate >= 55) {
                    winRateSubtext.textContent = 'üí∞ Profitable! (>55%)';
                    winRateSubtext.className = 'text-xs mt-1 text-green-600 font-semibold';
                } else if (winRate >= 50) {
                    winRateSubtext.textContent = '‚úÖ Break-even zone';
                    winRateSubtext.className = 'text-xs mt-1 text-yellow-600 font-semibold';
                } else {
                    winRateSubtext.textContent = 'üìö Still learning...';
                    winRateSubtext.className = 'text-xs mt-1 text-gray-600';
                }
            } else {
                winRateSubtext.textContent = 'AI accuracy';
                winRateSubtext.className = 'text-xs text-gray-400 mt-1';
            }
            
            // Show momentum indicator
            const momentumEl = document.getElementById('momentum');
            if (ai.model.weights.recentMomentum) {
                if (ai.model.weights.recentMomentum > 0) {
                    momentumEl.textContent = 'üìà Positive momentum';
                } else if (ai.model.weights.recentMomentum < 0) {
                    momentumEl.textContent = 'üìâ Adjusting strategy';
                } else {
                    momentumEl.textContent = '';
                }
            }
            
            // Update performance analytics
            updatePerformanceChart();
        }
        
        // Performance Analytics with Chart.js
        let performanceChart = null;
        function updatePerformanceChart() {
            const ctx = document.getElementById('performanceChart');
            if (!ctx) return;
            
            // Get historical data from AI model
            const history = ai.model.performanceHistory || [];
            
            // Calculate 7-day stats
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const recentBets = history.filter(h => h.timestamp > sevenDaysAgo);
            const recentWins = recentBets.filter(h => h.won).length;
            const weekWinRate = recentBets.length > 0 ? ((recentWins / recentBets.length) * 100).toFixed(1) : '-';
            document.getElementById('weekWinRate').textContent = recentBets.length > 0 ? weekWinRate + '%' : '-';
            
            // Calculate ROI in units
            let totalUnits = 0;
            recentBets.forEach(bet => {
                const units = bet.units || 1;
                if (bet.won) {
                    // American odds to decimal conversion for profit
                    const profit = bet.odds > 0 ? (bet.odds / 100) * units : (100 / Math.abs(bet.odds)) * units;
                    totalUnits += profit;
                } else {
                    totalUnits -= units;
                }
            });
            document.getElementById('roiUnits').textContent = totalUnits > 0 ? '+' + totalUnits.toFixed(1) : totalUnits.toFixed(1);
            
            // Current streak
            const currentStreak = ai.model.recentTrend?.currentStreak || 0;
            const streakType = ai.model.recentTrend?.streakType;
            if (currentStreak >= 2) {
                document.getElementById('currentStreakDisplay').textContent = 
                    streakType === 'win' ? `üî• ${currentStreak}W` : `‚ùÑÔ∏è ${currentStreak}L`;
            } else {
                document.getElementById('currentStreakDisplay').textContent = '-';
            }
            
            // Prepare chart data (last 20 bets)
            const chartData = history.slice(-20);
            const labels = chartData.map((_, i) => `Bet ${i + 1}`);
            const winData = chartData.map(h => h.won ? 1 : 0);
            const confidenceData = chartData.map(h => h.confidence || 50);
            
            // Create or update chart
            if (performanceChart) {
                performanceChart.data.labels = labels;
                performanceChart.data.datasets[0].data = winData;
                performanceChart.data.datasets[1].data = confidenceData;
                performanceChart.update();
            } else {
                performanceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Win/Loss',
                                data: winData,
                                borderColor: 'rgb(34, 197, 94)',
                                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                yAxisID: 'y',
                                stepped: true
                            },
                            {
                                label: 'Confidence',
                                data: confidenceData,
                                borderColor: 'rgb(168, 85, 247)',
                                backgroundColor: 'rgba(168, 85, 247, 0.1)',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            y: { type: 'linear', display: true, position: 'left', min: 0, max: 1, title: { display: true, text: 'Result' } },
                            y1: { type: 'linear', display: true, position: 'right', min: 0, max: 100, title: { display: true, text: 'Confidence %' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }
        }
        
        // Auto-settlement system - Smart timing to avoid API limit
        function getGameDuration(sport) {
            // Approximate game durations in minutes
            const durations = {
                'NFL': 210,      // ~3.5 hours
                'NCAAF': 210,    // ~3.5 hours
                'NBA': 150,      // ~2.5 hours
                'NHL': 150,      // ~2.5 hours
                'MLB': 180       // ~3 hours
            };
            return durations[sport] || 180;
        }
        
        function getNextSettlementTime() {
            if (predictions.length === 0) return null;
            
            const now = new Date();
            let earliestCheck = null;
            
            // Find the earliest game that should be finished
            predictions.forEach(pred => {
                const gameTime = new Date(pred.gameTime);
                const gameDuration = getGameDuration(pred.sport);
                const estimatedEndTime = new Date(gameTime.getTime() + gameDuration * 60000);
                
                // Add 15 minute buffer after estimated end
                const checkTime = new Date(estimatedEndTime.getTime() + 15 * 60000);
                
                // Only consider games that should be done or finishing soon
                if (checkTime <= new Date(now.getTime() + 4 * 60 * 60000)) { // Within next 4 hours
                    if (!earliestCheck || checkTime < earliestCheck) {
                        earliestCheck = checkTime;
                    }
                }
            });
            
            return earliestCheck;
        }
        
        async function autoSettleCheck() {
            if (predictions.length === 0) {
                console.log('‚è∞ Auto-settle: No predictions to check');
                return;
            }
            
            const now = new Date();
            const nextCheckTime = getNextSettlementTime();
            
            if (!nextCheckTime) {
                console.log('‚è∞ Auto-settle: No games finishing soon');
                scheduleNextAutoSettle();
                return;
            }
            
            if (now < nextCheckTime) {
                const minutesUntil = Math.ceil((nextCheckTime - now) / 60000);
                console.log(`‚è∞ Auto-settle: Next check in ${minutesUntil} minutes (when games should be finished)`);
                scheduleNextAutoSettle();
                return;
            }
            
            console.log('ü§ñ Auto-settling completed games...');
            await settleBets(true); // Pass true for silent mode
            
            // Schedule next check after settling
            scheduleNextAutoSettle();
        }
        
        let autoSettleTimeout = null;
        function scheduleNextAutoSettle() {
            // Clear existing timeout
            if (autoSettleTimeout) clearTimeout(autoSettleTimeout);
            
            const nextCheckTime = getNextSettlementTime();
            if (!nextCheckTime) {
                // No games finishing soon, check again in 2 hours
                autoSettleTimeout = setTimeout(autoSettleCheck, 2 * 60 * 60000);
                console.log('‚è∞ No games finishing soon, will check again in 2 hours');
                return;
            }
            
            const now = new Date();
            const msUntilCheck = Math.max(60000, nextCheckTime - now); // At least 1 minute
            autoSettleTimeout = setTimeout(autoSettleCheck, msUntilCheck);
            
            const minutesUntil = Math.ceil(msUntilCheck / 60000);
            console.log(`‚è∞ Auto-settle scheduled for ${minutesUntil} minutes from now`);
        }
        
        // Initialize
        loadPredictions(); // Load saved predictions
        updateStats();
        displayPredictions(); // Display loaded predictions
        updateApiUsageDisplay(); // Show API usage
        updateStorageDisplay(); // Show storage usage
        initDarkMode(); // Initialize dark mode
        displayModelVersions(); // Show model snapshots
        
        // Check storage and cleanup if needed
        const storageUsage = getStorageUsage();
        if (storageUsage.percent > 80) {
            console.warn('‚ö†Ô∏è Storage usage high, running cleanup...');
            cleanupOldData();
            updateStorageDisplay();
        }
        
        // Request notification permission after 5 seconds
        setTimeout(() => {
            if (Notification.permission === 'default') {
                console.log('üí° Tip: Enable notifications for bet updates');
            }
        }, 5000);
        
        // Start smart auto-settlement system
        scheduleNextAutoSettle();
        
        // Display version info
        console.log('üöÄ AI Betting System v3.0 - Build: 2025-12-15 Enhanced');
        console.log('‚úÖ NEW: Storage Management, Export/Import, API Caching, Analytics, Dark Mode, Notifications');
        console.log('‚úÖ Features: Multi-bet types, AI Learning, CLV Tracking, Bet Sizing, Model Versioning');
        console.log(`üìä Loaded ${predictions.length} saved predictions`);
    </script>
    
    <!-- Version Footer -->
    <div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.7); font-size: 12px;">
        v3.0 ‚Ä¢ Build: Dec 15, 2025 ‚Ä¢ Enhanced: Analytics, Dark Mode, Export, Caching, Notifications
    </div>
</body>
</html>
