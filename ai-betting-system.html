<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Self-Learning AI Betting System v5.4 ULTRA - 24/7 Automatic Scheduling</title>
    <link rel="icon" type="image/svg+xml" href="icon.svg">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#6d28d9">
    <link rel="stylesheet" href="dist/tailwind.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root{
            --brand-500: #6d28d9;
            --brand-600: #5b21b6;
            --accent-500: #10b981;
            --muted-600: #6b7280;
            --glass-bg: rgba(255,255,255,0.7);
            --glass-bg-dark: rgba(20,20,30,0.7);
            --card-shadow: 0 12px 40px rgba(13, 14, 23, 0.08);
            --focus-outline: 3px solid rgba(99,102,241,0.18);
        }
        /* New card-focused visual styles */
        .prediction-card {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 18px;
            border-radius: 16px;
            box-shadow: 0 10px 30px rgba(13,14,23,0.12);
            transition: transform 0.18s ease, box-shadow 0.18s ease;
            overflow: hidden;
            position: relative;
        }
        /* Colorful gradient stripe and soft background */
        .prediction-card {
            background: linear-gradient(180deg, rgba(255,255,255,0.9), rgba(250,245,255,0.85));
        }
        .prediction-card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 8px;
            border-top-left-radius: 16px;
            border-bottom-left-radius: 16px;
            background: linear-gradient(180deg, #7c3aed, #06b6d4);
            opacity: 0.95;
        }
        .prediction-card:hover {
            transform: translateY(-6px);
            box-shadow: 0 18px 40px rgba(13,14,23,0.16);
        }
        .emoji-badge {
            width: 64px;
            height: 64px;
            border-radius: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        .btn-outline { background: transparent; color: #111827; border: 1px solid rgba(0,0,0,0.06); }
        /* small icon-only button */
        .icon-btn { width:44px; height:44px; padding:0; display:inline-flex; align-items:center; justify-content:center; border-radius:10px; }

        /* Ensure buttons inside cards contrast nicely */
        .prediction-card button { box-shadow: 0 8px 26px rgba(15, 23, 42, 0.08); }
        /* Glass card friendly background */
        .glass-card {
            background: linear-gradient(180deg, var(--glass-bg), rgba(255,255,255,0.6));
            backdrop-filter: blur(8px) saturate(140%);
            box-shadow: var(--card-shadow);
        }
        /* Auto badge improvements */
        #autoLearningBadge { padding-left: 10px; padding-right: 10px; }
        #autoLearningText { color: #064e3b; font-weight: 700; }
        #autoLearningDot { margin-left: 6px; }
    </style>

    <script>
    // ...existing code...
    // ...existing code...
    </script>
    <style>
            .progress-bar {
                transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            }
            .gradient-text {
                background: linear-gradient(90deg, #7f53ac, #657ced);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                background-clip: text;
                color: transparent;
            }
            .slide-in {
                animation: slideIn 0.7s cubic-bezier(0.4, 0, 0.2, 1);
            }
            @keyframes slideIn {
                from { opacity: 0; transform: translateY(30px); }
                to { opacity: 1; transform: translateY(0); }
            }
            .glow-pulse {
                animation: glowPulse 2s infinite alternate;
            }
            @keyframes glowPulse {
                from { box-shadow: 0 0 0 0 #a78bfa44; }
                to { box-shadow: 0 0 16px 8px #a78bfa44; }
            }
            .sport-btn.selected, .sport-btn:active {
                border-color: #a78bfa;
                background: #f3e8ff;
            }
            .dark-mode .sport-btn.selected, .dark-mode .sport-btn:active {
                background: #4c1d95;
                border-color: #a78bfa;
            }
            .card-stats {
                border-top: 3px solid #3b82f6;
            }
            @media (max-width: 640px) {
                .glass-card { padding: 1rem !important; }
            }
            /* The following CSS was outside of <style> and caused a parse error */
            button::after {
                content: '';
                position: absolute;
                left: 50%;
                width: 0;
                height: 0;
                border-radius: 50%;
                background: rgba(255, 255, 255, 0.3);
                transform: translate(-50%, -50%);
                transition: width 0.6s, height 0.6s;
            }
            button:active::after {
                width: 300px;
                height: 300px;
            }
        body.dark-mode {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            background-size: 200% 200%;
            animation: gradientShift 15s ease infinite;
        }
        body.dark-mode .glass-card {
            background: rgba(30, 30, 46, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        body.dark-mode h1, body.dark-mode h2, body.dark-mode h3 {
            color: #e0e0e0 !important;
        }
        body.dark-mode .text-gray-900 { color: #e0e0e0 !important; }
        body.dark-mode .text-gray-700 { color: #b0b0b0 !important; }
        body.dark-mode .text-gray-600 { color: #909090 !important; }
        body.dark-mode .text-gray-500 { color: #707070 !important; }
        body.dark-mode .bg-gray-100 { background-color: #2a2a3e !important; }
        body.dark-mode .bg-gray-200 { background-color: #3a3a4e !important; }
        body.dark-mode .border-gray-300 { border-color: #4a4a5e !important; }
        /* Mobile Optimization (Enhanced) */
        @media (max-width: 640px) {
            body { padding: 8px !important; }
            .max-w-7xl { padding: 0; }
            .glass-card { 
                padding: 16px !important; 
                margin-bottom: 12px !important;
                backdrop-filter: blur(12px) saturate(180%); /* Lighter blur for mobile performance */
            }
            /* Optimize animations for mobile performance */
            .glass-card:hover { transform: translateY(-2px); } /* Reduce transform on mobile */
            .float-animation { animation: none; } /* Disable floating on mobile */
            .glow-pulse { animation: none; box-shadow: 0 0 10px rgba(102, 126, 234, 0.3); } /* Static glow on mobile */
            body { animation: none; background-position: 0% 50%; } /* Static gradient on mobile */
            .shimmer { animation: none; } /* Disable shimmer on mobile for performance */
            /* Enhance touch feedback */
            button:active { transform: scale(0.97); }
            h1 { font-size: 1.5rem !important; line-height: 1.3 !important; }
            h2 { font-size: 1.125rem !important; line-height: 1.4 !important; }
            h3 { font-size: 1rem !important; }
            .sportsbook-table { overflow-x: auto; display: block; }
            .mobile-hide { display: none !important; }
            .mobile-stack { flex-direction: column !important; gap: 8px !important; }
            .mobile-full { width: 100% !important; }
            .mobile-text-sm { font-size: 0.875rem !important; }
            .mobile-compact { padding: 8px !important; margin: 4px 0 !important; }
            /* Touch-friendly buttons (Apple HIG 44x44 minimum) */
            button { 
                min-height: 48px; 
                min-width: 48px; 
                padding: 12px 16px; 
                font-size: 0.9375rem;
                -webkit-tap-highlight-color: rgba(102, 126, 234, 0.3);
            }
            .sport-btn { 
                padding: 16px 12px !important;
                -webkit-tap-highlight-color: rgba(139, 92, 246, 0.3);
            }
            /* Better touch feedback */
            button:active {
                background-color: rgba(102, 126, 234, 0.1);
                transform: scale(0.97);
            }
            /* Better grid layouts on mobile */
            .grid-cols-2 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; gap: 8px !important; }
            .grid-cols-3, .grid-cols-4, .grid-cols-5 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; gap: 8px !important; }
            .md\:grid-cols-3, .md\:grid-cols-4, .md\:grid-cols-8 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; gap: 8px !important; }
            .xl\:grid-cols-8 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; gap: 8px !important; }
            /* Improved stats cards */
            .stat-card { padding: 12px !important; }
            .text-2xl { font-size: 1.5rem !important; }
            .text-xl { font-size: 1.25rem !important; }
            .text-lg { font-size: 1.125rem !important; }
            /* Better spacing */
            .space-y-6 > * + * { margin-top: 12px !important; }
            .space-y-4 > * + * { margin-top: 8px !important; }
            .space-y-3 > * + * { margin-top: 6px !important; }
            /* Prediction cards on mobile */
            .prediction-card { padding: 12px !important; margin-bottom: 8px !important; }
            /* Better form inputs */
            input[type="range"] { height: 36px; }
            select { min-height: 44px; font-size: 16px; }
        }
        /* Tablet Optimization (Enhanced) */
        @media (min-width: 641px) and (max-width: 1024px) {
            body { padding: 16px !important; }
            .glass-card { 
                padding: 20px !important;
                backdrop-filter: blur(16px) saturate(180%); /* Medium blur for tablets */
            }
            /* Keep some animations on tablet but optimize */
            .glass-card:hover { transform: translateY(-3px) scale(1.005); }
            .float-animation { animation-duration: 4s; } /* Slower float on tablet */
            .tablet-compact { padding: 16px !important; }
            .grid-cols-3 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
            .grid-cols-4 { grid-template-columns: repeat(2, minmax(0, 1fr)) !important; gap: 12px !important; }
            .grid-cols-5 { grid-template-columns: repeat(3, minmax(0, 1fr)) !important; }
            .md\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)) !important; gap: 12px !important; }
            .xl\:grid-cols-8 { grid-template-columns: repeat(4, minmax(0, 1fr)) !important; gap: 12px !important; }
            h1 { font-size: 2rem !important; }
            h2 { font-size: 1.5rem !important; }
            button { min-height: 48px; padding: 12px 20px; }
            .sport-btn { padding: 20px 16px !important; }
            /* Better two-column layout */
            .tablet-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
        }
        /* Desktop Enhancements (Enhanced) */
        @media (min-width: 1025px) {
            body { padding: 32px !important; }
            .max-w-7xl { padding: 0 16px; }
            .glass-card { padding: 24px !important; }
            .desktop-grid { display: grid; grid-template-columns: 2fr 1fr; gap: 24px; }
            .desktop-three-col { display: grid; grid-template-columns: repeat(3, 1fr); gap: 24px; }
            .glass-card:hover { 
                transform: translateY(-4px); 
                box-shadow: 0 20px 60px 0 rgba(31, 38, 135, 0.5);
            }
            /* Better button hover states */
            button:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(0,0,0,0.15); }
            button:active { transform: translateY(0); }
            /* Enhanced grid layouts */
            .grid-cols-4 { gap: 16px !important; }
            .grid-cols-5 { gap: 16px !important; }
            .md\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)) !important; gap: 16px !important; }
            .lg\:grid-cols-4 { grid-template-columns: repeat(4, minmax(0, 1fr)) !important; gap: 16px !important; }
            .xl\:grid-cols-8 { grid-template-columns: repeat(4, minmax(0, 1fr)) !important; gap: 16px !important; }
            /* Better typography */
            h1 { font-size: 2.25rem !important; }
            h2 { font-size: 1.75rem !important; }
            /* Improved stats display */
            .stat-card { padding: 20px !important; }
            .text-2xl { font-size: 1.875rem !important; }
            /* Better prediction cards */
            .prediction-card { padding: 20px !important; }
            /* Sidebar layout for analytics */
            .desktop-sidebar-layout { display: grid; grid-template-columns: 1fr 350px; gap: 24px; }
        }
        /* Extra Large Desktop (1280px+) - Full 8-sport grid */
        @media (min-width: 1280px) {
            .xl\:grid-cols-8 { grid-template-columns: repeat(8, minmax(0, 1fr)) !important; gap: 16px !important; }
        }
        /* Large Desktop (1440px+) */
        @media (min-width: 1440px) {
            .max-w-7xl { max-width: 1400px; }
            .glass-card { padding: 32px !important; }
            h1 { font-size: 2.5rem !important; }
            h2 { font-size: 2rem !important; }
            .desktop-grid { gap: 32px; }
            .xl\:grid-cols-8 { gap: 20px !important; }
        }
        /* Responsive Utilities */
        .mobile-only { display: block; }
        .tablet-only { display: none; }
        .desktop-only { display: none; }
        @media (min-width: 641px) and (max-width: 1024px) {
            .mobile-only { display: none; }
            .tablet-only { display: block; }
            .desktop-only { display: none; }
        }
        @media (min-width: 1025px) {
            .mobile-only { display: none; }
            .tablet-only { display: none; }
            .desktop-only { display: block; }
        }
        /* Smooth transitions for all interactive elements */
        button, .glass-card, input, select {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        /* Better focus states for accessibility */
        button:focus, input:focus, select:focus {
            outline: 2px solid #667eea;
            outline-offset: 2px;
        }
        /* Loading states */
        .loading { opacity: 0.6; pointer-events: none; cursor: wait; }
        .loading::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 20px; height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid #667eea;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spinner 0.6s linear infinite;
        }
        @keyframes spinner {
            to { transform: rotate(360deg); }
        }
        /* Reduced Motion for Accessibility & Battery Saving */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
            body { animation: none; background-position: 0% 50%; }
            .glass-card:hover { transform: none; }
            .float-animation { animation: none; }
            .glow-pulse { animation: none; }
        }
        /* Print Optimization */
        @media print {
            body { background: white; }
            .glass-card { box-shadow: none; border: 1px solid #ddd; page-break-inside: avoid; }
            button, .mobile-hide, #darkModeBtn, #notifBtn { display: none !important; }
            h1, h2 { color: black !important; }
        }
    </style>
</head>
<body class="p-4 sm:p-6 md:p-8 lg:p-8">
    <div class="max-w-7xl mx-auto space-y-4 md:space-y-6">
        
        <!-- Header -->
        <div class="glass-card p-4 md:p-6 glow-pulse" style="border-top: 3px solid; border-image: linear-gradient(90deg, #667eea, #764ba2, #667eea) 1;">
            <div class="flex flex-col md:flex-row items-center justify-between gap-4">
                <div class="text-center md:text-left flex-1">
                    <h1 class="text-xl sm:text-2xl md:text-3xl font-bold text-gray-900">
                        <span class="inline-block float-animation">ü§ñ</span> Self-Learning AI Betting System
                    </h1>
                    <p class="text-xs sm:text-sm md:text-base text-gray-600 mt-1 leading-relaxed">24/7 Auto-Scheduling + 5 AI Improvements <span class="text-xs text-purple-600 font-mono font-bold">v5.4 ULTRA</span></p>
                    <p class="text-xs text-gray-500 mt-2 hidden sm:block">üß† Loss Avoidance ¬∑ ‚òÅÔ∏è Weather Learning ¬∑ üéØ API-Sports Multi-Sport AI ¬∑ üìä A/B Testing ¬∑ üèàüèÄ‚öæüèí‚öΩ 5 Sports</p>
                </div>
                <div class="text-center md:text-right bg-gradient-to-br from-green-50 to-blue-50 dark:from-green-900 dark:to-blue-900 p-4 rounded-lg min-w-[180px]">
                    <div class="text-xs text-gray-500 dark:text-gray-400 uppercase tracking-wide">AI Status</div>
                    <div class="text-xl font-bold text-green-600 dark:text-green-400 my-1">‚óè Learning</div>
                    <div class="inline-block mt-1 px-2 py-0.5 bg-green-100 dark:bg-green-800 text-green-800 dark:text-green-200 text-xs font-semibold rounded-full animate-pulse">
                        ü§ñ Auto-Learning ON
                    </div>
                    <div class="text-xs text-gray-600 dark:text-gray-300 mt-2 space-y-1">
                        <div><strong>API:</strong> <span id="apiUsage">0/500</span></div>
                        <div><strong>Storage:</strong> <span id="storageUsage">0%</span></div>
                    </div>

                    <!-- Quick Composer removed: All predictions are auto-generated and auto-logged -->

                    <div class="mt-3 grid grid-cols-3 gap-2">
                        <button onclick="toggleDarkMode()" class="text-xs md:text-sm px-4 py-2 bg-gray-200 dark:bg-gray-700 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition-all w-full font-semibold" id="darkModeBtn">üåô Dark Mode</button>
                        <button onclick="downloadDesktopShortcut()" class="text-xs md:text-sm px-4 py-2 bg-blue-600 text-white rounded-lg hover:opacity-95 transition-all w-full font-semibold">üîó Shortcut</button>
                        <button id="installBtn" onclick="installPWA()" class="text-xs md:text-sm px-4 py-2 bg-green-600 text-white rounded-lg hover:opacity-95 transition-all w-full font-semibold" style="display:none">‚¨áÔ∏è Install</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- API Usage Tips Banner -->
        <div class="glass-card p-4 bg-gradient-to-r from-blue-50 to-purple-50 dark:from-blue-900 dark:to-purple-900 border-l-4 border-blue-500" id="apiTipsBanner">
            <div class="flex items-start justify-between">
                <div class="flex-1">
                    <div class="flex items-center gap-2 mb-2">
                        <span class="text-lg">üí°</span>
                        <span class="font-bold text-gray-900 dark:text-gray-100 text-sm sm:text-base">Automated Daily Schedule (500 calls/month)</span>
                    </div>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-2 text-xs sm:text-sm text-gray-700 dark:text-gray-300">
                        <div class="flex items-center gap-1">
                            <span class="text-green-600 dark:text-green-400">‚úì</span>
                            <span><strong>6am CT:</strong> Daily analysis (8 sports = ~240 calls/month)</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-green-600 dark:text-green-400">‚úì</span>
                            <span><strong>11pm CT:</strong> Auto-settlement + Learning</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-purple-600 dark:text-purple-400">ü§ñ</span>
                            <span><strong>AI learns automatically</strong> after settlement</span>
                        </div>
                        <div class="flex items-center gap-1">
                            <span class="text-blue-600 dark:text-blue-400">üìä</span>
                            <span><strong>16 calls/day = ~480/month</strong> (optimized usage)</span>
                        </div>
                    </div>
                </div>
                <button onclick="document.getElementById('apiTipsBanner').style.display='none'" class="text-gray-400 hover:text-gray-600 ml-2 text-xl leading-none">&times;</button>
            </div>
        </div>

        <!-- AI Stats Dashboard -->
        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-3 md:gap-4">
            <div class="glass-card p-4 slide-in hover:shadow-xl card-stats" style="border-top: 3px solid #3b82f6;">
                <div class="text-xs sm:text-sm text-gray-500 dark:text-gray-400 flex justify-between items-center mb-2">
                    <span class="font-medium">Total Bets Analyzed</span>
                    <span class="text-xs" id="trendIndicator"></span>
                </div>
                <div class="text-3xl md:text-2xl lg:text-3xl font-bold text-gray-900 dark:text-gray-100" id="totalBets">0</div>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mt-3">
                    <div class="bg-gradient-to-r from-blue-500 to-purple-600 h-2.5 rounded-full progress-bar" id="totalBetsProgress" style="width: 0%"></div>
                </div>
                <div class="text-xs text-gray-400 dark:text-gray-500 mt-2">Lifetime learning</div>
            </div>
            <div class="glass-card p-4 slide-in hover:shadow-xl">
                <div class="text-xs sm:text-sm text-gray-500 dark:text-gray-400 flex justify-between items-center mb-2">
                    <span class="font-medium">Win Rate</span>
                    <span class="text-xs font-bold" id="winRateTrend"></span>
                </div>
                <div class="text-3xl md:text-2xl lg:text-3xl font-bold text-green-600 dark:text-green-400" id="winRate">0%</div>
                <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mt-3">
                    <div class="bg-gradient-to-r from-green-400 to-emerald-600 h-2.5 rounded-full progress-bar" id="winRateProgress" style="width: 0%"></div>
                </div>
                <div class="text-xs mt-2" id="winRateSubtext">AI accuracy</div>
            </div>
            <div class="glass-card p-4 slide-in hover:shadow-xl">
                <div class="text-xs sm:text-sm text-gray-500 dark:text-gray-400 mb-2 font-medium">Best Bet Type</div>
                <div class="text-lg sm:text-xl font-bold text-purple-600 gradient-text truncate" id="confidence">Learning...</div>
                <div class="text-xs text-gray-400 dark:text-gray-500 mt-1">Top performer</div>
                <div class="text-xs font-semibold mt-2" id="recentStreak"></div>
            </div>
            <div class="glass-card p-4 slide-in hover:shadow-xl">
                <div class="text-xs sm:text-sm text-gray-500 dark:text-gray-400 mb-2 font-medium">Learning Cycles</div>
                <div class="text-3xl md:text-2xl lg:text-3xl font-bold text-blue-600 dark:text-blue-400" id="cycles">0</div>
                <div class="text-xs text-gray-400 dark:text-gray-500 mt-1">Training iterations</div>
                <div class="text-xs font-semibold mt-2 text-purple-600 dark:text-purple-400" id="momentum"></div>
            </div>
        </div>

        <!-- Sport Selection -->
        <div class="glass-card p-4 md:p-6">
            <h2 class="text-base sm:text-lg md:text-xl font-bold text-gray-900 dark:text-gray-100 mb-4">üèÜ Select Sport</h2>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-4 xl:grid-cols-8 gap-3 md:gap-4">
                <button onclick="selectSport('americanfootball_nfl', 'NFL')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">üèà</div>
                    <div class="font-semibold text-sm md:text-base">NFL</div>
                </button>
                <button onclick="selectSport('basketball_nba', 'NBA')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">üèÄ</div>
                    <div class="font-semibold text-sm md:text-base">NBA</div>
                </button>
                <button onclick="selectSport('icehockey_nhl', 'NHL')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">üèí</div>
                    <div class="font-semibold text-sm md:text-base">NHL</div>
                </button>
                <button onclick="selectSport('baseball_mlb', 'MLB')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">‚öæ</div>
                    <div class="font-semibold text-sm md:text-base">MLB</div>
                </button>
                <button onclick="selectSport('americanfootball_ncaaf', 'NCAAF')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">üéì</div>
                    <div class="font-semibold text-sm md:text-base">NCAAF</div>
                </button>
                <button onclick="selectSport('soccer_epl', 'EPL')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">‚öΩ</div>
                    <div class="font-semibold text-sm md:text-base">EPL</div>
                </button>
                <button onclick="selectSport('soccer_usa_mls', 'MLS')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">‚öΩ</div>
                    <div class="font-semibold text-sm md:text-base">MLS</div>
                </button>
                <button onclick="selectSport('soccer_uefa_champs_league', 'UCL')" class="sport-btn p-5 border-2 border-gray-300 dark:border-gray-600 rounded-xl hover:border-purple-500 hover:bg-purple-50 dark:hover:bg-purple-900 transition-all shadow-sm hover:shadow-md active:scale-95">
                    <div class="text-3xl md:text-2xl mb-2">‚öΩ</div>
                    <div class="font-semibold text-sm md:text-base">UCL</div>
                </button>
            </div>
            <div class="mt-4 p-3 bg-purple-50 dark:bg-purple-900 rounded-lg text-center">
                <span class="text-xs sm:text-sm text-gray-600 dark:text-gray-300">Selected: </span>
                <span class="font-bold text-base sm:text-lg text-purple-600 dark:text-purple-400" id="selectedSport">None</span>
            </div>
        </div>

        <!-- Confidence Filter & Data Management -->
        <div class="glass-card p-4 md:p-5">
            <div class="flex flex-col md:flex-row items-stretch md:items-center justify-between gap-4">
                <div class="flex-1 w-full">
                    <label class="text-sm sm:text-base font-semibold text-gray-700 dark:text-gray-300">üéØ Min Confidence Filter: <span id="minConfidenceValue" class="text-purple-600 dark:text-purple-400">0%</span></label>
                    <input type="range" id="minConfidenceSlider" min="0" max="95" value="0" step="5" class="w-full mt-3 h-2" oninput="updateConfidenceFilter(this.value)">
                    <div class="flex justify-between text-xs sm:text-sm text-gray-400 dark:text-gray-500 mt-2">
                        <span>All Bets</span>
                        <span>50%</span>
                        <span>Elite (95%)</span>
                    </div>
                </div>
                <div class="flex flex-wrap gap-2 justify-center md:justify-end">
                    <button onclick="exportData()" class="px-4 py-2.5 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-all shadow hover:shadow-md active:scale-95 text-sm font-semibold min-h-[44px]">üì• Export</button>
                    <button onclick="importData()" class="px-4 py-2.5 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-all shadow hover:shadow-md active:scale-95 text-sm font-semibold min-h-[44px]">üì§ Import</button>
                    <button onclick="requestNotificationPermission()" class="px-4 py-2.5 bg-orange-500 text-white rounded-lg hover:bg-orange-600 transition-all shadow hover:shadow-md active:scale-95 text-sm font-semibold min-h-[44px]" id="notifBtn">üîî Notify</button>
                </div>
            </div>
        </div>

        <!-- AI Control Panel -->
        <div class="glass-card p-4 md:p-6">
            <h2 class="text-base sm:text-lg md:text-xl font-bold text-gray-900 dark:text-gray-100 mb-4">üß† AI Control Panel</h2>
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 md:gap-4">
                <button id="analyzeBtn" onclick="analyzeGames()" style="background: linear-gradient(90deg, var(--brand-500), var(--brand-600));" class="text-white font-bold py-4 md:py-5 px-4 md:px-6 rounded-xl hover:opacity-95 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed active:scale-95 min-h-[72px] md:min-h-[80px] relative overflow-hidden group">
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-200%] group-hover:translate-x-[200%] transition-transform duration-1000"></div>
                    <div class="relative text-base md:text-lg mb-1">üîç Analyze Games</div>
                    <div class="relative text-xs opacity-90">Find value bets with AI</div>
                </button>
                <button id="settleBtn" onclick="settleBets()" style="background: linear-gradient(90deg, var(--accent-500), #059669);" class="text-white font-bold py-4 md:py-5 px-4 md:px-6 rounded-xl hover:opacity-95 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed active:scale-95 min-h-[72px] md:min-h-[80px] relative overflow-hidden group">
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-200%] group-hover:translate-x-[200%] transition-transform duration-1000"></div>
                    <div class="relative text-base md:text-lg mb-1">‚úÖ Settle Results</div>
                    <div class="relative text-xs opacity-90">Get real game outcomes</div>
                </button>
                <button id="forceSettleBtn" onclick="settleBets(true)" style="background: linear-gradient(90deg, #ef4444, #f97316);" class="text-white font-bold py-4 md:py-5 px-4 md:px-6 rounded-xl hover:opacity-95 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed active:scale-95 min-h-[72px] md:min-h-[80px] relative overflow-hidden group ml-2">
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-200%] group-hover:translate-x-[200%] transition-transform duration-1000"></div>
                    <div class="relative text-base md:text-lg mb-1">üõ†Ô∏è Force Settle</div>
                    <div class="relative text-xs opacity-90">Force update all results</div>
                </button>
                <button id="learnBtn" onclick="runLearningCycle()" style="background: linear-gradient(90deg, #f97316, #ef4444);" class="text-white font-bold py-4 md:py-5 px-4 md:px-6 rounded-xl hover:opacity-95 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed active:scale-95 min-h-[72px] md:min-h-[80px] relative overflow-hidden group">
                    <div class="absolute inset-0 bg-gradient-to-r from-transparent via-white/20 to-transparent translate-x-[-200%] group-hover:translate-x-[200%] transition-transform duration-1000"></div>
                    <div class="text-base md:text-lg mb-1">üéì Extra Learning</div>
                    <div class="text-xs opacity-90">Auto-learns after settlement</div>
                </button>
            </div>
            <div class="mt-4 flex justify-center">
                <div class="flex gap-2">
                    <button onclick="clearAllBets()" class="bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700 text-white font-semibold py-2.5 px-6 rounded-lg text-sm md:text-base transition-all shadow hover:shadow-md active:scale-95">
                        üóëÔ∏è Clear All Bets
                    </button>
                    <button id="autoModeBtn" onclick="toggleAutoMode()" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2.5 px-4 rounded-lg text-sm md:text-base transition-all shadow hover:shadow-md active:scale-95">
                        ‚öôÔ∏è AutoMode
                    </button>
                </div>
            </div>
            <div class="mt-3 text-sm text-gray-700 dark:text-gray-300">
                <label class="block mb-1 font-semibold">üîß Learning Rate: <span id="lrValue">6%</span></label>
                <input type="range" id="learningRateSlider" min="1" max="20" value="6" step="1" oninput="setLearningRate(this.value)" class="w-full">
                <label class="block mt-2 mb-1 font-semibold">üíé Diamond Threshold: <span id="diamondValue">95%</span></label>
                <input type="range" id="diamondThresholdSlider" min="80" max="99" value="95" step="1" oninput="setDiamondThreshold(this.value)" class="w-full">
            </div>
        </div>

        <!-- Settlement Log -->
        <div id="settlementLog" class="glass-card p-6 hidden">
            <h2 class="text-xl font-bold text-gray-900 mb-4">üìã Settlement Log</h2>
            <div id="logContent" class="space-y-1 text-sm font-mono max-h-96 overflow-y-auto bg-gray-900 p-4 rounded-lg"></div>
        </div>

        <!-- AI Predictions -->
        <div class="glass-card p-4 md:p-6">
            <div class="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-3 mb-4">
                <h2 class="text-lg md:text-xl font-bold text-gray-900 dark:text-gray-100">üéØ AI Predictions</h2>
                <div id="autoLearningBadge" class="inline-flex items-center gap-2 px-3 py-1.5 bg-gradient-to-r from-green-100 to-blue-100 dark:from-green-900 dark:to-blue-900 rounded-full border border-green-300 dark:border-green-700">
                    <span id="autoLearningText" class="text-xs sm:text-sm font-semibold text-gray-700 dark:text-gray-300">ü§ñ Auto-Learning Active</span>
                    <span id="autoLearningDot" class="relative flex h-2 w-2">
                        <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-green-400 opacity-75"></span>
                        <span class="relative inline-flex rounded-full h-2 w-2 bg-green-500"></span>
                    </span>
                </div>
            </div>
            <div id="predictions" class="space-y-3">
                <div class="text-center text-gray-400 dark:text-gray-500 py-8">
                    <div class="text-base sm:text-lg mb-2">Click "Analyze Games" to start AI analysis</div>
                    <div class="text-xs sm:text-sm">AI will automatically learn from results at 11pm CT</div>
                </div>
            </div>
        </div>

        <!-- Bankroll Tracker -->
        <div class="glass-card p-4 md:p-6" id="bankrollWidget">
            <h2 class="text-base sm:text-lg md:text-xl font-bold text-gray-900 dark:text-gray-100 mb-4">üí∞ Bankroll Management</h2>
            <div class="grid grid-cols-2 lg:grid-cols-4 gap-3 md:gap-4">
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-green-50 to-green-100 dark:from-green-900 dark:to-green-800 rounded-xl shadow-sm hover:shadow-md transition-all">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-300 font-medium mb-1">Current Bankroll</div>
                    <div class="text-xl sm:text-2xl md:text-3xl font-bold text-green-600 dark:text-green-400" id="currentBankroll">$10,000</div>
                </div>
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900 dark:to-blue-800 rounded-xl shadow-sm hover:shadow-md transition-all">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-300 font-medium mb-1">Total P&L</div>
                    <div class="text-xl sm:text-2xl md:text-3xl font-bold text-blue-600 dark:text-blue-400" id="totalPnL">$0.00</div>
                </div>
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-900 dark:to-purple-800 rounded-xl shadow-sm hover:shadow-md transition-all">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-300 font-medium mb-1">ROI</div>
                    <div class="text-xl sm:text-2xl md:text-3xl font-bold text-purple-600 dark:text-purple-400" id="roiPercent">0.0%</div>
                </div>
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-orange-50 to-orange-100 dark:from-orange-900 dark:to-orange-800 rounded-xl shadow-sm hover:shadow-md transition-all">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-300 font-medium mb-1">Max Drawdown</div>
                    <div class="text-xl sm:text-2xl md:text-3xl font-bold text-orange-600 dark:text-orange-400" id="maxDrawdown">0.0%</div>
                </div>
            </div>
            <div id="stopLossAlert" style="display: none;" class="mt-4 p-3 md:p-4 bg-gradient-to-r from-red-100 to-red-50 dark:from-red-900 dark:to-red-800 border-l-4 border-red-500 text-red-700 dark:text-red-300 rounded-lg text-sm md:text-base shadow-md">
                <strong>üõë STOP LOSS TRIGGERED</strong> - Bankroll has dropped 20% from peak. Review strategy before continuing.
            </div>
        </div>

        <!-- Learning Insights -->
        <div class="glass-card p-4 md:p-6">
            <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-4 gap-3">
                <h2 class="text-base sm:text-lg md:text-xl font-bold text-gray-900 dark:text-gray-100">üìä AI Learning Insights</h2>
                <div class="flex items-center gap-2">
                    <button onclick="createModelSnapshot()" id="snapshotBtn" style="background: linear-gradient(90deg, var(--brand-500), var(--brand-600));" class="px-4 py-2 text-white rounded-lg hover:opacity-95 transition-all shadow hover:shadow-md text-xs sm:text-sm font-semibold active:scale-95">üíæ Save Snapshot</button>
                    <button id="viewBriefingsBtn" onclick="renderDailyBriefings()" style="background: linear-gradient(90deg, #047857, #065f46);" class="px-4 py-2 text-white rounded-lg hover:opacity-95 transition-all shadow hover:shadow-md text-xs sm:text-sm font-semibold active:scale-95">üìÖ View Daily Briefings</button>
                </div>
            </div>
            <div id="insights" class="space-y-4">
                <div id="insightsContent"></div>
                <script>
                // --- SETTLE BETS FUNCTION (moved from <style> block) ---
                async function settleBets(silentMode = false) {
                    if (predictions.length === 0) {
                        if (!silentMode) alert('No predictions to settle. Analyze games first!');
                        return;
                    }
                    // Warn about manual settlement (suggest auto-settle)
                    if (!silentMode) {
                        // Non-blocking info: manual settlement will proceed but AutoMode is recommended.
                        showNotification(`üí° Manual Settlement will run now. Recommended: let AutoMode handle settlements to save API calls. Current API Usage: ${getApiUsage().count}/500`, 'info');
                    }
                    // Show settlement log
                    const logDiv = document.getElementById('settlementLog');
                    const logContent = document.getElementById('logContent');
                    if (!silentMode) {
                        logDiv.classList.remove('hidden');
                        logContent.innerHTML = '';
                    }
                    function addLog(message, type = 'info') {
                        const colors = {
                            info: 'text-blue-600',
                            success: 'text-green-600',
                            warning: 'text-orange-600',
                            error: 'text-red-600',
                            header: 'font-bold text-purple-600'
                        };
                        if (!silentMode && logContent) {
                            const log = document.createElement('div');
                            log.className = `font-mono text-xs mb-1 ${colors[type] || ''}`;
                            log.textContent = message;
                            logContent.appendChild(log);
                            logContent.scrollTop = logContent.scrollHeight;
                        }
                        console.log(message);
                    }
                    // --- Settlement Logic ---
                    try {
                        addLog('üîç Starting settlement process...', 'header');
                        // For each unsettled prediction, get result from Odds API
                        const unsettled = predictions.filter(p => !p.settled);
                        if (unsettled.length === 0) {
                            addLog('‚úÖ All bets settled!', 'success');
                            if (!silentMode) showNotification('‚úÖ All bets settled!', 'success');
                            if (!silentMode) {
                                const btn = document.getElementById('settleBtn');
                                if (btn) {
                                    btn.disabled = false;
                                    btn.innerHTML = '<div class="text-lg">‚úÖ Settle Results</div><div class="text-xs opacity-90">Get real game outcomes</div>';
                                }
                            }
                            return;
                        }
                        // Map human-readable sport names to Odds API sport keys
                        const oddsSportMap = {
                            'NFL': 'americanfootball_nfl',
                            'NBA': 'basketball_nba',
                            'NHL': 'icehockey_nhl',
                            'MLB': 'baseball_mlb',
                            'NCAAF': 'americanfootball_ncaaf',
                            'EPL': 'soccer_epl',
                            'MLS': 'soccer_usa_mls',
                            'UCL': 'soccer_uefa_champs_league'
                        };
                        // Group by Odds API sport key for efficient API calls
                        const sportsToCheck = [...new Set(unsettled.map(p => {
                            const name = p.sport || p.sportKey || '';
                            return oddsSportMap[name] || name;
                        }))];
                        for (const sportKey of sportsToCheck) {
                            const sportPreds = unsettled.filter(p => {
                                const name = p.sport || p.sportKey || '';
                                return (oddsSportMap[name] || name) === sportKey;
                            });
                            if (sportPreds.length === 0) continue;
                            // Try to get results for this sport
                            const activeKey = getActiveApiKey();
                            // Try both /scores and /odds endpoints for robustness
                            const urls = [
                                `https://api.the-odds-api.com/v4/sports/${sportKey}/scores?apiKey=${activeKey.key}&daysFrom=3`,
                                `https://api.the-odds-api.com/v4/sports/${sportKey}/odds?apiKey=${activeKey.key}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`
                            ];
                            let results = [];
                            for (const url of urls) {
                                let res = apiCache.get(url);
                                if (!res) {
                                    const response = await fetch(url);
                                    trackApiCall();
                                    if (!response.ok) continue;
                                    res = await response.json();
                                    apiCache.set(url, res, 30);
                                }
                                if (Array.isArray(res)) results = results.concat(res);
                            }
                            for (const pred of sportPreds) {
                                if (pred.settled) continue;
                                // Try to match by game id, fallback to fuzzy team/date match
                                let result = results.find(r => r.id === pred.gameId);
                                if (!result) {
                                    // Fuzzy match: both teams and date (case-insensitive, partial match)
                                    result = results.find(r => {
                                        const rDate = new Date(r.commence_time);
                                        const pDate = new Date(pred.gameTime);
                                        const sameDay = rDate.toDateString() === pDate.toDateString();
                                        const homeMatch = r.home_team && pred.game && pred.game.toLowerCase().includes(r.home_team.toLowerCase());
                                        const awayMatch = r.away_team && pred.game && pred.game.toLowerCase().includes(r.away_team.toLowerCase());
                                        return sameDay && homeMatch && awayMatch;
                                    });
                                }
                                if (result && (result.completed || result.scores)) {
                                    // Settle bet
                                    const homeScore = result.scores?.find(s => s.name === 'home')?.score ?? null;
                                    const awayScore = result.scores?.find(s => s.name === 'away')?.score ?? null;
                                    pred.settled = true;
                                    pred.won = ai.settlePrediction(pred, result, homeScore, awayScore);
                                    pred.settledAt = Date.now();
                                    savePredictions();
                                    showSettlementNotification(pred, pred.won, result, homeScore, awayScore, 'Auto-settled');
                                }
                            }
                        }
                        addLog('‚úÖ Settlement process complete.', 'success');
                        if (!silentMode) showNotification('‚úÖ Settlement process complete.', 'success');
                        // Immediately run a learning cycle so AI incorporates newly settled bets
                        try {
                            setTimeout(() => {
                                runLearningCycle && runLearningCycle();
                                updateStats && updateStats();
                                createModelSnapshot && createModelSnapshot();
                                savePredictions && savePredictions();
                            }, 500);
                        } catch (e) {
                            console.warn('Auto-learning after settlement failed:', e);
                        }
                    } catch (err) {
                        addLog('‚ùå Error during settlement: ' + err.message, 'error');
                        if (!silentMode) showNotification('‚ùå Error during settlement', 'error');
                    }
                    if (!silentMode) {
                        const btn = document.getElementById('settleBtn');
                        if (btn) {
                            btn.disabled = false;
                            btn.innerHTML = '<div class="text-lg">‚úÖ Settle Results</div><div class="text-xs opacity-90">Get real game outcomes</div>';
                        }
                    }
                }
                function renderInsights() {
                    const insightsDiv = document.getElementById('insightsContent');
                    if (!window.ai || !ai.model) {
                        insightsDiv.innerHTML = '<div class="text-center text-gray-400 dark:text-gray-500 py-8">ü§ñ AI insights will appear after learning cycles</div>';
                        return;
                    }
                    const m = ai.model;
                    let html = '';
                    html += `<div class='mb-2'><b>Learning Cycles:</b> ${m.learningCycles || 0}</div>`;
                    html += `<div class='mb-2'><b>Total Bets:</b> ${m.totalBets || 0} | <b>Wins:</b> ${m.wins || 0} | <b>Losses:</b> ${m.losses || 0} | <b>Win Rate:</b> ${m.totalBets ? ((m.wins/m.totalBets)*100).toFixed(1) : 0}%</div>`;
                    if (m.recentTrend) {
                        html += `<div class='mb-2'><b>Current Streak:</b> ${m.recentTrend.currentStreak || 0} (${m.recentTrend.streakType || ''})</div>`;
                    }
                    // Top Money Maker Teams
                    if (m.moneyMakerPatterns && m.moneyMakerPatterns.teams) {
                        const mmTeams = Object.entries(m.moneyMakerPatterns.teams)
                            .filter(([team, data]) => data.total >= 5 && data.winRate > 0.6)
                            .sort((a, b) => b[1].winRate - a[1].winRate)
                            .slice(0, 5);
                        if (mmTeams.length) {
                            html += `<div class='mb-2'><b>Top Money Maker Teams:</b><ul class='ml-4 list-disc'>`;
                            mmTeams.forEach(([team, data]) => {
                                html += `<li>${team}: ${data.winRate ? (data.winRate*100).toFixed(1) : 0}% WR (${data.total} bets)</li>`;
                            });
                            html += '</ul></div>';
                        }
                    }
                    // Best Bet Types
                    if (m.betTypePerformance) {
                        const bestTypes = Object.entries(m.betTypePerformance)
                            .filter(([type, data]) => data.total >= 5 && data.wins/data.total > 0.6)
                            .sort((a, b) => (b[1].wins/b[1].total) - (a[1].wins/a[1].total))
                            .slice(0, 3);
                        if (bestTypes.length) {
                            html += `<div class='mb-2'><b>Best Bet Types:</b><ul class='ml-4 list-disc'>`;
                            bestTypes.forEach(([type, data]) => {
                                html += `<li>${type}: ${((data.wins/data.total)*100).toFixed(1)}% WR (${data.total} bets)</li>`;
                            });
                            html += '</ul></div>';
                        }
                    }
                    // Patterns to Avoid
                    if (m.losingPatterns && m.losingPatterns.teams) {
                        const avoidTeams = Object.entries(m.losingPatterns.teams)
                            .filter(([team, data]) => data.total >= 5 && data.losses/data.total > 0.6)
                            .sort((a, b) => (b[1].losses/b[1].total) - (a[1].losses/a[1].total))
                            .slice(0, 3);
                        if (avoidTeams.length) {
                            html += `<div class='mb-2'><b>Teams to Avoid:</b><ul class='ml-4 list-disc'>`;
                            avoidTeams.forEach(([team, data]) => {
                                html += `<li>${team}: ${((data.losses/data.total)*100).toFixed(1)}% Loss Rate (${data.total} bets)</li>`;
                            });
                            html += '</ul></div>';
                        }
                    }
                    // CLV Insights
                    if (m.advancedMetrics && m.advancedMetrics.clvTracking) {
                        const clv = m.advancedMetrics.clvTracking;
                        if (clv.history && clv.history.length) {
                            const avgCLV = (clv.history.reduce((sum, h) => sum + h.clv, 0) / clv.history.length).toFixed(2);
                            html += `<div class='mb-2'><b>Avg CLV (last 50):</b> ${avgCLV}%</div>`;
                        }
                    }
                    insightsDiv.innerHTML = html;
                }
                // Render on load and after learning
                setTimeout(renderInsights, 1000);
                if (window.ai) {
                    const oldLearn = ai.runLearningCycle;
                    ai.runLearningCycle = function() { const r = oldLearn.apply(this, arguments); setTimeout(renderInsights, 1000); return r; };
                }
                </script>
            </div>
        </div>

        <!-- Performance Analytics -->
        <div class="glass-card p-4 md:p-6">
            <h2 class="text-base sm:text-lg md:text-xl font-bold text-gray-900 dark:text-gray-100 mb-4">üìà Performance Analytics</h2>
            <div class="bg-white dark:bg-gray-800 p-2 rounded-lg">
                <canvas id="performanceChart" height="80"></canvas>
            </div>
            <div class="grid grid-cols-3 gap-3 md:gap-4 mt-4">
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-green-50 to-green-100 dark:from-green-900 dark:to-green-800 rounded-xl shadow-sm">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-400 font-medium mb-1">7-Day WR</div>
                    <div class="text-lg sm:text-xl md:text-2xl font-bold text-green-600 dark:text-green-400" id="weekWinRate">-</div>
                </div>
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-blue-50 to-blue-100 dark:from-blue-900 dark:to-blue-800 rounded-xl shadow-sm">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-400 font-medium mb-1">ROI (Units)</div>
                    <div class="text-lg sm:text-xl md:text-2xl font-bold text-blue-600 dark:text-blue-400" id="roiUnits">-</div>
                </div>
                <div class="text-center p-3 md:p-4 bg-gradient-to-br from-purple-50 to-purple-100 dark:from-purple-900 dark:to-purple-800 rounded-xl shadow-sm">
                    <div class="text-xs sm:text-sm text-gray-600 dark:text-gray-400 font-medium mb-1">Streak</div>
                    <div class="text-lg sm:text-xl md:text-2xl font-bold text-purple-600 dark:text-purple-400" id="currentStreakDisplay">-</div>
                </div>
            </div>
        </div>

        <!-- Model Versions -->
        <div class="glass-card p-4" id="modelVersions" style="display: none;">
            <h3 class="text-sm font-bold text-gray-700 dark:text-gray-300 mb-2">üîÑ Model Snapshots</h3>
            <div id="versionsList" class="space-y-2 text-xs"></div>
        </div>

    </div>

    <!-- Load API configuration (generated during deployment) -->
    <script src="config.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Configuration - Load from secure config file
        // API keys are injected during deployment via GitHub Actions
        const ODDS_API_KEYS = window.APP_CONFIG?.ODDS_API_KEYS || [
            // Fallback for local development (use a test key or mock data)
            { key: 'REPLACE_WITH_LOCAL_DEV_KEY', limit: 500, name: 'Dev', type: 'odds' }
        ];

        // Verify API key is loaded
        if (!ODDS_API_KEYS[0] || ODDS_API_KEYS[0].key.includes('__') || ODDS_API_KEYS[0].key === 'REPLACE_WITH_LOCAL_DEV_KEY') {
            console.warn('‚ö†Ô∏è API key not properly configured. Some features may not work.');
            console.warn('For production: Ensure ODDS_API_KEY is set in GitHub Secrets');
            console.warn('For local dev: Create config.js from config.template.js with your dev key');
        }
        
        // Weather API (free, no limit) remains available for weather data.
        
        let currentSport = null;
        let currentSportName = '';
        let predictions = [];
        
        // API Usage Tracking - Multi-API Support
        function getActiveApiKey() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
            const apiUsage = JSON.parse(localStorage.getItem('apiUsageOdds') || '{}');
            
            // Initialize tracking for odds API keys
            if (!apiUsage[monthKey]) {
                apiUsage[monthKey] = ODDS_API_KEYS.map(k => ({ 
                    name: k.name, 
                    count: 0, 
                    limit: k.limit,
                    key: k.key 
                }));
            }
            
            // Find first key with available calls
            for (let keyInfo of apiUsage[monthKey]) {
                if (keyInfo.count < keyInfo.limit) {
                    return keyInfo;
                }
            }
            
            // All keys exhausted - return primary anyway (will show error)
            return apiUsage[monthKey][0];
        }
        
        function trackApiCall() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
            const apiUsage = JSON.parse(localStorage.getItem('apiUsageOdds') || '{}');
            
            if (!apiUsage[monthKey]) {
                apiUsage[monthKey] = ODDS_API_KEYS.map(k => ({ 
                    name: k.name, 
                    count: 0, 
                    limit: k.limit,
                    key: k.key 
                }));
            }
            
            // Increment the active key's usage
            const activeKey = getActiveApiKey();
            const keyIndex = apiUsage[monthKey].findIndex(k => k.key === activeKey.key);
            if (keyIndex !== -1) {
                apiUsage[monthKey][keyIndex].count++;
            }
            
            // Clean up old months
            const currentMonth = monthKey;
            Object.keys(apiUsage).forEach(key => {
                if (key !== currentMonth) delete apiUsage[key];
            });
            
            localStorage.setItem('apiUsageOdds', JSON.stringify(apiUsage));
            updateApiUsageDisplay();
            return apiUsage[monthKey];
        }
        
       
        
        function getApiUsage() {
            const now = new Date();
            const monthKey = `${now.getFullYear()}-${now.getMonth() + 1}`;
            const apiUsage = JSON.parse(localStorage.getItem('apiUsageOdds') || '{}');
            
            if (!apiUsage[monthKey]) {
                return ODDS_API_KEYS.map(k => ({ name: k.name, count: 0, limit: k.limit }));
            }
            return apiUsage[monthKey];
        }
        
        function canMakeApiCall(callsNeeded = 1) {
            const usageArray = getApiUsage();
            const totalUsed = usageArray.reduce((sum, k) => sum + k.count, 0);
            const totalLimit = usageArray.reduce((sum, k) => sum + k.limit, 0);
            const remaining = totalLimit - totalUsed;
            
            return {
                allowed: remaining >= callsNeeded,
                remaining: remaining,
                needed: callsNeeded,
                current: totalUsed,
                limit: totalLimit,
                keys: usageArray
            };
        }
        
        function updateApiUsageDisplay() {
            const usageArray = getApiUsage();
            const totalUsed = usageArray.reduce((sum, k) => sum + k.count, 0);
            const totalLimit = usageArray.reduce((sum, k) => sum + k.limit, 0);
            const percent = (totalUsed / totalLimit * 100).toFixed(0);
            const remaining = totalLimit - totalUsed;
            const color = percent >= 100 ? 'text-red-600 font-black' : percent > 90 ? 'text-red-600' : percent > 70 ? 'text-orange-600' : 'text-green-600';
            const apiDisplay = document.getElementById('apiUsage');

            if (apiDisplay) {
                // Show Odds API usage only
                let html = `<div class="mb-1"><span class="${color} font-bold">${totalUsed}/${totalLimit}</span> Odds API (month)</div>`;

                // Show individual Odds API key status
                const keyDetails = usageArray.map(k => {
                    const keyPercent = (k.count / k.limit * 100).toFixed(0);
                    const keyColor = keyPercent >= 100 ? 'text-red-500' : keyPercent > 90 ? 'text-orange-500' : 'text-green-500';
                    return `<span class="${keyColor} text-xs">${k.name}: ${k.count}/${k.limit}</span>`;
                }).join(' ‚Ä¢ ');

                html += `<div class="text-xs text-gray-600 dark:text-gray-400 mb-1">${keyDetails}</div>`;
                apiDisplay.innerHTML = html;
            }

            // Notify when approaching limit
            if (percent >= 100 && !localStorage.getItem('api100notified')) {
                showNotification('üõë API LIMIT REACHED - Using cache only', 'error');
                localStorage.setItem('api100notified', 'true');
            } else if (percent >= 90 && !localStorage.getItem('api90notified')) {
                showNotification('‚ö†Ô∏è API usage at 90% - Only essential calls', 'warning');
                localStorage.setItem('api90notified', 'true');
            } else if (percent >= 70 && !localStorage.getItem('api70notified')) {
                showNotification('üìä API usage at 70% - Using cache when possible', 'info');
                localStorage.setItem('api70notified', 'true');
            }
        }
        
        // Storage Management
        function getStorageUsage() {
            let total = 0;
            for (let key in localStorage) {
                if (localStorage.hasOwnProperty(key)) {
                    total += localStorage[key].length + key.length;
                }
            }
            const mb = (total / (1024 * 1024)).toFixed(2);
            const percent = ((total / (5 * 1024 * 1024)) * 100).toFixed(1);
            return { bytes: total, mb, percent };
        }
        
        function updateStorageDisplay() {
            const usage = getStorageUsage();
            const elem = document.getElementById('storageUsage');
            if (elem) {
                const color = usage.percent > 80 ? 'text-red-600' : usage.percent > 60 ? 'text-orange-600' : 'text-green-600';
                elem.className = color + ' font-bold';
                elem.textContent = usage.percent + '%';
            }
        }
        
        function cleanupOldData() {
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - 90); // Keep last 90 days
            
            predictions = predictions.filter(p => {
                const predDate = new Date(p.timestamp || p.oddsTimestamp || 0);
                return predDate > cutoffDate || !p.settled;
            });
            
            savePredictions();
            console.log(`üóëÔ∏è Cleaned up old predictions. ${predictions.length} remaining.`);
        }
        
        // API Response Caching
        const apiCache = {
            data: {},
            set(key, value, ttlMinutes = 5) {
                this.data[key] = {
                    value,
                    expires: Date.now() + (ttlMinutes * 60 * 1000)
                };
            },
            get(key) {
                const cached = this.data[key];
                if (!cached) return null;
                if (Date.now() > cached.expires) {
                    delete this.data[key];
                    return null;
                }
                return cached.value;
            },
            clear() {
                this.data = {};
            }
        };
        
        // Export/Import Functions
        function exportData() {
            const exportObj = {
                predictions,
                aiModel: ai.model,
                exportDate: new Date().toISOString(),
                version: '2.0'
            };
            const dataStr = JSON.stringify(exportObj, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `ai-betting-backup-${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            URL.revokeObjectURL(url);
            showNotification('‚úÖ Data exported successfully!', 'success');
        }
        
        function importData() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = (e) => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const importObj = JSON.parse(event.target.result);
                        if (confirm(`Import ${importObj.predictions?.length || 0} predictions and AI model from ${importObj.exportDate}?`)) {
                            predictions = importObj.predictions || [];
                            ai.model = importObj.aiModel || ai.model;
                            savePredictions();
                            ai.saveModel();
                            displayPredictions();
                            updateStats();
                            showNotification('‚úÖ Data imported successfully!', 'success');
                        }
                    } catch (err) {
                        showNotification('‚ùå Invalid backup file', 'error');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }
        
        // Auto-Settlement Notification Window
        function showSettlementNotification(pred, won, score, homeScore, awayScore, resultDetails) {
            const gameDate = new Date(pred.gameTime);
            const dateStr = gameDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            const timeStr = gameDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
            
            // Calculate payout
            const stake = 100;
            let payout = 0;
            if (won) {
                if (pred.odds > 0) {
                    payout = stake + (stake * pred.odds / 100);
                } else {
                    payout = stake + (stake * 100 / Math.abs(pred.odds));
                }
            }
            
            // Create notification container if it doesn't exist
            let container = document.getElementById('settlementNotifications');
            if (!container) {
                container = document.createElement('div');
                container.id = 'settlementNotifications';
                container.style.cssText = `
                    position: fixed;
                    top: 80px;
                    right: 20px;
                    z-index: 10000;
                    max-width: 400px;
                    max-height: 80vh;
                    overflow-y: auto;
                `;
                document.body.appendChild(container);
            }
            
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                background: ${won ? 'linear-gradient(135deg, #10b981 0%, #059669 100%)' : 'linear-gradient(135deg, #ef4444 0%, #dc2626 100%)'};
                color: white;
                padding: 16px;
                border-radius: 12px;
                margin-bottom: 12px;
                box-shadow: 0 8px 24px rgba(0,0,0,0.3);
                animation: slideInRight 0.5s ease-out;
                border: 2px solid ${won ? '#34d399' : '#f87171'};
            `;
            
            notification.innerHTML = `
                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                    <div style="font-size: 24px;">${won ? '‚úÖ' : '‚ùå'}</div>
                    <div style="font-size: 18px; font-weight: bold;">${won ? 'WON' : 'LOST'}</div>
                    <button onclick="this.parentElement.parentElement.remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; width: 24px; height: 24px; border-radius: 50%; cursor: pointer; font-size: 16px;">√ó</button>
                </div>
                <div style="font-size: 14px; font-weight: 600; margin-bottom: 6px;">
                    ${pred.game}
                </div>
                <div style="font-size: 12px; opacity: 0.95; margin-bottom: 8px;">
                    üìÖ ${dateStr} at ${timeStr}
                </div>
                <div style="background: rgba(255,255,255,0.15); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                    <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">AI PICK</div>
                    <div style="font-size: 13px; font-weight: 600;">
                        ${pred.betDetails} ${pred.odds > 0 ? '+' : ''}${pred.odds}
                    </div>
                    <div style="font-size: 11px; opacity: 0.9; margin-top: 2px;">
                        ${pred.confidence.toFixed(0)}% confidence
                    </div>
                </div>
                <div style="background: rgba(255,255,255,0.15); padding: 8px; border-radius: 6px; margin-bottom: 8px;">
                    <div style="font-size: 11px; opacity: 0.9; margin-bottom: 4px;">FINAL SCORE</div>
                    <div style="font-size: 13px; font-weight: 600;">
                        ${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}
                    </div>
                    <div style="font-size: 11px; opacity: 0.9; margin-top: 4px;">
                        ${resultDetails}
                    </div>
                </div>
                ${won ? `
                    <div style="background: rgba(255,255,255,0.2); padding: 8px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 11px; opacity: 0.9;">PAYOUT ($100 stake)</div>
                        <div style="font-size: 16px; font-weight: bold; margin-top: 2px;">
                            $${payout.toFixed(2)}
                        </div>
                        <div style="font-size: 11px; opacity: 0.9; margin-top: 2px;">
                            Profit: +$${(payout - stake).toFixed(2)}
                        </div>
                    </div>
                ` : `
                    <div style="background: rgba(255,255,255,0.2); padding: 6px; border-radius: 6px; text-align: center;">
                        <div style="font-size: 12px;">
                            Loss: -$${stake.toFixed(2)}
                        </div>
                    </div>
                `}
            `;
            
            // Add to container
            container.insertBefore(notification, container.firstChild);
            
            // Auto-remove after 15 seconds
            setTimeout(() => {
                notification.style.animation = 'slideOutRight 0.5s ease-out';
                setTimeout(() => notification.remove(), 500);
            }, 15000);
            
            // Show browser notification if permitted
            if (Notification.permission === 'granted') {
                new Notification(`Bet ${won ? 'WON' : 'LOST'} ‚úÖ`, {
                    body: `${pred.game}\n${pred.betDetails}\nFinal: ${score.away_team} ${awayScore} - ${homeScore} ${score.home_team}`,
                    icon: won ? '‚úÖ' : '‚ùå'
                });
            }
        }
        
        // Confidence Filter
        let minConfidenceFilter = 0;
        function updateConfidenceFilter(value) {
            minConfidenceFilter = parseInt(value);
            document.getElementById('minConfidenceValue').textContent = value + '%';
            displayPredictions();
        }
        
        // Model Versioning
        function createModelSnapshot() {
            const snapshots = JSON.parse(localStorage.getItem('modelSnapshots') || '[]');
            const snapshot = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                model: JSON.parse(JSON.stringify(ai.model)),
                winRate: ai.model.totalBets > 0 ? (ai.model.wins / ai.model.totalBets * 100).toFixed(1) : 0
            };
            snapshots.push(snapshot);
            // Keep only last 10 snapshots
            if (snapshots.length > 10) snapshots.shift();
            localStorage.setItem('modelSnapshots', JSON.stringify(snapshots));
            showNotification('üíæ Model snapshot saved', 'success');
            displayModelVersions();
        }
        
        function displayModelVersions() {
            const snapshots = JSON.parse(localStorage.getItem('modelSnapshots') || '[]');
            const container = document.getElementById('modelVersions');
            const list = document.getElementById('versionsList');
            
            if (snapshots.length === 0) {
                container.style.display = 'none';
                return;
            }
            
            container.style.display = 'block';
            list.innerHTML = snapshots.reverse().map((snap, idx) => `
                <div class="flex justify-between items-center p-2 bg-gray-100 dark:bg-gray-800 rounded">
                    <div>
                        <div class="font-semibold">${new Date(snap.timestamp).toLocaleString()}</div>
                        <div class="text-gray-500">Win Rate: ${snap.winRate}% | Bets: ${snap.model.totalBets}</div>
                    </div>
                    <button onclick="restoreModelSnapshot(${snap.id})" class="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600">Restore</button>
                </div>
            `).join('');
        }
        
        function restoreModelSnapshot(snapshotId) {
            const snapshots = JSON.parse(localStorage.getItem('modelSnapshots') || '[]');
            const snapshot = snapshots.find(s => s.id === snapshotId);
            if (!snapshot) return;
            
            if (confirm(`Restore model from ${new Date(snapshot.timestamp).toLocaleString()}?`)) {
                ai.model = snapshot.model;
                ai.saveModel();
                updateStats();
                showNotification('‚úÖ Model restored successfully!', 'success');
            }
        }

        // Render stored daily briefings in a modal-like overlay
        function renderDailyBriefings() {
            const briefings = JSON.parse(localStorage.getItem('dailyBriefings') || '[]').slice().reverse();
            const modalId = 'dailyBriefingsModal';
            let modal = document.getElementById(modalId);
            if (modal) modal.remove();

            modal = document.createElement('div');
            modal.id = modalId;
            modal.style.cssText = `position:fixed; inset:0; background: rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:20000; padding:20px;`;

            const box = document.createElement('div');
            box.style.cssText = 'background: white; max-width:900px; width:100%; max-height:80vh; overflow:auto; border-radius:12px; padding:18px; box-shadow:0 12px 48px rgba(2,6,23,0.4);';
            // Adapt to mobile: full screen modal
            if (window.innerWidth <= 640) {
                box.style.width = '100%';
                box.style.height = '100%';
                box.style.maxHeight = '100%';
                box.style.borderRadius = '0';
                box.style.padding = '12px';
            }

            const header = document.createElement('div');
            header.style.cssText = 'display:flex; justify-content:space-between; align-items:center; margin-bottom:12px;';
            header.innerHTML = `<div><h3 style="margin:0;font-size:18px;">üìÖ Daily AI Briefings</h3><div style="font-size:12px;color:#555;">Most recent first</div></div>`;
            const closeBtn = document.createElement('button');
            closeBtn.textContent = 'Close';
            closeBtn.onclick = () => modal.remove();
            closeBtn.style.cssText = 'background:#efefef;border:none;padding:8px 10px;border-radius:8px;cursor:pointer;';
            header.appendChild(closeBtn);
            box.appendChild(header);

            if (!briefings.length) {
                const empty = document.createElement('div');
                empty.textContent = 'No briefings available yet.';
                empty.style.cssText = 'color:#666;padding:20px;';
                box.appendChild(empty);
            } else {
                briefings.forEach(b => {
                    const item = document.createElement('div');
                    item.style.cssText = 'border-bottom:1px solid #eee;padding:12px 0;';
                    const d = new Date(b.date);
                    item.innerHTML = `
                        <div style="display:flex;justify-content:space-between;align-items:center;">
                            <div style="font-weight:700">${d.toLocaleDateString()} ${d.toLocaleTimeString()}</div>
                            <div style="font-size:12px;color:#666">Win Rate: ${b.winRate}% ‚Ä¢ Bets: ${b.totalBets}</div>
                        </div>
                        <div style="margin-top:6px;color:#333;white-space:pre-wrap;">${b.summary}</div>
                        <div style="margin-top:8px;font-size:12px;color:#444">Snapshot: Learning Cycles ${b.modelSnapshot.learningCycles || 0} ‚Ä¢ Wins ${b.modelSnapshot.wins || 0} ‚Ä¢ Losses ${b.modelSnapshot.losses || 0}</div>
                    `;
                    box.appendChild(item);
                });
            }

            modal.appendChild(box);
            document.body.appendChild(modal);
        }

        // Generate and download a macOS-compatible .webloc shortcut file for the current URL
        function downloadDesktopShortcut() {
            const url = window.location.href;
            const plist = `<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">\n<plist version="1.0">\n<dict>\n  <key>URL</key>\n  <string>${url}</string>\n</dict>\n</plist>`;
            const blob = new Blob([plist], { type: 'application/xml' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            // Name the file using project name
            a.download = 'NewBets.webloc';
            document.body.appendChild(a);
            a.click();
            setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1500);
            showNotification('üîó Desktop shortcut downloaded. Move it to your Desktop to open the app by double-clicking.', 'success');
        }

        // PWA install prompt handling
        let deferredPWAInstall = null;
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPWAInstall = e;
            const btn = document.getElementById('installBtn');
            if (btn) btn.style.display = 'block';
            console.log('üì• beforeinstallprompt captured');
        });

        async function installPWA() {
            if (!deferredPWAInstall) {
                // Fallback: show instructions
                alert('PWA install not available. Use browser Install / Add to Home Screen option.');
                return;
            }
            deferredPWAInstall.prompt();
            const choice = await deferredPWAInstall.userChoice;
            if (choice.outcome === 'accepted') {
                showNotification('‚úÖ App installed', 'success');
            } else {
                showNotification('‚ùå Install dismissed', 'warning');
            }
            deferredPWAInstall = null;
            const btn = document.getElementById('installBtn');
            if (btn) btn.style.display = 'none';
        }
        
        // Dark Mode
        function toggleDarkMode() {
            document.body.classList.toggle('dark-mode');
            const isDark = document.body.classList.contains('dark-mode');
            localStorage.setItem('darkMode', isDark);
            document.getElementById('darkModeBtn').textContent = isDark ? '‚òÄÔ∏è Light' : 'üåô Dark';
        }
        
        function initDarkMode() {
            const isDark = localStorage.getItem('darkMode') === 'true';
            if (isDark) {
                document.body.classList.add('dark-mode');
                document.getElementById('darkModeBtn').textContent = '‚òÄÔ∏è Light';
            }
        }
        
        // Browser Notifications
        let notificationsEnabled = false;
        function requestNotificationPermission() {
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    notificationsEnabled = permission === 'granted';
                    if (notificationsEnabled) {
                        showNotification('üîî Notifications enabled!', 'success');
                    }
                });
            } else if (Notification.permission === 'granted') {
                notificationsEnabled = true;
            }
        }
        
        function showNotification(message, type = 'info') {
            // Visual notification
            const notif = document.createElement('div');
            const colors = {
                success: 'bg-green-500',
                error: 'bg-red-500',
                warning: 'bg-orange-500',
                info: 'bg-blue-500'
            };
            notif.className = `fixed top-20 right-4 ${colors[type]} text-white px-4 py-3 rounded-lg shadow-lg z-50 animate-pulse`;
            notif.textContent = message;
            document.body.appendChild(notif);
            setTimeout(() => notif.remove(), 3000);
            
            // Browser notification
            if (notificationsEnabled && type !== 'info') {
                new Notification('AI Betting System', { body: message, icon: 'ü§ñ' });
            }
        }
        
        // Load predictions from localStorage on startup
        function loadPredictions() {
            const saved = localStorage.getItem('predictions');
            if (saved) {
                try {
                    predictions = JSON.parse(saved);
                    console.log(`Loaded ${predictions.length} saved predictions`);
                } catch (e) {
                    console.error('Error loading predictions:', e);
                    predictions = [];
                }
            }
        }
        
        // Save predictions to localStorage
        function savePredictions() {
            localStorage.setItem('predictions', JSON.stringify(predictions));
        }

                // Quick composer helpers
                function setComposerPick(p) {
                    const el = document.getElementById('composerPick');
                    if (el) el.value = p;
                    // visual feedback (optional)
                    showNotification(`Composer pick set: ${p.toUpperCase()}`, 'info');
                }

                function addManualPrediction() {
                    const sportKey = document.getElementById('composerSport').value;
                    const gameText = (document.getElementById('composerGame').value || '').trim();
                    const pick = (document.getElementById('composerPick').value || 'home').toLowerCase();

                    // parse teams from gameText (very tolerant)
                    let home = 'Home';
                    let away = 'Away';
                    if (gameText) {
                        const parts = gameText.split(/\s+vs\s+|\s+v\s+|\s+@\s+/i);
                        if (parts.length === 2) {
                            home = parts[1].trim();
                            away = parts[0].trim();
                        } else {
                            // try comma split
                            const comma = gameText.split(/,| vs | VS /i);
                            if (comma.length >= 2) { away = comma[0].trim(); home = comma[1].trim(); }
                            else { home = gameText; away = 'Opponent'; }
                        }
                    }

                    let team = pick === 'home' ? home : (pick === 'away' ? away : 'Draw');
                    let opponent = pick === 'home' ? away : (pick === 'away' ? home : 'Draw');
                    const betDetails = pick === 'draw' ? 'Draw' : `${team} to Win`;

                    const newPred = {
                        id: `manual_${Date.now()}`,
                        game: `${away} @ ${home}`,
                        gameId: `manual_${Date.now()}`,
                        sportKey: sportKey,
                        sport: sportKey,
                        team: team,
                        opponent: opponent,
                        type: 'Moneyline',
                        betDetails: betDetails,
                        odds: 100,
                        confidence: 72,
                        aiReasoning: ['Manual entry'],
                        gameTime: new Date().toISOString(),
                        timestamp: Date.now(),
                        settled: false,
                        learned: false
                    };

                    predictions.unshift(newPred);
                    savePredictions();
                    displayPredictions();
                    showNotification('‚úÖ Manual prediction added', 'success');
                }
        

        // --- AutoMode UI & Simulation Helper ---
        function getAutoMode() {
            return (localStorage.getItem('autoMode') || 'true') === 'true';
        }

        function setAutoMode(enabled) {
            localStorage.setItem('autoMode', enabled ? 'true' : 'false');
            updateAutoModeUI();
            showNotification(enabled ? 'ü§ñ AutoMode enabled' : '‚è∏Ô∏è AutoMode disabled', enabled ? 'success' : 'info');
        }

        function toggleAutoMode() {
            setAutoMode(!getAutoMode());
        }

        function updateAutoModeUI() {
            const enabled = getAutoMode();
            const btn = document.getElementById('autoModeBtn');
            const badgeText = document.getElementById('autoLearningText');
            const badgeDot = document.getElementById('autoLearningDot');
            if (btn) {
                btn.textContent = enabled ? '‚öôÔ∏è AutoMode: ON' : '‚öôÔ∏è AutoMode: OFF';
                btn.style.backgroundColor = enabled ? '#4f46e5' : '#6b7280';
            }
            if (badgeText) {
                badgeText.textContent = enabled ? 'ü§ñ Auto-Learning Active' : '‚è∏Ô∏è Auto-Learning Paused';
            }
            if (badgeDot) {
                badgeDot.style.display = enabled ? 'flex' : 'none';
            }
        }

        // Simulation helper removed - learning is based on real logged & settled bets only


        // AI Learning Model
        class BettingAI {
            constructor() {
                this.loadModel();
            }
            // Always generate a pick for every game
            async analyzeGame(game) {
                // Fallback: Always return a pick, even if data is incomplete
                // Use basic info if no model or data
                const home = game.home_team || 'Home';
                const away = game.away_team || 'Away';
                const odds = (game.bookmakers && game.bookmakers[0] && game.bookmakers[0].markets && game.bookmakers[0].markets[0] && game.bookmakers[0].markets[0].outcomes) ? game.bookmakers[0].markets[0].outcomes : [];
                let pickTeam = home;
                let pickOdds = 0;
                if (odds.length >= 2) {
                    // Pick the team with better odds (lower negative or higher positive)
                    if (odds[0].price > odds[1].price) {
                        pickTeam = odds[0].name;
                        pickOdds = odds[0].price;
                    } else {
                        pickTeam = odds[1].name;
                        pickOdds = odds[1].price;
                    }
                }
                // Always return a pick with at least 60% confidence
                return {
                    game: `${away} @ ${home}`,
                    gameId: game.id || `${away}_at_${home}`,
                    team: pickTeam,
                    opponent: pickTeam === home ? away : home,
                    type: 'Moneyline',
                    betDetails: `${pickTeam} to Win`,
                    odds: pickOdds || 100,
                    confidence: 65 + Math.floor(Math.random() * 10), // 65-74% confidence
                    aiReasoning: 'Default fallback: AI always generates a pick for learning and transparency.',
                    gameTime: game.commence_time || new Date().toISOString(),
                    settled: false
                };
            }

            // Initialize or load model from localStorage
            loadModel() {
                try {
                    const raw = localStorage.getItem('aiModel');
                    if (raw) {
                        this.model = JSON.parse(raw);
                    } else {
                        this.model = this._defaultModel();
                        this.saveModel();
                    }
                } catch (err) {
                    console.warn('Failed to load AI model, using defaults.', err);
                    this.model = this._defaultModel();
                }
            }

            saveModel() {
                try {
                    localStorage.setItem('aiModel', JSON.stringify(this.model));
                } catch (err) {
                    console.warn('Failed to save AI model', err);
                }
            }

            // Normalize team names for robust matching
            normalizeName(name) {
                if (!name) return '';
                // Remove accents, punctuation, common club suffixes/prefixes and lowercase
                let s = name.toString().normalize('NFD').replace(/\p{Diacritic}/gu, '');
                s = s.replace(/[^\w\s]/g, ' ');
                s = s.replace(/\b(FC|CF|SC|AC|CD|REAL|SPORTING|ATHLETIC|CLUB|TEAM|UNITED)\b/gi, '');
                s = s.replace(/\s+/g, ' ').trim().toLowerCase();
                return s;
            }

            // Simple Levenshtein distance for fuzzy matching
            levenshtein(a, b) {
                if (!a || !b) return Math.max(a ? a.length : 0, b ? b.length : 0);
                const m = a.length, n = b.length;
                const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));
                for (let i = 0; i <= m; i++) dp[i][0] = i;
                for (let j = 0; j <= n; j++) dp[0][j] = j;
                for (let i = 1; i <= m; i++) {
                    for (let j = 1; j <= n; j++) {
                        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                        dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
                    }
                }
                return dp[m][n];
            }

            // Determine if two names are similar enough
            namesSimilar(a, b) {
                const na = this.normalizeName(a);
                const nb = this.normalizeName(b);
                if (!na || !nb) return false;
                if (na === nb) return true;
                // If one contains the other, that's a match
                if (na.includes(nb) || nb.includes(na)) return true;
                const dist = this.levenshtein(na, nb);
                const maxLen = Math.max(na.length, nb.length);
                // allow small edit distance relative to length
                return dist <= Math.max(1, Math.floor(maxLen * 0.18));
            }

            // Try to match a prediction to a result object robustly
            matchPredictionToResult(pred, result) {
                // Exact id match
                if (result && pred.gameId && result.id && pred.gameId === result.id) {
                    return { match: true, homeScore: result.scores?.find(s=>s.name==='home')?.score ?? null, awayScore: result.scores?.find(s=>s.name==='away')?.score ?? null, homeTeam: result.home_team, awayTeam: result.away_team, completed: !!(result.completed || result.scores) };
                }

                // If result has home/away names, use fuzzy matching
                const homeName = result?.home_team || result?.home || '';
                const awayName = result?.away_team || result?.away || '';
                if (homeName || awayName) {
                    const predTeam = pred.team || '';
                    const predOpp = pred.opponent || '';
                    // Try to match pred.team to home/away
                    if (this.namesSimilar(predTeam, homeName) && this.namesSimilar(predOpp, awayName)) {
                        return { match: true, homeScore: result.scores?.find(s=>s.name==='home')?.score ?? null, awayScore: result.scores?.find(s=>s.name==='away')?.score ?? null, homeTeam: homeName, awayTeam: awayName, completed: !!(result.completed || result.scores) };
                    }
                    if (this.namesSimilar(predTeam, awayName) && this.namesSimilar(predOpp, homeName)) {
                        return { match: true, homeScore: result.scores?.find(s=>s.name==='home')?.score ?? null, awayScore: result.scores?.find(s=>s.name==='away')?.score ?? null, homeTeam: homeName, awayTeam: awayName, completed: !!(result.completed || result.scores) };
                    }
                }

                // Fallback: attempt fuzzy match against result.title or combined string
                const title = (result?.title || '') + ' ' + (result?.commence_time || '');
                if (title && (this.namesSimilar(pred.team, title) || this.namesSimilar(pred.game, title))) {
                    return { match: true, homeScore: result.scores?.find(s=>s.name==='home')?.score ?? null, awayScore: result.scores?.find(s=>s.name==='away')?.score ?? null, homeTeam: result.home_team, awayTeam: result.away_team, completed: !!(result.completed || result.scores) };
                }

                return { match: false };
            }

            _defaultModel() {
                return {
                    learningCycles: 0,
                    totalBets: 0,
                    wins: 0,
                    losses: 0,
                    pushes: 0,
                    betTypePerformance: {
                        Moneyline: { wins: 0, total: 0 },
                        Spread: { wins: 0, total: 0 },
                        Total: { wins: 0, total: 0 }
                    },
                    recentTrend: { last10: [] },
                    // Pattern statistics (Bayesian Beta priors) keyed by pattern string
                    patternStats: {},
                    // Simple feature weights updated incrementally
                    weights: {
                        teamStrength: 0.0,
                        homeAdvantage: 0.0,
                        bookmakerBias: 0.0,
                        betType: 0.0,
                        recentMomentum: 0.0
                    },
                    // Learning hyperparameters (tweakable via UI later)
                    hyperparams: {
                        learningRate: 0.06,
                        decay: 0.995,
                        diamondThreshold: 0.95,
                        diamondMinExamples: 5
                    },
                    // Confidence calibration buckets
                    confidenceCalibration: {},
                    // Performance history for charting and backtesting
                    performanceHistory: []
                };
            }

            // Learn from settled predictions that haven't been learned yet
            learn() {
                const insights = [];
                const settled = (window.predictions || []).filter(p => p.settled && !p.learned);
                if (!settled.length) return ['No new settled bets to learn from.'];

                // Ensure maps exist
                this.model.teamPerformance = this.model.teamPerformance || {};
                this.model.patternStats = this.model.patternStats || {};
                this.model.confidenceCalibration = this.model.confidenceCalibration || {};

                const lr = this.model.hyperparams?.learningRate || 0.06;
                const decay = this.model.hyperparams?.decay || 0.995;
                const diamondThreshold = this.model.hyperparams?.diamondThreshold || 0.95;
                const diamondMinExamples = this.model.hyperparams?.diamondMinExamples || 5;

                let processed = 0;

                for (const p of settled) {
                    // Interpret push/draw
                    if (p.push) {
                        this.model.pushes = (this.model.pushes || 0) + 1;
                    }

                    // Only count as a statistical bet if not a push
                    if (!p.push) {
                        this.model.totalBets = (this.model.totalBets || 0) + 1;
                        if (p.won) {
                            this.model.wins = (this.model.wins || 0) + 1;
                            this.model.betTypePerformance[p.type] = this.model.betTypePerformance[p.type] || { wins: 0, total: 0 };
                            this.model.betTypePerformance[p.type].wins += 1;
                        } else {
                                if (pick) {
                                pick.sport = sport.name;
                                pick.sportEmoji = sport.emoji;
                                newPredictions.push(pick);
                                added++;
                            } else {
                    const team = p.team || 'unknown';
                    const opp = p.opponent || 'unknown';
                    this.model.teamPerformance[team] = this.model.teamPerformance[team] || { wins: 0, losses: 0, pushes: 0, games: 0 };
                    this.model.teamPerformance[opp] = this.model.teamPerformance[opp] || { wins: 0, losses: 0, pushes: 0, games: 0 };
                    if (p.push) {
                        this.model.teamPerformance[team].pushes += 1;
                        this.model.teamPerformance[opp].pushes += 1;
                    } else if (p.won) {
                        this.model.teamPerformance[team].wins += 1;
                        this.model.teamPerformance[opp].losses += 1;
                    } else {
                        this.model.teamPerformance[team].losses += 1;
                        this.model.teamPerformance[opp].wins += 1;
                    }
                    this.model.teamPerformance[team].games += 1;
                    this.model.teamPerformance[opp].games += 1;

                    // Update pattern stats (pattern = sport|type|team)
                    const patternKey = `${p.sport || 'any'}|${p.type || 'any'}|${this.normalizeName(team)}`;
                    this.model.patternStats[patternKey] = this.model.patternStats[patternKey] || { alpha: 1, beta: 1, wins: 0, total: 0, last: Date.now() };
                    const ps = this.model.patternStats[patternKey];
                    ps.total += p.push ? 0 : 1;
                    if (!p.push) {
                        if (p.won) { ps.wins += 1; ps.alpha += 1; } else { ps.beta += 1; }
                    }
                    ps.last = Date.now();

                    // Update confidence calibration bucket
                    const bucket = Math.min(95, Math.max(0, Math.round((p.confidence || 50) / 5) * 5));
                    this.model.confidenceCalibration[bucket] = this.model.confidenceCalibration[bucket] || { wins: 0, total: 0 };
                    if (!p.push) {
                        this.model.confidenceCalibration[bucket].total += 1;
                        if (p.won) this.model.confidenceCalibration[bucket].wins += 1;
                    }

                    // Incremental weight updates (simple reward/punish)
                    // Features: teamStrength (team recent win rate), homeAdvantage (home?), betType, bookmaker
                    try {
                        const teamPerf = this.model.teamPerformance[team];
                        const teamWinRate = teamPerf && teamPerf.games ? (teamPerf.wins / teamPerf.games) : 0.5;
                        // reward weights when prediction correct, penalize when wrong
                        const reward = p.won ? 1 : -1;
                        // Update weights with small lr * reward * feature
                        this.model.weights.teamStrength = (this.model.weights.teamStrength || 0) * decay + lr * reward * (teamWinRate - 0.5);
                        const isHome = (p.home === true) || (p.betSide && p.betSide === 'home') || (p.location && p.location === 'home');
                        this.model.weights.homeAdvantage = (this.model.weights.homeAdvantage || 0) * decay + lr * reward * (isHome ? 0.6 : -0.1);
                        this.model.weights.betType = (this.model.weights.betType || 0) * decay + lr * reward * (p.type === 'Moneyline' ? 0.2 : 0.1);
                        // Bookmaker bias: if source is provided
                        const bm = p.bookmaker || (p.source && p.source.bookmaker) || 'unknown';
                        this.model.weights.bookmakerBias = (this.model.weights.bookmakerBias || 0) * decay + lr * reward * (bm === 'fav' ? 0.1 : 0);
                        // recent momentum influence
                        const recentWins = (this.model.recentTrend && this.model.recentTrend.last10) ? this.model.recentTrend.last10.filter(Boolean).length : 0;
                        this.model.weights.recentMomentum = (this.model.weights.recentMomentum || 0) * decay + lr * reward * ((recentWins / 10) - 0.5);
                    } catch (e) {
                        console.warn('Weight update failed', e);
                    }

                    // Append to performance history (bounded)
                    this.model.performanceHistory = this.model.performanceHistory || [];
                    this.model.performanceHistory.push({ timestamp: Date.now(), won: !!p.won, confidence: p.confidence || 50, odds: p.odds || 0, type: p.type, sport: p.sport });
                    if (this.model.performanceHistory.length > 5000) this.model.performanceHistory.shift();

                    // Mark as learned
                    p.learned = true;
                    processed++;
                }

                // After processing, detect diamond patterns
                const diamonds = [];
                Object.entries(this.model.patternStats).forEach(([k, v]) => {
                    const total = v.total || 0;
                    const mean = v.alpha / (v.alpha + v.beta);
                    if (total >= diamondMinExamples && mean >= diamondThreshold) {
                        diamonds.push({ pattern: k, total, mean });
                    }
                });

                // Save and increment cycle
                this.model.learningCycles = (this.model.learningCycles || 0) + 1;
                this.saveModel();

                insights.push(`${processed} settled bets processed.`);
                insights.push(`Total Bets: ${this.model.totalBets || 0}, Wins: ${this.model.wins || 0}, Losses: ${this.model.losses || 0}, Pushes: ${this.model.pushes || 0}`);
                if (diamonds.length) {
                    insights.push(`üî∂ Diamond patterns found: ${diamonds.length}`);
                    diamonds.slice(0,5).forEach(d => insights.push(`‚Ä¢ ${d.pattern} ‚Äî ${(d.mean*100).toFixed(1)}% over ${d.total} bets`));
                } else {
                    insights.push('No diamond patterns detected this cycle.');
                }

                // Return human-friendly insights
                return insights;
            }

            // Settle a single prediction using a result object (scores or completed flag)
            settlePrediction(pred, result, homeScore, awayScore) {
                try {
                    // Use the smarter matcher to find relevant result fields
                    const m = this.matchPredictionToResult(pred, result || {});
                    if (!m.match) {
                        // couldn't match this prediction to the provided result
                        return false;
                    }

                    const home = (typeof homeScore === 'number') ? homeScore : (m.homeScore ?? null);
                    const away = (typeof awayScore === 'number') ? awayScore : (m.awayScore ?? null);

                    if (home !== null && away !== null) {
                        pred.finalScore = `${home}-${away}`;
                        // handle draw/push
                        if (home === away) {
                            // For sports with a Draw outcome (soccer), consider "Draw" as a valid winning prediction.
                            const wantsDraw = (pred.team && this.namesSimilar(pred.team, 'draw')) || (pred.type && String(pred.type).toLowerCase().includes('draw'));
                            if (wantsDraw) {
                                pred.won = true;
                                pred.push = false;
                            } else {
                                // Otherwise treat as a push for spreads/totals or as no-win for moneyline predictions
                                pred.push = true;
                                pred.won = false; // treat push separately in learn()
                            }
                        } else {
                            // Decide which side won based on team matching
                            const homeTeamName = (m.homeTeam || result?.home_team || result?.home || '').toString();
                            const awayTeamName = (m.awayTeam || result?.away_team || result?.away || '').toString();
                            // if pred.team matches homeTeamName
                            if (this.namesSimilar(pred.team, homeTeamName)) {
                                pred.won = home > away;
                            } else if (this.namesSimilar(pred.team, awayTeamName)) {
                                pred.won = away > home;
                            } else {
                                // fallback: if pred.team appears in game string, attempt mapping
                                if (this.namesSimilar(pred.team, `${awayTeamName} ${homeTeamName}`) || this.namesSimilar(pred.team, `${homeTeamName} ${awayTeamName}`)) {
                                    pred.won = home > away || away > home; // crude fallback
                                } else {
                                    pred.won = false;
                                }
                            }
                        }
                    } else {
                        // No explicit score data; if result contains a completed flag and winner string, use that
                        const winner = result?.winner || result?.winning_team || null;
                        if (winner) {
                            pred.won = this.namesSimilar(pred.team, winner);
                            pred.finalScore = result?.final_score || null;
                        } else {
                            // Can't settle without score or winner info
                            return false;
                        }
                    }

                    pred.settled = true;
                    pred.settledAt = Date.now();
                    return pred.won === true;
                } catch (err) {
                    console.error('Error in settlePrediction', err);
                    return false;
                }
            }
        }

        const ai = new BettingAI();

        // Helper: return calibrated probability for a raw confidence value
        ai.computeCalibratedConfidence = function(confidence) {
            const bucket = Math.min(95, Math.max(0, Math.round((confidence || 50) / 5) * 5));
            const cal = this.model.confidenceCalibration && this.model.confidenceCalibration[bucket];
            if (cal && cal.total > 0) {
                return (cal.wins / cal.total) * 100;
            }
            return confidence; // fallback to raw
        };

        // Helper: run a light daily retrain/decay to keep model adaptive
        ai.runDailyRetrain = function() {
            try {
                // decay older pattern stats slightly to prioritize recent data
                const decay = this.model.hyperparams?.decay || 0.995;
                Object.values(this.model.patternStats || {}).forEach(ps => {
                    ps.alpha = Math.max(1, ps.alpha * decay);
                    ps.beta = Math.max(1, ps.beta * decay);
                });

                // Recompute calibration table summary (no heavy computation)
                Object.keys(this.model.confidenceCalibration || {}).forEach(k => {
                    const b = this.model.confidenceCalibration[k];
                    if (b.total > 0) b.rate = b.wins / b.total;
                });

                // Trim old performance history to last 90 days
                const cutoff = Date.now() - (90 * 24 * 60 * 60 * 1000);
                this.model.performanceHistory = (this.model.performanceHistory || []).filter(h => h.timestamp > cutoff);

                this.model.learningCycles = (this.model.learningCycles || 0) + 1;
                this.saveModel();
                createModelSnapshot && createModelSnapshot();
                return true;
            } catch (e) {
                console.warn('Daily retrain failed', e);
                return false;
            }
        };

        // Mark predictions that match diamond patterns (used by UI and display)
        ai.markDiamondPredictions = function() {
            const h = this.model.hyperparams || {};
            const thr = h.diamondThreshold || 0.95;
            const minEx = h.diamondMinExamples || 5;
            const diamonds = new Set();
            Object.entries(this.model.patternStats || {}).forEach(([k, v]) => {
                const total = v.total || 0;
                const mean = v.alpha / (v.alpha + v.beta);
                if (total >= minEx && mean >= thr) diamonds.add(k);
            });
            // Tag predictions
            (window.predictions || []).forEach(p => {
                const team = p.team || '';
                const key = `${p.sport || 'any'}|${p.type || 'any'}|${ai.normalizeName(team)}`;
                p.diamond = diamonds.has(key);
                if (p.diamond) {
                    // boost displayed confidence slightly for diamond picks
                    p.confidence = Math.max(p.confidence || 0, (ai.computeCalibratedConfidence(p.confidence) || p.confidence));
                }
            });
            savePredictions && savePredictions();
            return Array.from(diamonds);
        };

        // UI hookups for hyperparameter sliders
        function setLearningRate(val) {
            const percent = parseFloat(val);
            document.getElementById('lrValue').textContent = percent + '%';
            if (!ai.model.hyperparams) ai.model.hyperparams = {};
            ai.model.hyperparams.learningRate = percent / 100;
            ai.saveModel();
        }

        function setDiamondThreshold(val) {
            const percent = parseInt(val, 10);
            document.getElementById('diamondValue').textContent = percent + '%';
            if (!ai.model.hyperparams) ai.model.hyperparams = {};
            ai.model.hyperparams.diamondThreshold = percent / 100;
            ai.saveModel();
            // immediately mark diamonds with new threshold
            ai.markDiamondPredictions();
            displayPredictions();
        }

        // Initialize sliders to model values on load
        setTimeout(() => {
            try {
                const hr = (ai.model.hyperparams && ai.model.hyperparams.learningRate) ? Math.round(ai.model.hyperparams.learningRate * 100) : 6;
                const dt = (ai.model.hyperparams && ai.model.hyperparams.diamondThreshold) ? Math.round(ai.model.hyperparams.diamondThreshold * 100) : 95;
                const lrSlider = document.getElementById('learningRateSlider');
                const dtSlider = document.getElementById('diamondThresholdSlider');
                if (lrSlider) { lrSlider.value = hr; document.getElementById('lrValue').textContent = hr + '%'; }
                if (dtSlider) { dtSlider.value = dt; document.getElementById('diamondValue').textContent = dt + '%'; }
            } catch (e) { /* ignore */ }
        }, 1000);

        // --- AUTOMATIC AI CYCLE ---


        // --- 2 API Calls Per Day Scheduler ---
        function scheduleAIActions() {
            // Schedule 6am analysis (can do live fetches when autoMode is enabled)
            scheduleAtHour(6, async () => {
                const autoMode = getAutoMode();
                if (autoMode) {
                    const apiCheck = canMakeApiCall(1);
                    if (!apiCheck.allowed) return showNotification('üõë API LIMIT REACHED - 6am auto-analysis skipped', 'error');
                    await analyzeTodaysGames(true); // force live fetch when cache missing
                } else {
                    // cache-only scheduled analysis
                    await analyzeTodaysGames(false);
                }
            });

            // Schedule 11pm settlement/learning (auto settle + learn + snapshot)
            scheduleAtHour(23, async () => {
                const autoMode = getAutoMode();
                if (autoMode) {
                    const apiCheck = canMakeApiCall(3); // settlement may need multiple calls
                    if (!apiCheck.allowed) return showNotification('üõë API LIMIT REACHED - 11pm auto-settle skipped', 'error');
                    await settleTodaysBets();
                    runLearningCycle && runLearningCycle();
                    updateStats && updateStats();
                    // Save a model snapshot after learning
                    createModelSnapshot();
                    // Run a light daily retrain (decay & recalibrate)
                    try { ai.runDailyRetrain(); } catch (e) { console.warn('Daily retrain error', e); }
                    showDailyLearningSummary();
                } else {
                    // limited scheduled action: only run learning from already-settled bets
                    runLearningCycle && runLearningCycle();
                    updateStats && updateStats();
                    showDailyLearningSummary();
                }
            });
            // Show a daily AI learning/reporting summary after 11pm learning
            function showDailyLearningSummary() {
                if (!ai || !ai.model) return;
                const m = ai.model;
                const summary = `üìä Daily AI Report: ${new Date().toLocaleDateString()}\n` +
                    `Bets: ${m.totalBets || 0}, Wins: ${m.wins || 0}, Losses: ${m.losses || 0}, Win Rate: ${m.totalBets ? ((m.wins/m.totalBets)*100).toFixed(1) : 0}%`;
                showNotification(summary, 'info');
                // Optionally, log to a persistent log (localStorage)
                const briefings = JSON.parse(localStorage.getItem('dailyBriefings') || '[]');
                const briefing = {
                    id: Date.now(),
                    date: new Date().toISOString(),
                    summary: summary,
                    totalBets: m.totalBets || 0,
                    wins: m.wins || 0,
                    losses: m.losses || 0,
                    winRate: m.totalBets ? ((m.wins/m.totalBets)*100).toFixed(1) : 0,
                    modelSnapshot: JSON.parse(JSON.stringify(m))
                };
                briefings.push(briefing);
                // Keep last 90 briefings
                if (briefings.length > 90) briefings.shift();
                localStorage.setItem('dailyBriefings', JSON.stringify(briefings));
            }
            // Schedule hourly learning (no API call, just learning from settled bets)
            setInterval(() => {
                runLearningCycle && runLearningCycle();
                updateStats && updateStats();
            }, 60 * 60 * 1000); // Every hour
        }

        function scheduleAtHour(hour, callback) {
            const now = new Date();
            const target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, 0, 0, 0);
            if (now > target) target.setDate(target.getDate() + 1); // Next day if already passed
            const msUntil = target - now;
            setTimeout(() => {
                callback();
                setInterval(callback, 24 * 60 * 60 * 1000); // Repeat every 24h
            }, msUntil);
        }

        // Analyze only today's games (skip future games)
        async function analyzeTodaysGames(forceLive = false) {
            const sports = [
                { key: 'americanfootball_nfl', name: 'NFL', emoji: 'üèà' },
                { key: 'basketball_nba', name: 'NBA', emoji: 'üèÄ' },
                { key: 'icehockey_nhl', name: 'NHL', emoji: 'üèí' },
                { key: 'baseball_mlb', name: 'MLB', emoji: '‚öæ' },
                { key: 'americanfootball_ncaaf', name: 'NCAAF', emoji: 'üéì' },
                { key: 'soccer_epl', name: 'EPL', emoji: '‚öΩ' },
                { key: 'soccer_usa_mls', name: 'MLS', emoji: '‚öΩ' },
                { key: 'soccer_uefa_champs_league', name: 'UCL', emoji: '‚öΩ' }
            ];
            const today = new Date();
            let newPredictions = [];
            // Scheduled analysis should be cache-only to preserve API quota.
            for (const sport of sports) {
                try {
                    let games = apiCache.get(sport.key);
                    // If no cache and we are allowed to force live fetch (auto-mode), try to fetch live data
                    if ((!games || !Array.isArray(games) || games.length === 0) && forceLive) {
                        const apiCheck = canMakeApiCall(1);
                        if (!apiCheck.allowed) {
                            console.log(`[${sport.name}] No cached data and API limit reached ‚Äî skipping live fetch`);
                            continue;
                        }
                        try {
                            const activeKey = getActiveApiKey();
                            const url = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${activeKey.key}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`;
                            const response = await fetch(url);
                            trackApiCall();
                            if (response.ok) {
                                games = await response.json();
                                apiCache.set(sport.key, games, 5);
                                console.log(`${sport.name}: ${Array.isArray(games) ? games.length : 0} games (from API - scheduled live fetch)`);
                            } else {
                                console.warn(`${sport.name}: Scheduled live fetch failed:`, response.status, response.statusText);
                            }
                        } catch (err) {
                            console.warn(`${sport.name}: Scheduled live fetch error:`, err);
                        }
                    }

                    if (!games || !Array.isArray(games) || games.length === 0) {
                        console.log(`[${sport.name}] No cached data available for scheduled analysis ‚Äî skipping`);
                        continue;
                    }

                    console.log(`[${sport.name}] Using cached games: ${games.length}`);
                    for (const game of games) {
                        try {
                            const gameDate = new Date(game.commence_time);
                            if (gameDate.toDateString() !== today.toDateString()) continue; // Only today
                            const pick = await ai.analyzeGame(game);
                            console.log(`[${sport.name}] Game:`, game.id || game, 'Pick:', pick);
                            if (pick) {
                                pick.sport = sport.name;
                                pick.sportEmoji = sport.emoji;
                                newPredictions.push(pick);
                            }
                        } catch (gerr) {
                            console.warn(`Error analyzing game for ${sport.name}:`, gerr);
                        }
                    }
                } catch (error) {
                    console.error(`Error during scheduled analysis for ${sport.name}:`, error);
                }
            }
            if (newPredictions.length > 0) {
                predictions.push(...newPredictions);
                predictions.sort((a, b) => b.confidence - a.confidence);
                savePredictions();
                displayPredictions && displayPredictions();
            }
            showNotification('üîç 6am: Analyzed today\'s games.', 'success');
        }

        // Settle only today's bets
        async function settleTodaysBets() {
            if (predictions.length === 0) return;
            const today = new Date();
            for (const pred of predictions) {
                if (pred.settled) continue;
                const gameDate = new Date(pred.gameTime);
                if (gameDate.toDateString() !== today.toDateString()) continue;
                // Settle this prediction (reuse your existing settle logic or call API as needed)
                // For simplicity, call settleBets(true) which will handle all unsettled bets for today
            }
            await settleBets(true);
            showNotification('‚úÖ 11pm: Settled today\'s results and updated AI.', 'success');
        }

        // Start the 2-call-per-day AI schedule on page load
        window.addEventListener('DOMContentLoaded', scheduleAIActions);
// Analyze all games for learning (no bets placed, just model update)
async function analyzeGamesForLearning() {
    const apiCheck = canMakeApiCall(8);
    if (!apiCheck.allowed) return;

    const sports = [
        { key: 'americanfootball_nfl', name: 'NFL', emoji: 'üèà' },
        { key: 'basketball_nba', name: 'NBA', emoji: 'üèÄ' },
        { key: 'icehockey_nhl', name: 'NHL', emoji: 'üèí' },
        { key: 'baseball_mlb', name: 'MLB', emoji: '‚öæ' },
        { key: 'americanfootball_ncaaf', name: 'NCAAF', emoji: 'üéì' },
        { key: 'soccer_epl', name: 'EPL', emoji: '‚öΩ' },
        { key: 'soccer_usa_mls', name: 'MLS', emoji: '‚öΩ' },
        { key: 'soccer_uefa_champs_league', name: 'UCL', emoji: '‚öΩ' }
    ];

    for (const sport of sports) {
        try {
            const activeKey = getActiveApiKey();
            const url = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${activeKey.key}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`;
            let games = apiCache.get(sport.key);
            if (!games) {
                const response = await fetch(url);
                trackApiCall();
                if (!response.ok) continue;
                games = await response.json();
                apiCache.set(sport.key, games, 5);
            }
            for (const game of games) {
                // Let the AI analyze for learning, but do NOT add predictions
                await ai.analyzeGame(game);
            }
        } catch (error) {
            console.error(`Error learning from ${sport.name}:`, error);
        }
    }
        // After learning, update model and stats
        runLearningCycle && runLearningCycle();
        updateStats && updateStats();
    }
            // Analyze games, but only add elite "money maker" bets
            async function analyzeGamesEliteOnly() {
            const apiCheck = canMakeApiCall(8);
            if (!apiCheck.allowed) return;

            // All sports to analyze
            const sports = [
                { key: 'americanfootball_nfl', name: 'NFL', emoji: 'üèà' },
                { key: 'basketball_nba', name: 'NBA', emoji: 'üèÄ' },
                { key: 'icehockey_nhl', name: 'NHL', emoji: 'üèí' },
                { key: 'baseball_mlb', name: 'MLB', emoji: '‚öæ' },
                { key: 'americanfootball_ncaaf', name: 'NCAAF', emoji: 'üéì' },
                { key: 'soccer_epl', name: 'EPL', emoji: '‚öΩ' },
                { key: 'soccer_usa_mls', name: 'MLS', emoji: '‚öΩ' },
                { key: 'soccer_uefa_champs_league', name: 'UCL', emoji: '‚öΩ' }
            ];

            const newPredictions = [];
            const existingGameIds = new Set(predictions.map(p => p.gameId));
            const existingMLTeams = new Map();
            predictions.forEach(p => {
                if (p.type === 'Moneyline') {
                    existingMLTeams.set(p.team, p.opponent);
                }
            });

            for (const sport of sports) {
                try {
                    const activeKey = getActiveApiKey();
                    const url = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${activeKey.key}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`;
                    let games = apiCache.get(sport.key);
                    if (!games) {
                        const response = await fetch(url);
                        trackApiCall();
                        if (!response.ok) continue;
                        games = await response.json();
                        apiCache.set(sport.key, games, 5);
                    }
                    for (const game of games) {
                        if (existingGameIds.has(game.id)) continue;
                        const gameDate = new Date(game.commence_time);
                        const now = new Date();
                        const hoursUntilGame = (gameDate - now) / (1000 * 60 * 60);
                        if (hoursUntilGame > 24) continue;
                        const pick = await ai.analyzeGame(game);
                        if (pick && pick.superElite) {
                            // Only add elite money maker bets
                            if (pick.type === 'Moneyline') {
                                if (existingMLTeams.has(pick.team) || existingMLTeams.has(pick.opponent)) continue;
                            }
                            pick.sport = sport.name;
                            pick.sportEmoji = sport.emoji;
                            newPredictions.push(pick);
                            showNotification('üí∞ ELITE MONEY MAKER BET ADDED! ' + pick.game, 'success');
                        }
                    }
                } catch (error) {
                    console.error(`Error analyzing ${sport.name}:`, error);
                }
            }
            if (newPredictions.length > 0) {
                predictions.push(...newPredictions);
                predictions.sort((a, b) => b.confidence - a.confidence);
                savePredictions();
                displayPredictions && displayPredictions();
            }
        }


        // Start the automatic AI cycle on page load (use existing scheduler)
        window.addEventListener('DOMContentLoaded', () => {
            try { scheduleAIActions(); } catch (e) { console.warn('scheduleAIActions failed to start', e); }
        });
        // Initialize AutoMode UI state
        window.addEventListener('DOMContentLoaded', updateAutoModeUI);

        // Service Worker: Listen for background sync or message to trigger learning/model update
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.ready.then(reg => {
                if (reg.active) {
                    navigator.serviceWorker.addEventListener('message', event => {
                        if (event.data && event.data.type === 'AI_LEARN') {
                            // Settle bets and run learning/model update in background
                            settleBets(true).then(() => {
                                runLearningCycle && runLearningCycle();
                                updateStats && updateStats();
                            });
                        }
                    });
                }
            });
        }
        
        // API-Sports: Fetch backup data for all sports (100 calls/day each)
        async function fetchApiSportsData(sportType) {
            const sportsUsage = getApiSportsUsage();
            
            if (!API_SPORTS_ENDPOINTS[sportType]) {
                console.log(`‚ùå Sport type ${sportType} not supported`);
                return [];
            }
            
            if (sportsUsage[sportType].count >= sportsUsage[sportType].limit) {
                console.log(`‚ö†Ô∏è API-Sports ${sportType} daily limit reached`);
                return [];
            }
            
            try {
                const endpoint = API_SPORTS_ENDPOINTS[sportType];
                let data = [];
                
                // Fetch based on sport type
                if (sportType === 'football') {
                    // Soccer leagues
                    const leagues = [39, 140, 78, 135, 61]; // Premier, La Liga, Bundesliga, Serie A, Ligue 1
                    const response = await fetch(`${endpoint.url}/fixtures?league=${leagues[0]}&season=2025&next=10`, {
                        headers: {
                            'x-rapidapi-key': API_SPORTS_KEY,
                            'x-rapidapi-host': endpoint.url.replace('https://', '')
                        }
                    });
                    trackApiSportsCall('football');
                    if (response.ok) data = await response.json();
                    
                } else if (sportType === 'basketball') {
                    // NBA games
                    const response = await fetch(`${endpoint.url}/games?league=12&season=2024-2025`, {
                        headers: {
                            'x-rapidapi-key': API_SPORTS_KEY,
                            'x-rapidapi-host': endpoint.url.replace('https://', '')
                        }
                    });
                    trackApiSportsCall('basketball');
                    if (response.ok) data = await response.json();
                    
                } else if (sportType === 'baseball') {
                    // MLB games
                    const response = await fetch(`${endpoint.url}/games?league=1&season=2025`, {
                        headers: {
                            'x-rapidapi-key': API_SPORTS_KEY,
                            'x-rapidapi-host': endpoint.url.replace('https://', '')
                        }
                    });
                    trackApiSportsCall('baseball');
                    if (response.ok) data = await response.json();
                    
                } else if (sportType === 'americanfootball') {
                    // NFL games
                    const response = await fetch(`${endpoint.url}/games?league=1&season=2024`, {
                        headers: {
                            'x-rapidapi-key': API_SPORTS_KEY,
                            'x-rapidapi-host': endpoint.url.replace('https://', '')
                        }
                    });
                    trackApiSportsCall('americanfootball');
                    if (response.ok) data = await response.json();
                    
                } else if (sportType === 'hockey') {
                    // NHL games
                    const response = await fetch(`${endpoint.url}/games?league=57&season=2024`, {
                        headers: {
                            'x-rapidapi-key': API_SPORTS_KEY,
                            'x-rapidapi-host': endpoint.url.replace('https://', '')
                        }
                    });
                    trackApiSportsCall('hockey');
                    if (response.ok) data = await response.json();
                }
                
                console.log(`üéØ API-Sports ${sportType}: Fetched backup data`);
                return data;
                
            } catch (error) {
                console.error(`‚ùå API-Sports ${sportType} error:`, error);
                return [];
            }
        }
        
        // selectSport removed (API-Sports logic)
        
        async function analyzeGames() {
            const btn = document.getElementById('analyzeBtn');
            
            // Check if analyzed recently (recommend once per day)
            const lastAnalyzed = localStorage.getItem('lastAnalyzed');
            const now = Date.now();
            if (lastAnalyzed) {
                const hoursSince = (now - parseInt(lastAnalyzed)) / (1000 * 60 * 60);
                if (hoursSince < 12) {
                    const hoursRemaining = (12 - hoursSince).toFixed(1);
                    if (!confirm(`‚è∞ You analyzed ${hoursSince.toFixed(1)} hours ago.\n\nüí° Best Practice: Analyze once per day to save API calls.\n\nContinue anyway? (Uses 5 API calls)\n\nRecommended wait: ${hoursRemaining} more hours`)) {
                        return;
                    }
                }
            }
            
            btn.disabled = true;
            btn.innerHTML = '<div class="text-lg">‚è≥ Analyzing...</div><div class="text-xs opacity-90">Checking all 8 sports...</div>';
            
            // CHECK API LIMIT BEFORE STARTING
            const apiCheck = canMakeApiCall(8); // Checking 8 sports (NFL, NBA, NHL, MLB, NCAAF, EPL, MLS, UCL)
            if (!apiCheck.allowed) {
                btn.disabled = false;
                btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
                alert(`‚ö†Ô∏è API Limit Reached!\n\nYou've used ${apiCheck.current}/${apiCheck.limit} API calls this month.\nRemaining: ${apiCheck.remaining} calls\n\nThe system will use cached data when possible.\nLimit resets next month.`);
                return;
            }
            
            if (apiCheck.remaining <= 50) {
                showNotification(`‚ö†Ô∏è Low API calls: ${apiCheck.remaining} remaining`, 'warning');
            }
            
            // Track this analysis
            localStorage.setItem('lastAnalyzed', now.toString());
            
            try {
                // All sports to analyze
                const sports = [
                    { key: 'americanfootball_nfl', name: 'NFL', emoji: 'üèà' },
                    { key: 'basketball_nba', name: 'NBA', emoji: 'üèÄ' },
                    { key: 'icehockey_nhl', name: 'NHL', emoji: 'üèí' },
                    { key: 'baseball_mlb', name: 'MLB', emoji: '‚öæ' },
                    { key: 'americanfootball_ncaaf', name: 'NCAAF', emoji: 'üéì' },
                    { key: 'soccer_epl', name: 'EPL', emoji: '‚öΩ' },
                    { key: 'soccer_usa_mls', name: 'MLS', emoji: '‚öΩ' },
                    { key: 'soccer_uefa_champs_league', name: 'UCL', emoji: '‚öΩ' }
                ];
                
                const newPredictions = [];
                const existingGameIds = new Set(predictions.map(p => p.gameId));
                
                // Track existing ML bets by team to prevent contradictions
                const existingMLTeams = new Map();
                predictions.forEach(p => {
                    if (p.type === 'Moneyline') {
                        // Store the team and opponent for this ML bet
                        existingMLTeams.set(p.team, p.opponent);
                    }
                });
                
                for (const sport of sports) {
                    console.log(`Analyzing ${sport.name}...`);
                    
                    try {
                        const activeKey = getActiveApiKey();
                        const url = `https://api.the-odds-api.com/v4/sports/${sport.key}/odds?apiKey=${activeKey.key}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`;
                        
                        // Check cache first
                        let games = apiCache.get(sport.key);
                        if (!games) {
                            const response = await fetch(url);
                            trackApiCall(); // Count this API request
                            console.log(`üì° Using ${activeKey.name} API Key (${activeKey.count}/${activeKey.limit})`);
                            if (!response.ok) {
                                console.warn(`${sport.name}: API response not ok`, response.status, response.statusText);
                                continue;
                            }
                            games = await response.json();
                            apiCache.set(sport.key, games, 5); // Cache for 5 minutes
                            console.log(`${sport.name}: ${Array.isArray(games) ? games.length : 0} games (from API)`);
                        } else {
                            console.log(`${sport.name}: ${Array.isArray(games) ? games.length : 0} games (from cache ‚ö°)`);
                        }
                        if (!Array.isArray(games) || games.length === 0) {
                            console.warn(`${sport.name}: No games returned from Odds API.`);
                            continue;
                        }
                        // Process games sequentially to handle async weather API
                        let added = 0;
                        for (const game of games) {
                            if (existingGameIds.has(game.id)) {
                                console.log(`Skipping ${game.id} - already have prediction`);
                                continue;
                            }
                            const pick = await ai.analyzeGame(game);
                                if (pick) {
                                pick.sport = sport.name;
                                pick.sportEmoji = sport.emoji;
                                pick.reasoning = pick.reasoning || (pick.aiReasoning ? pick.aiReasoning : 'No detailed reasoning provided.');
                                newPredictions.push(pick);
                                added++;
                            } else {
                                console.log(`No pick generated for game:`, game);
                            }
                        }
                        console.log(`${sport.name}: ${added} predictions added from ${games.length} games.`);
                    } catch (error) {
                        console.error(`Error analyzing ${sport.name}:`, error);
                    }
                }
                
                console.log(`Generated ${newPredictions.length} new predictions`);
                console.log(`Keeping ${predictions.length} existing predictions`);
                
                if (newPredictions.length === 0) {
                    const msg = predictions.length > 0 
                        ? `‚è∞ No new high-value bets found. Keeping your ${predictions.length} active predictions!`
                        : '‚è∞ No high-value bets found across all sports. AI is being selective!';
                    alert(msg);
                    btn.disabled = false;
                    btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
                    return;
                }
                
                const oldCount = predictions.length;
                
                // Sort new predictions by confidence
                newPredictions.sort((a, b) => b.confidence - a.confidence);
                
                // Add ALL new predictions to existing ones (keep ALL old ones)
                predictions.push(...newPredictions);
                
                // Sort all predictions by confidence
                predictions.sort((a, b) => b.confidence - a.confidence);
                
                // Save to localStorage
                savePredictions();
                
                console.log(`Total predictions: ${predictions.length} (${oldCount} kept + ${newPredictions.length} new)`);
                
                displayPredictions();
                updateBankrollUI();
                
                // Only show tier breakdown if AI has earned it
                const aiWinRate = ai.model.totalBets > 0 ? (ai.model.wins / ai.model.totalBets) : 0;
                let alertMsg = `‚úÖ Added ${newPredictions.length} new bets! Total active: ${predictions.length} (kept ${oldCount} existing)\n\n`;
                
                if (aiWinRate >= 0.95 && ai.model.totalBets >= 30) {
                    const superElite = newPredictions.filter(p => p.superElite).length;
                    if (superElite > 0) {
                        alertMsg += `\nüí∞üíéüí∞ AI MASTER MODE ACTIVE! üí∞üíéüí∞\n`;
                        alertMsg += `${superElite} MONEY MAKER BET${superElite > 1 ? 'S' : ''}!\n`;
                        alertMsg += `AI Win Rate: ${(aiWinRate * 100).toFixed(1)}% üî•\n`;
                    }
                } else if (aiWinRate >= 0.80 && ai.model.totalBets >= 30) {
                    const eliteBets = newPredictions.filter(p => p.confidence >= 95).length;
                    const premiumBets = newPredictions.filter(p => p.confidence >= 85 && p.confidence < 95).length;
                    const strongBets = newPredictions.filter(p => p.confidence >= 75 && p.confidence < 85).length;
                    if (eliteBets > 0) alertMsg += `üíé ELITE bets (95%+): ${eliteBets}\n`;
                    if (premiumBets > 0) alertMsg += `üî• PREMIUM bets (85-94%): ${premiumBets}\n`;
                    if (strongBets > 0) alertMsg += `‚≠ê STRONG bets (75-84%): ${strongBets}\n`;
                } else {
                    alertMsg += `üß† AI is learning... (${ai.model.totalBets} bets analyzed)\n`;
                    const betsNeeded = Math.max(0, 30 - ai.model.totalBets);
                    if (betsNeeded > 0) {
                        alertMsg += `Need ${betsNeeded} more bets for statistical significance\n`;
                    }
                    const usage = getApiUsage();
                    alertMsg += `API Usage: ${usage.count}/${usage.limit} this month`;
                }
                
                alert(alertMsg);
                
            } catch (error) {
                console.error('Full error:', error);
                alert('Error fetching games: ' + error.message + '\n\nCheck browser console for details.');
            }
            
            btn.disabled = false;
            btn.innerHTML = '<div class="text-lg">üîç Analyze Games</div><div class="text-xs opacity-90">Find value bets with AI</div>';
        }
        
        function displayPredictions() {
            const container = document.getElementById('predictions');
            
            // Apply confidence filter
            const filteredPredictions = predictions.filter(p => p.confidence >= minConfidenceFilter);
            
            if (filteredPredictions.length === 0) {
                if (predictions.length > 0 && minConfidenceFilter > 0) {
                    container.innerHTML = `<div class="text-center text-gray-400 py-8">No bets match ${minConfidenceFilter}%+ confidence filter. ${predictions.length} bets hidden.</div>`;
                } else {
                    container.innerHTML = '<div class="text-center text-gray-400 py-8">No high-value bets found. AI is being selective! üéØ</div>';
                }
                return;
            }
            
            container.innerHTML = filteredPredictions.map((p, i) => {
                // Ensure all properties exist
                const betType = p.type || 'Moneyline';
                const betDetails = p.betDetails || `${p.team} to Win`;
                const sportDisplay = p.sport ? `${p.sportEmoji || ''} ${p.sport}` : '';
                const gameDate = new Date(p.gameTime);
                const now = new Date();
                const isToday = gameDate.toDateString() === now.toDateString();
                const isTomorrow = gameDate.toDateString() === new Date(now.getTime() + 86400000).toDateString();
                
                let dateStr = '';
                if (isToday) dateStr = 'Today';
                else if (isTomorrow) dateStr = 'Tomorrow';
                else dateStr = gameDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                
                const timeStr = gameDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                
                // Calculate potential payout for display
                const odds = p.odds || 0;
                let payout100 = 0;
                let payout500 = 0;
                let payout1000 = 0;
                if (odds > 0) {
                    payout100 = 100 + (100 * odds / 100);
                    payout500 = 500 + (500 * odds / 100);
                    payout1000 = 1000 + (1000 * odds / 100);
                } else if (odds < 0) {
                    payout100 = 100 + (100 * 100 / Math.abs(odds));
                    payout500 = 500 + (500 * 100 / Math.abs(odds));
                    payout1000 = 1000 + (1000 * 100 / Math.abs(odds));
                }
                
                // Determine border color based on confidence tier and AI mastery
                let borderClass = 'border-gray-200';
                let bgClass = '';
                if (p.settled) {
                    borderClass = p.won ? 'border-green-400' : 'border-red-400';
                    bgClass = p.won ? 'bg-green-50' : 'bg-red-50';
                } else if (p.superElite && p.showTier) {
                    // AI has 95%+ win rate - SUPER OBVIOUS
                    borderClass = 'border-8 border-yellow-400 shadow-2xl animate-pulse';
                    bgClass = 'bg-gradient-to-r from-yellow-100 via-green-100 to-yellow-100';
                } else if (p.showTier && p.confidence >= 95) {
                    borderClass = 'border-purple-500 shadow-lg';
                    bgClass = 'bg-gradient-to-r from-purple-50 to-pink-50';
                } else if (p.showTier && p.confidence >= 85) {
                    borderClass = 'border-orange-500';
                    bgClass = 'bg-orange-50';
                } else if (p.showTier && p.confidence >= 75) {
                    borderClass = 'border-yellow-400';
                    bgClass = 'bg-yellow-50';
                }
                
                return `
                <div class="prediction-card glass-card ${borderClass} ${bgClass} hover:shadow-lg transition slide-in">
                    <div class="card-diamond">${p.diamond ? `<span class="inline-block px-2 py-1 diamond-badge">üíé DIAMOND</span>` : ''}</div>
                    <!-- Super Elite Money Alert (AI-Learned Pattern) -->
                    ${p.superElite && !p.settled ? `
                        <div class="mb-3 p-4 bg-gradient-to-r from-yellow-400 via-green-400 to-yellow-400 rounded-lg border-4 border-yellow-600 animate-pulse">
                            <div class="text-center">
                                <div class="text-3xl mb-2">üí∞ üíé üí∞ MONEY MAKER üí∞ üíé üí∞</div>
                                <div class="text-lg font-black text-gray-900">AI LEARNED PATTERN - ${p.confidence.toFixed(0)}% CONFIDENCE</div>
                                ${p.moneyMakerScore ? `<div class="text-sm font-bold text-gray-800">Pattern Match: ${p.moneyMakerScore.toFixed(0)}%</div>` : ''}
                                ${p.moneyMakerFactors && p.moneyMakerFactors.length > 0 ? `
                                    <div class="text-xs text-gray-800 mt-2 font-semibold">
                                        üß† AI Why: ${p.moneyMakerFactors.join(' ‚Ä¢ ')}
                                    </div>
                                ` : ''}
                                <div class="text-sm font-bold text-gray-800 mt-2">POTENTIAL PAYOUT:</div>
                                <div class="flex justify-around mt-2 text-gray-900 font-bold">
                                    <div>$100 ‚Üí <span class="text-green-700 text-xl">$${payout100.toFixed(0)}</span></div>
                                    <div>$500 ‚Üí <span class="text-green-700 text-xl">$${payout500.toFixed(0)}</span></div>
                                    <div>$1000 ‚Üí <span class="text-green-700 text-2xl">$${payout1000.toFixed(0)}</span></div>
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- High Probability Alert (AI-Learned but not quite Money Maker) -->
                    ${p.highProbability && !p.superElite && !p.settled ? `
                        <div class="mb-3 p-3 bg-gradient-to-r from-orange-400 to-red-400 rounded-lg border-2 border-orange-600">
                            <div class="text-center">
                                <div class="text-2xl mb-1">üî• HIGH PROBABILITY üî•</div>
                                <div class="text-sm font-bold text-white">AI Pattern Match: ${p.moneyMakerScore.toFixed(0)}%</div>
                                ${p.moneyMakerFactors && p.moneyMakerFactors.length > 0 ? `
                                    <div class="text-xs text-white mt-1">
                                        üß† ${p.moneyMakerFactors.slice(0, 2).join(' ‚Ä¢ ')}
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    ` : ''}
                    
                    <!-- Confidence Tier Badge (Only if AI earned it with 80%+ win rate) -->
                    ${p.showTier && p.confidenceTier && !p.settled && !p.superElite ? `
                        <div class="flex items-center justify-between mb-2">
                            <div class="inline-block ${p.confidence >= 95 ? 'bg-gradient-to-r from-purple-600 to-pink-600' : p.confidence >= 85 ? 'bg-gradient-to-r from-orange-500 to-red-500' : 'bg-gradient-to-r from-yellow-500 to-orange-500'} text-white text-xs font-bold px-3 py-1 rounded-full">
                                ${p.confidenceTier} ${p.tierName} BET
                            </div>
                            ${sportDisplay ? `<div class="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-2 py-1 rounded">${sportDisplay}</div>` : ''}
                        </div>
                    ` : `
                        ${sportDisplay ? `<div class="inline-block bg-blue-100 text-blue-800 text-xs font-bold px-2 py-1 rounded mb-2">${sportDisplay}</div>` : ''}
                    `}
                    
                    <!-- Game Header -->
                    <div class="card-top mb-3">
                        <div class="emoji-badge card-emoji">${p.settled ? (p.won ? '‚úÖ' : '‚ùå') : (p.confidenceTier || 'üìä')}</div>
                        <div class="flex-1">
                            <div class="card-title gradient-text truncate">${p.game}</div>
                            <div class="card-sub">üìÖ ${dateStr} ‚Ä¢ ${timeStr} ${p.settled ? `<span class="ml-2 font-bold ${p.won ? 'text-green-600' : 'text-red-600'}">${p.won ? 'WON' : 'LOST'}</span>` : '<span class="ml-2 text-orange-600">PENDING</span>'}</div>
                        </div>
                        ${p.showTier && !p.superElite ? `
                            <div class="text-right">
                                <div class="text-xs text-gray-400">Confidence</div>
                                <div class="text-2xl font-bold ${p.confidence >= 85 ? 'text-green-600' : 'text-purple-600'}">${p.confidence.toFixed(0)}%</div>
                            </div>
                        ` : !p.settled ? `
                            <div class="text-right">
                                <div class="text-xs text-gray-400">Status</div>
                                <div class="text-sm font-bold text-blue-600">üß† Learning</div>
                            </div>
                        ` : ''}

                    
                    </div>
                    
                    ${p.settled && p.finalScore ? `
                    <div class="mb-3 p-2 bg-gray-100 rounded text-center">
                        <div class="text-xs text-gray-500">Final Score</div>
                        <div class="font-bold text-sm text-gray-900">${p.finalScore}</div>
                        ${p.closingOdds && p.openingOdds && p.closingOdds !== p.openingOdds ? `
                            <div class="text-xs mt-1 ${p.closingOdds > p.openingOdds ? 'text-green-600' : 'text-red-600'}">
                                CLV: ${p.openingOdds > 0 ? '+' : ''}${p.openingOdds} ‚Üí ${p.closingOdds > 0 ? '+' : ''}${p.closingOdds}
                                ${p.closingOdds > p.openingOdds ? '‚úì Beat closing line!' : '‚úó Worse than close'}
                            </div>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <!-- Bet Details - PROMINENT DISPLAY -->
                    <div class="bg-gradient-to-r from-purple-600 to-blue-600 text-white rounded-lg p-3 mb-3">
                        <div class="flex justify-between items-center mb-1">
                            <div class="text-xs font-semibold opacity-90">üìå ${betType.toUpperCase()}</div>
                            ${p.units && !p.settled ? `<div class="text-xs font-bold bg-white bg-opacity-20 px-2 py-1 rounded">${p.units} UNIT${p.units > 1 ? 'S' : ''}</div>` : ''}
                        </div>
                        <div class="text-xl font-bold">${betDetails}</div>
                        <div class="text-sm opacity-90 mt-1">@ ${p.odds > 0 ? '+' : ''}${p.odds}</div>
                    </div>
                    
                    <!-- Sportsbook Comparison -->
                    ${!p.settled && p.bestBook ? `
                    <div class="mb-3 p-3 bg-green-50 border-2 border-green-200 rounded-lg">
                        <div class="text-xs font-bold text-green-800 mb-2">üèÜ BEST LINE FOUND:</div>
                        <div class="flex justify-between items-center">
                            <div class="font-bold text-green-700">${p.bestBook}</div>
                            <div class="text-xl font-black text-green-600">${p.odds > 0 ? '+' : ''}${p.odds}</div>
                        </div>
                        ${p.allBooks && p.allBooks.length > 1 ? `
                            <details class="mt-2">
                                <summary class="text-xs text-gray-600 cursor-pointer hover:text-gray-800">Compare ${p.allBooks.length} sportsbooks</summary>
                                <div class="mt-2 space-y-1">
                                    ${p.allBooks.sort((a, b) => b.odds - a.odds).map(b => `
                                        <div class="flex justify-between text-xs ${b.book === p.bestBook ? 'font-bold text-green-700' : 'text-gray-600'}">
                                            <span>${b.book}</span>
                                            <span>${b.odds > 0 ? '+' : ''}${b.odds}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </details>
                        ` : ''}
                    </div>
                    ` : ''}
                    
                    <!-- AI Reasoning (collapsible to reduce noise) -->
                    ${(() => {
                        const reasons = Array.isArray(p.aiReasoning) ? p.aiReasoning : (p.aiReasoning ? [p.aiReasoning] : []);
                        if (!p.settled && reasons.length > 0) {
                            return `
                    <details class="mb-3" open>
                        <summary class="text-sm font-semibold text-blue-800 cursor-pointer">üß† AI reasoning ‚Äî expand for details</summary>
                        <div class="mt-2 p-3 bg-blue-50 border-2 border-blue-200 rounded-lg">
                            <ul class="space-y-1 text-sm text-blue-700">
                                ${reasons.map(reason => `
                                    <li>‚Ä¢ ${reason}</li>
                                `).join('')}
                            </ul>
                        </div>
                    </details>
                    `;
                        }
                        return '';
                    })()}
                    
                    <!-- Stats Grid -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-2 text-center">
                        <div class="rounded p-2" style="background: linear-gradient(90deg,#ecfccb,#bbf7d0);">
                            <div class="text-xs text-green-800">Best Odds</div>
                            <div class="font-bold text-green-900">${p.odds > 0 ? '+' : ''}${p.odds}</div>
                        </div>
                        <div class="rounded p-2" style="background: linear-gradient(90deg,#fff7ed,#ffedd5);">
                            <div class="text-xs text-orange-800">Value</div>
                            <div class="font-bold text-orange-900">+${p.discrepancy}%</div>
                        </div>
                        <div class="rounded p-2" style="background: linear-gradient(90deg,#eef2ff,#e0e7ff);">
                            <div class="text-xs text-blue-800">Win Prob</div>
                            <div class="font-bold text-blue-900">${p.implied}%</div>
                        </div>
                    </div>
                    
                    ${p.confidence > 70 ? '<div class="mt-2 text-center text-xs text-green-600 font-bold">‚ú® HIGH CONFIDENCE BET</div>' : ''}
                </div>
                `;
            }).join('');
        }
        
        async function settleBets(silentMode = false) {
            if (predictions.length === 0) {
                if (!silentMode) alert('No predictions to settle. Analyze games first!');
                return;
            }
            
            // Warn about manual settlement (suggest auto-settle)
            if (!silentMode) {
                const confirm = window.confirm(`üí° Manual Settlement uses 5 API calls.\n\n‚úÖ Recommended: Let Auto-Settle handle this!\nAuto-settle checks when games finish automatically.\n\nüìä Current API Usage: ${getApiUsage().count}/500 calls\n\nContinue with manual settlement?`);
                if (!confirm) return;
            }
            
            // Show settlement log
            const logDiv = document.getElementById('settlementLog');
            const logContent = document.getElementById('logContent');
            if (!silentMode) {
                logDiv.classList.remove('hidden');
                logContent.innerHTML = '';
            }
            
            function addLog(message, type = 'info') {
                const colors = {
                    info: 'text-blue-600',
                    success: 'text-green-600',
                    warning: 'text-orange-600',
                    error: 'text-red-600',
                    header: 'font-bold text-purple-600'
                };
                if (!silentMode && logContent) {
                    const log = document.createElement('div');
                    log.className = `font-mono text-xs mb-1 ${colors[type] || ''}`;
                    log.textContent = message;
                    logContent.appendChild(log);
                    logContent.scrollTop = logContent.scrollHeight;
                }
                console.log(message);
            }

            // --- Settlement Logic ---
            try {
                addLog('üîç Starting settlement process...', 'header');
                // For each unsettled prediction, get result from Odds API
                const unsettled = predictions.filter(p => !p.settled);
                if (unsettled.length === 0) {
                    addLog('‚úÖ All bets settled!', 'success');
                    if (!silentMode) showNotification('‚úÖ All bets settled!', 'success');
                    if (!silentMode) {
                        btn.disabled = false;
                        btn.innerHTML = '<div class="text-lg">‚úÖ Settle Results</div><div class="text-xs opacity-90">Get real game outcomes</div>';
                    }
                    return;
                }
                // Map human-readable sport names to Odds API sport keys
                const oddsSportMap = {
                    'NFL': 'americanfootball_nfl',
                    'NBA': 'basketball_nba',
                    'NHL': 'icehockey_nhl',
                    'MLB': 'baseball_mlb',
                    'NCAAF': 'americanfootball_ncaaf',
                    'EPL': 'soccer_epl',
                    'MLS': 'soccer_usa_mls',
                    'UCL': 'soccer_uefa_champs_league'
                };
                // Group by Odds API sport key for efficient API calls
                const sportsToCheck = [...new Set(unsettled.map(p => {
                    const name = p.sport || p.sportKey || '';
                    return oddsSportMap[name] || name;
                }))];
                for (const sportKey of sportsToCheck) {
                    const sportPreds = unsettled.filter(p => {
                        const name = p.sport || p.sportKey || '';
                        return (oddsSportMap[name] || name) === sportKey;
                    });
                    if (sportPreds.length === 0) continue;
                    // Try to get results for this sport
                    const activeKey = getActiveApiKey();
                    // Try both /scores and /odds endpoints for robustness
                    const urls = [
                        `https://api.the-odds-api.com/v4/sports/${sportKey}/scores?apiKey=${activeKey.key}&daysFrom=3`,
                        `https://api.the-odds-api.com/v4/sports/${sportKey}/odds?apiKey=${activeKey.key}&regions=us&markets=h2h,spreads,totals&oddsFormat=american`
                    ];
                    let results = [];
                    for (const url of urls) {
                        let res = apiCache.get(url);
                        if (!res) {
                            const response = await fetch(url);
                            trackApiCall();
                            if (!response.ok) continue;
                            res = await response.json();
                            apiCache.set(url, res, 30);
                        }
                        if (Array.isArray(res)) results = results.concat(res);
                    }
                    for (const pred of sportPreds) {
                        if (pred.settled) continue;
                        // Try to match by game id, fallback to fuzzy team/date match
                        let result = results.find(r => r.id === pred.gameId);
                        if (!result) {
                            // Fuzzy match: both teams and date (case-insensitive, partial match)
                            result = results.find(r => {
                                const rDate = new Date(r.commence_time);
                                const pDate = new Date(pred.gameTime);
                                const sameDay = rDate.toDateString() === pDate.toDateString();
                                const homeMatch = r.home_team && pred.game && pred.game.toLowerCase().includes(r.home_team.toLowerCase());
                                const awayMatch = r.away_team && pred.game && pred.game.toLowerCase().includes(r.away_team.toLowerCase());
                                return sameDay && homeMatch && awayMatch;
                            });
                        }
                        if (result && (result.completed || result.scores)) {
                            // Settle bet
                            const homeScore = result.scores?.find(s => s.name === 'home')?.score ?? null;
                            const awayScore = result.scores?.find(s => s.name === 'away')?.score ?? null;
                            pred.settled = true;
                            pred.won = ai.settlePrediction(pred, result, homeScore, awayScore);
                            pred.settledAt = Date.now();
                            savePredictions();
                            showSettlementNotification(pred, pred.won, result, homeScore, awayScore, 'Auto-settled');
                        }
                    }
                }
            } catch (err) {
                addLog('‚ùå Error during settlement: ' + err.message, 'error');
                if (!silentMode) showNotification('‚ùå Error during settlement', 'error');
            }

        
        function clearAllBets() {
            if (confirm('‚ö†Ô∏è Clear all bets? This will remove all predictions but keep your AI learning data.')) {
                predictions = [];
                savePredictions();
                displayPredictions();
                alert('‚úÖ All bets cleared!');
            }
        }
        
        function runLearningCycle() {
            // Only allow learning if there are new settled but not yet learned results
            if (!predictions.some(p => p.settled && !p.learned)) {
                showNotification('No new results to learn from.', 'warning');
                return;
            }
            const insights = ai.learn();
            const container = document.getElementById('insights');
            container.innerHTML = `
                <div class="bg-gradient-to-r from-purple-50 to-blue-50 border-2 border-purple-200 rounded-lg p-6">
                    <h3 class="text-lg font-bold text-purple-900 mb-3">üéì Manual AI Learning Complete</h3>
                    <div class="text-sm text-gray-600 mb-3">
                        <strong>Note:</strong> AI learns automatically after every settlement. This button triggers an extra learning cycle.
                    </div>
                    <div class="space-y-2 text-sm text-gray-700">
                        ${insights.map(insight => `<div>‚Ä¢ ${insight}</div>`).join('')}
                    </div>
                    <div class="mt-4 text-xs text-gray-500">
                        üí° Total Learning Cycles: ${ai.model.learningCycles}
                    </div>
                </div>
            `;
            // Mark any discovered diamond patterns on predictions and refresh UI
            try {
                const found = ai.markDiamondPredictions();
                if (found && found.length) {
                    insights.unshift(`üî∂ ${found.length} diamond pattern(s) tagged.`);
                }
            } catch (e) { console.warn('Marking diamond predictions failed', e); }

            updateStats();
            updateBankrollUI();
            displayPredictions();
            createModelSnapshot && createModelSnapshot();
            
            // No alert needed; notification and panel update are sufficient
        }
        
        function updateStats() {
            const totalBets = ai.model.totalBets;
            const winRate = totalBets > 0 ? ((ai.model.wins / totalBets) * 100).toFixed(1) : '0';
            
            // Calculate best bet type
            let bestBetType = 'Learning...';
            let bestWinRate = 0;
            ['Moneyline', 'Spread', 'Total'].forEach(type => {
                const perf = ai.model.betTypePerformance[type];
                if (perf && perf.total >= 3) {
                    const typeRate = (perf.wins / perf.total) * 100;
                    if (typeRate > bestWinRate) {
                        bestWinRate = typeRate;
                        bestBetType = `${type} (${typeRate.toFixed(1)}%)`;
                    }
                }
            });
            
            // Update basic stats
            document.getElementById('totalBets').textContent = totalBets;
            document.getElementById('winRate').textContent = winRate + '%';
            document.getElementById('confidence').textContent = bestBetType;
            document.getElementById('cycles').textContent = ai.model.learningCycles;
            
            // Update progress bars with animation
            const totalBetsProgress = Math.min(100, (totalBets / 100) * 100);
            document.getElementById('totalBetsProgress').style.width = totalBetsProgress + '%';
            document.getElementById('winRateProgress').style.width = winRate + '%';
            
            // Show trend indicators
            if (ai.model.recentTrend && ai.model.recentTrend.last10.length >= 5) {
                const recentWins = ai.model.recentTrend.last10.filter(w => w).length;
                const recentWinRate = (recentWins / ai.model.recentTrend.last10.length * 100).toFixed(0);
                const trendEl = document.getElementById('winRateTrend');
                
                if (recentWinRate >= 60) {
                    trendEl.textContent = 'üî• HOT';
                    trendEl.className = 'text-xs font-bold text-green-600';
                } else if (recentWinRate <= 40) {
                    trendEl.textContent = '‚ùÑÔ∏è COLD';
                    trendEl.className = 'text-xs font-bold text-red-600';
                } else {
                    trendEl.textContent = '‚û°Ô∏è STEADY';
                    trendEl.className = 'text-xs font-bold text-gray-600';
                }
                
                // Show recent streak
                const streakEl = document.getElementById('recentStreak');
                if (ai.model.recentTrend.currentStreak >= 3) {
                    const streakEmoji = ai.model.recentTrend.streakType === 'win' ? 'üî•' : '‚ö†Ô∏è';
                    const streakText = ai.model.recentTrend.streakType === 'win' ? 'Win Streak' : 'Loss Streak';
                    const streakColor = ai.model.recentTrend.streakType === 'win' ? 'text-green-600' : 'text-red-600';
                    streakEl.textContent = `${streakEmoji} ${ai.model.recentTrend.currentStreak} ${streakText}`;
                    streakEl.className = `text-xs font-semibold mt-2 ${streakColor}`;
                } else {
                    streakEl.textContent = '';
                }
            }
            
            // Show win rate assessment
            const winRateSubtext = document.getElementById('winRateSubtext');
            if (totalBets >= 10) {
                if (winRate >= 55) {
                    winRateSubtext.textContent = 'üí∞ Profitable! (>55%)';
                    winRateSubtext.className = 'text-xs mt-1 text-green-600 font-semibold';
                } else if (winRate >= 50) {
                    winRateSubtext.textContent = '‚úÖ Break-even zone';
                    winRateSubtext.className = 'text-xs mt-1 text-yellow-600 font-semibold';
                } else {
                    winRateSubtext.textContent = 'üìö Still learning...';
                    winRateSubtext.className = 'text-xs mt-1 text-gray-600';
                }
            } else {
                winRateSubtext.textContent = 'AI accuracy';
                winRateSubtext.className = 'text-xs text-gray-400 mt-1';
            }
            
            // Show momentum indicator
            const momentumEl = document.getElementById('momentum');
            if (ai.model.weights.recentMomentum) {
                if (ai.model.weights.recentMomentum > 0) {
                    momentumEl.textContent = 'üìà Positive momentum';
                } else if (ai.model.weights.recentMomentum < 0) {
                    momentumEl.textContent = 'üìâ Adjusting strategy';
                } else {
                    momentumEl.textContent = '';
                }
            }
            
            // Update performance analytics
            updatePerformanceChart();
        }
        
        // Bankroll UI Update
        function updateBankrollUI() {
            const bankroll = ai.model.bankroll;
            if (!bankroll) return;
            
            document.getElementById('currentBankroll').textContent = '$' + bankroll.current.toFixed(2);
            
            const pnl = bankroll.current - bankroll.starting;
            const pnlElement = document.getElementById('totalPnL');
            pnlElement.textContent = (pnl >= 0 ? '+$' : '-$') + Math.abs(pnl).toFixed(2);
            pnlElement.className = pnl >= 0 ? 
                'text-2xl font-bold text-green-600 dark:text-green-400' : 
                'text-2xl font-bold text-red-600 dark:text-red-400';
            
            const roi = ((pnl / bankroll.starting) * 100).toFixed(1);
            const roiElement = document.getElementById('roiPercent');
            roiElement.textContent = roi + '%';
            roiElement.className = roi >= 0 ? 
                'text-2xl font-bold text-purple-600 dark:text-purple-400' : 
                'text-2xl font-bold text-red-600 dark:text-red-400';
            
            document.getElementById('maxDrawdown').textContent = bankroll.maxDrawdown.toFixed(1) + '%';
            
            // Show/hide stop loss alert
            const stopLossAlert = document.getElementById('stopLossAlert');
            if (bankroll.stopLossTriggered) {
                stopLossAlert.style.display = 'block';
            } else {
                stopLossAlert.style.display = 'none';
            }
        }
        
        // Performance Analytics with Chart.js
        let performanceChart = null;
        function updatePerformanceChart() {
            const ctx = document.getElementById('performanceChart');
            if (!ctx) return;
            
            // Get historical data from AI model
            const history = ai.model.performanceHistory || [];
            
            // Calculate 7-day stats
            const sevenDaysAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);
            const recentBets = history.filter(h => h.timestamp > sevenDaysAgo);
            const recentWins = recentBets.filter(h => h.won).length;
            const weekWinRate = recentBets.length > 0 ? ((recentWins / recentBets.length) * 100).toFixed(1) : '-';
            document.getElementById('weekWinRate').textContent = recentBets.length > 0 ? weekWinRate + '%' : '-';
            
            // Calculate ROI in units
            let totalUnits = 0;
            recentBets.forEach(bet => {
                const units = bet.units || 1;
                if (bet.won) {
                    // American odds to decimal conversion for profit
                    const profit = bet.odds > 0 ? (bet.odds / 100) * units : (100 / Math.abs(bet.odds)) * units;
                    totalUnits += profit;
                } else {
                    totalUnits -= units;
                }
            });
            document.getElementById('roiUnits').textContent = totalUnits > 0 ? '+' + totalUnits.toFixed(1) : totalUnits.toFixed(1);
            
            // Current streak
            const currentStreak = ai.model.recentTrend?.currentStreak || 0;
            const streakType = ai.model.recentTrend?.streakType;
            if (currentStreak >= 2) {
                document.getElementById('currentStreakDisplay').textContent = 
                    streakType === 'win' ? `üî• ${currentStreak}W` : `‚ùÑÔ∏è ${currentStreak}L`;
            } else {
                document.getElementById('currentStreakDisplay').textContent = '-';
            }
            
            // Prepare chart data (last 20 bets)
            const chartData = history.slice(-20);
            const labels = chartData.map((_, i) => `Bet ${i + 1}`);
            const winData = chartData.map(h => h.won ? 1 : 0);
            const confidenceData = chartData.map(h => h.confidence || 50);
            
            // Create or update chart
            if (performanceChart) {
                performanceChart.data.labels = labels;
                performanceChart.data.datasets[0].data = winData;
                performanceChart.data.datasets[1].data = confidenceData;
                performanceChart.update();
            } else {
                performanceChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Win/Loss',
                                data: winData,
                                borderColor: 'rgb(34, 197, 94)',
                                backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                yAxisID: 'y',
                                stepped: true
                            },
                            {
                                label: 'Confidence',
                                data: confidenceData,
                                borderColor: 'rgb(168, 85, 247)',
                                backgroundColor: 'rgba(168, 85, 247, 0.1)',
                                yAxisID: 'y1'
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        interaction: { mode: 'index', intersect: false },
                        scales: {
                            y: { type: 'linear', display: true, position: 'left', min: 0, max: 1, title: { display: true, text: 'Result' } },
                            y1: { type: 'linear', display: true, position: 'right', min: 0, max: 100, title: { display: true, text: 'Confidence %' }, grid: { drawOnChartArea: false } }
                        }
                    }
                });
            }
        }
        
        // Auto-settlement system - Smart timing to avoid API limit
        function getGameDuration(sport) {
            // Approximate game durations in minutes
            const durations = {
                'NFL': 210,      // ~3.5 hours
                'NCAAF': 210,    // ~3.5 hours
                'NBA': 150,      // ~2.5 hours
                'NHL': 150,      // ~2.5 hours
                'MLB': 180       // ~3 hours
            };
            return durations[sport] || 180;
        }
        
        function getNextSettlementTime() {
            if (predictions.length === 0) return null;
            
            const now = new Date();
            let earliestCheck = null;
            
            // Find the earliest game that should be finished
            predictions.forEach(pred => {
                const gameTime = new Date(pred.gameTime);
                const gameDuration = getGameDuration(pred.sport);
                const estimatedEndTime = new Date(gameTime.getTime() + gameDuration * 60000);
                
                // Add 15 minute buffer after estimated end
                const checkTime = new Date(estimatedEndTime.getTime() + 15 * 60000);
                
                // Only consider games that should be done or finishing soon
                if (checkTime <= new Date(now.getTime() + 4 * 60 * 60000)) { // Within next 4 hours
                    if (!earliestCheck || checkTime < earliestCheck) {
                        earliestCheck = checkTime;
                    }
                }
            });
            
            return earliestCheck;
        }
        
        async function autoSettleCheck() {
            if (predictions.length === 0) {
                console.log('‚è∞ Auto-settle: No predictions to check');
                return;
            }
            
            const now = new Date();
            const nextCheckTime = getNextSettlementTime();
            
            if (!nextCheckTime) {
                console.log('‚è∞ Auto-settle: No games finishing soon');
                scheduleNextAutoSettle();
                return;
            }
            
            if (now < nextCheckTime) {
                const minutesUntil = Math.ceil((nextCheckTime - now) / 60000);
                console.log(`‚è∞ Auto-settle: Next check in ${minutesUntil} minutes (when games should be finished)`);
                scheduleNextAutoSettle();
                return;
            }
            
            console.log('ü§ñ Auto-settling completed games...');
            
            // Track before count
            const beforeSettle = predictions.filter(p => !p.settled).length;
            
            await settleBets(true); // Pass true for silent mode
            
            // Check what was settled
            const afterSettle = predictions.filter(p => !p.settled).length;
            const settledCount = beforeSettle - afterSettle;
            
            if (settledCount > 0) {
                console.log(`‚úÖ Auto-settled ${settledCount} bets`);
            }
            
            // Schedule next check after settling
            scheduleNextAutoSettle();
        }
        
        let autoSettleTimeout = null;
        function scheduleNextAutoSettle() {
            // Clear existing timeout
            if (autoSettleTimeout) clearTimeout(autoSettleTimeout);
            // Always check at 11pm CT
            const now = new Date();
            const ctNow = new Date(now.toLocaleString('en-US', { timeZone: 'America/Chicago' }));
            const msTo11pm = (() => {
                const target = new Date(ctNow);
                target.setHours(23, 0, 0, 0);
                if (ctNow > target) target.setDate(target.getDate() + 1);
                return target - ctNow;
            })();
            autoSettleTimeout = setTimeout(() => {
                settleBets(true); // Force settle at 11pm CT
                scheduleNextAutoSettle();
            }, msTo11pm);
            const minutesUntil = Math.ceil(msTo11pm / 60000);
            console.log(`‚è∞ Auto-settle scheduled for ${minutesUntil} minutes from now (11pm CT)`);
        }
        
        // Live Odds Monitoring (API-efficient - only checks active bets within 2 hours of game start)
        let liveOddsInterval = null;
        async function startLiveOddsMonitoring() {
            // Check every 15 minutes
            liveOddsInterval = setInterval(async () => {
                const now = new Date();
                let apiCallsNeeded = 0;
                
                for (const prediction of predictions) {
                    if (prediction.status !== 'Pending') continue;
                    
                    // Only check if within 2 hours of game start (API efficiency)
                    if (ai.shouldCheckLiveOdds(prediction)) {
                        apiCallsNeeded++;
                    }
                }
                
                if (apiCallsNeeded > 0) {
                    console.log(`üìä Live odds check: ${apiCallsNeeded} active bets within 2 hours of game start`);
                    // Could fetch live odds here if needed, but respecting 500 API call limit
                    // For now, we rely on the initial odds captured at bet placement
                }
            }, 15 * 60 * 1000); // Every 15 minutes
            
            console.log('üì° Live odds monitoring started (checks active bets within 2 hours of game start)');
        }
        
        // DAILY SCHEDULED TASKS - Optimal for AI Learning & Win Rate
        // 6am CT: Analyze fresh daily games (morning prep)
        // 11pm CT: Settle all completed games (end of day learning)
        let dailyScheduleInterval = null;
        function startDailySchedule() {
            // Check every minute for scheduled tasks
            dailyScheduleInterval = setInterval(async () => {
                const now = new Date();
                
                // Convert to Central Time
                const ctTime = new Date(now.toLocaleString('en-US', { timeZone: 'America/Chicago' }));
                const hour = ctTime.getHours();
                const minute = ctTime.getMinutes();
                
                // Track if we've run today's tasks
                const today = ctTime.toDateString();
                const lastAnalysis = localStorage.getItem('lastScheduledAnalysis');
                const lastSettlement = localStorage.getItem('lastScheduledSettlement');
                
                // 6:00 AM CT - Daily Analysis (Run once per day)
                if (hour === 6 && minute === 0 && lastAnalysis !== today) {
                    console.log('üåÖ 6:00 AM CT - Running scheduled daily analysis...');
                    showNotification('üåÖ Good morning! Running daily game analysis...', 'info');
                    
                    const apiCheck = canMakeApiCall(8); // 8 sports: NFL, NBA, NHL, MLB, NCAAF, EPL, MLS, UCL
                    if (apiCheck.allowed) {
                        await analyzeGames();
                        localStorage.setItem('lastScheduledAnalysis', today);
                        showNotification(`‚úÖ Daily analysis complete! Found ${predictions.length} betting opportunities`, 'success');
                    } else {
                        console.log('‚ö†Ô∏è Skipping scheduled analysis - API limit reached');
                        showNotification('‚ö†Ô∏è Scheduled analysis skipped - API limit reached', 'warning');
                    }
                }
                
                // 11:00 PM CT - Daily Settlement (Run once per day)
                if (hour === 23 && minute === 0 && lastSettlement !== today) {
                    console.log('üåô 11:00 PM CT - Running scheduled daily settlement...');
                    showNotification('üåô End of day settlement starting...', 'info');
                    
                    const apiCheck = canMakeApiCall(8); // 8 sports: NFL, NBA, NHL, MLB, NCAAF, EPL, MLS, UCL
                    if (apiCheck.allowed && predictions.some(p => !p.settled)) {
                        const beforeCount = predictions.filter(p => !p.settled).length;
                        await settleBets(true);
                        const afterCount = predictions.filter(p => !p.settled).length;
                        const settled = beforeCount - afterCount;
                        
                        localStorage.setItem('lastScheduledSettlement', today);
                        
                        if (settled > 0) {
                            const winRate = ai.model.totalBets > 0 ? ((ai.model.wins / ai.model.totalBets) * 100).toFixed(1) : 0;
                            showNotification(`üåô Daily settlement complete! Settled ${settled} bets. AI Win Rate: ${winRate}%`, 'success');
                        }
                    } else if (!apiCheck.allowed) {
                        console.log('‚ö†Ô∏è Skipping scheduled settlement - API limit reached');
                    }
                }
            }, 60 * 1000); // Check every minute
            
            // Show initial schedule info
            const ctNow = new Date(new Date().toLocaleString('en-US', { timeZone: 'America/Chicago' }));
            console.log('üìÖ Daily Schedule Active (Central Time):');
            console.log('  üåÖ 6:00 AM - Analyze today\'s games');
            console.log('  üåô 11:00 PM - Settle completed games');
            console.log(`  ‚è∞ Current CT: ${ctNow.toLocaleTimeString()}`);
            showNotification('üìÖ Daily schedule active: 6am analysis, 11pm settlement (CT)', 'info');
        }
        
        // Initialize
        loadPredictions(); // Load saved predictions
        updateStats();
        displayPredictions(); // Display loaded predictions
        updateApiUsageDisplay(); // Show API usage
        updateStorageDisplay(); // Show storage usage
        initDarkMode(); // Initialize dark mode
        displayModelVersions(); // Show model snapshots
        
        // Check storage and cleanup if needed
        const storageUsage = getStorageUsage();
        if (storageUsage.percent > 80) {
            console.warn('‚ö†Ô∏è Storage usage high, running cleanup...');
            cleanupOldData();
            updateStorageDisplay();
        }
        
        // Request notification permission after 5 seconds
        setTimeout(() => {
            if (Notification.permission === 'default') {
                console.log('üí° Tip: Enable notifications for bet updates');
            }
        }, 5000);
        
        // Start smart auto-settlement system
        scheduleNextAutoSettle();
        
        // Start live odds monitoring (API-efficient)
        startLiveOddsMonitoring();
        
        // Start daily scheduled tasks (6am analysis, 11pm settlement)
        startDailySchedule();
        
        // Register Service Worker for background sync and offline support
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/NewBets/service-worker.js')
                .then((registration) => {
                    console.log('‚úÖ Service Worker registered successfully');
                    
                    // Request periodic background sync permission (if supported)
                    if ('periodicSync' in registration) {
                        registration.periodicSync.register('daily-betting-tasks', {
                            minInterval: 6 * 60 * 60 * 1000 // Every 6 hours
                        }).then(() => {
                            console.log('‚úÖ Periodic background sync registered');
                        }).catch((err) => {
                            console.log('‚ö†Ô∏è Periodic sync not available:', err);
                        });
                    }
                    
                    // Listen for messages from service worker
                    navigator.serviceWorker.addEventListener('message', (event) => {
                        if (event.data.type === 'RUN_ANALYSIS') {
                            console.log('üåÖ Service Worker triggered: Running analysis...');
                            analyzeGames();
                        } else if (event.data.type === 'RUN_SETTLEMENT') {
                            console.log('üåô Service Worker triggered: Running settlement...');
                            settleBets(true);
                        }
                    });
                })
                .catch((error) => {
                    console.log('‚ö†Ô∏è Service Worker registration failed:', error);
                });
        }
        
        // Check for auto-trigger from URL params
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('auto') === 'analyze') {
            console.log('üåÖ Auto-triggered: Running analysis...');
            setTimeout(() => analyzeGames(), 2000);
        } else if (urlParams.get('auto') === 'settle') {
            console.log('üåô Auto-triggered: Running settlement...');
            setTimeout(() => settleBets(true), 2000);
        }
        
        // Display version info
        console.log('üöÄ AI Betting System v5.4 ULTRA - Build: 2025-12-16 01:00 UTC');
        console.log('üÜï NEW in v5.4: Always-updating cache, improved mobile/desktop sync, and update indicator.');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üéØ 5 CRITICAL AI IMPROVEMENTS FOR 95% WIN RATE:');
        console.log('   1Ô∏è‚É£ Stricter Rejection Rules - Auto-reject bets with 2+ losing patterns');
        console.log('   2Ô∏è‚É£ API-Sports Validation - 75%+ confidence bets require both AIs to agree');
        console.log('   3Ô∏è‚É£ Recent Form Weighting - Last 5 games count 3x more than older games');
        console.log('   4Ô∏è‚É£ CLV Tracking - Learn and boost bets with positive closing line value');
        console.log('   5Ô∏è‚É£ Smart Bankroll Protection - Raise thresholds after 2+ consecutive losses');
        console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
        console.log('üß† ADVANCED AI: Bayesian Updates ¬∑ Kelly Criterion ¬∑ Ensemble Learning ¬∑ Time-Decay ¬∑ Regression Detection');
        console.log('üíé ULTRA FEATURES: Monte Carlo ¬∑ Line Movement ¬∑ Market Efficiency ¬∑ Correlation Analysis ¬∑ Sharp Detection');
        console.log('üÜï API-Sports Multi-Sport Intelligence (500 calls/day) ¬∑ Cross-AI Validation ¬∑ Team Form Analysis');
        console.log('‚úÖ Core: Multi-bet types, Model Versioning, Export/Import, Dark Mode, Notifications');
        console.log(`üìä Loaded ${predictions.length} saved predictions`);
        console.log('üèàüèÄ‚öæüèí‚öΩ API-Sports covers: NFL, NBA, MLB, NHL, Soccer (EPL, MLS, UCL, La Liga, Bundesliga, Serie A, Ligue 1)');
    }
    </script>
    
    <!-- Version Footer -->
    <div style="text-align: center; padding: 20px; color: rgba(255,255,255,0.7); font-size: 12px;">
        v5.4 ULTRA ‚Ä¢ Build: Dec 16, 2025 01:00 UTC ‚Ä¢ 24/7 Auto-Scheduling ‚Ä¢ Service Worker ‚Ä¢ GitHub Actions ‚Ä¢ 5 AI Improvements
    </div>
</body>
</html>